<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="Allen">


    <meta name="subtitle" content="绿衣捧砚催题卷，红袖添香伴读书">




<title>从零开始学习Vue3源码（三、Vue3响应式原理（下）） | 阿伦的个人博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



<!-- 百度统计，在head.ejs中引入 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4089b5476d9d7b1fbf81de2841dc180c";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    


<!-- 搜索 -->
<div id="algolia-search">
  <div class="search-dialog">  
    <nav class="search-nav">
      <span class="search-dialog-title">Search</span>
      <button class="search-close-button">
        <span class="iconfont icon-guanbi"></span>
      </button>
    </nav>
  
    <div class="search-wrap">
      <div id="algolia-search-input"></div>
      <hr />  
      <div id="algolia-search-results">
        <div id="algolia-hits"></div>
        <div id="algolia-pagination"></div>
        <div id="algolia-info">
          <div class="algolia-stats"></div>
          <div class="algolia-poweredBy"></div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="search-mask"></div>
  
  <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.66.1/dist/instantsearch.production.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/algoliasearch/4.23.2/algoliasearch-lite.umd.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/js/algolia.js"></script>
</div>



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="阿伦的个人博客" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
            } else {
                pagebody.classList.remove('dark-theme');
            }
            // mobile
            if (document.getElementById("mobile-toggle-theme")) {
                document.getElementById("mobile-toggle-theme").innerText = isDark ? "· Dark" : "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Allen&#39;s Blog</a></div>
            <div class="menu navbar-right">
                <!-- 其他的导航 -->
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                

                <!-- Search -->
                <span id="search-button" style="padding: 0 8px;cursor: pointer;">
                    <span class="search">Search</span>
                </span>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Allen&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">从零开始学习Vue3源码（三、Vue3响应式原理（下））</h1>
            
                <div class="post-meta">
                    
                    <!-- 
                        Author: <a itemprop="author" rel="author" href="/">Allen</a>
                     -->

                    
                        <span class="post-time">
                        
                        <!-- Date: <a href="#">三月 14, 2023&nbsp;&nbsp;11:07:06</a> -->
                        <span class="iconfont icon-date1"></span>
                        三月 14, 2023
                        </span>
                    
                    &nbsp;  &nbsp;
                    
                        <span class="post-category">
                            <span class="iconfont icon-icon-goodscategory"></span>
                            
                                <a href="/categories/Web%E5%89%8D%E7%AB%AF/">Web前端</a>
                            
                        </span>
                    
                    <!-- 展示当前文章所属tags -->
                    
                    &nbsp;  &nbsp;
                    <span class="iconfont icon-tags"></span>
                        <span>
                            
                                <a href="/tags/Vue/">Vue </a>&nbsp;
                            
                        </span>
                    
                    
                    
                        <!-- 文章字数和阅读时间 -->
<div style="display: inline;">
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-post"></span>
      <!-- <span class="post-meta-item-text">  Count: </span> -->
      <span class="post-count">7.4k Words</span>
    </span>
  </span>
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-time"></span>
      <!-- <span class="post-meta-item-text">  Time: </span> -->
      <span class="post-count">31 min</span>
    </span>
  </span>
</div>

                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章中——Vue3响应式原理]，我们基本了解了响应式的核心<code>reactive</code>和<code>effect</code>，话不多说，我们这节课将剩下的内容写完。</p>
<p>其实<code>watch</code>和<code>watchEffect</code>并不在<code>reactivity</code>响应式模块里，而是在<code>runtime-dom</code>模块里，那为啥还要在<code>reactivity</code>这个响应式模块中，来介绍这两个<code>API</code>呢？一是因为这两个<code>API</code>我们在项目中太常见，二才是最主要的，是因为<code>watch</code>和<code>watchEffect</code>都是基于上篇文章说的<code>effect</code>进行了封装，从而得到的。所以说么，<code>effect</code>是最底层的方法，弄懂了上篇文章的内容，那么这篇文章就显得相对好理解很多。</p>
<h3 id="watch的实现"><a href="#watch的实现" class="headerlink" title="watch的实现"></a><code>watch</code>的实现</h3><p>我们先在<code>reactive.ts</code>和<code>/shared/src/index.ts</code>中完善两个工具方法，方便我们在实现<code>watch</code>时进行导入调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactive.ts文件</span></span><br><span class="line"><span class="comment">// 判断传入的值是不是一个响应式的值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReactive</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !!(value &amp;&amp; value[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shared/src/index.ts 文件</span></span><br><span class="line"><span class="comment">// 判断传入的值，是不是一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isFunction</span> = value =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>/reactivity/src</code>目录下新建<code>apiWatch.ts</code>文件，来写<code>watch</code>的主逻辑。首先我们简单回顾下<code>Vue3</code>中<code>watch</code>的常见用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// 用法1：</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">name</span>, <span class="function">(<span class="params">newV, oldV</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newV, oldV)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 用法2：</span></span><br><span class="line"><span class="title function_">watch</span>(state, <span class="function">(<span class="params">newV, oldV</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newV, oldV)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么在用到<code>watch</code>的时候，第一个参数我们可以传入一个函数（如用法1）来监听某个属性的变化，有朋友可能会问，为啥要写成一个函数，我直接把第一个参数传入<code>state.name</code>不行么？醒醒，快醒醒！在这个案例中<code>state.name</code>就是个定死的值<code>张三</code>，监听常量，肯定是不会发生变化的啊；</p>
<p>同样，第一个参数还可以传入一个对象（如方法2）但是这种有几个问题，一般不推荐，比如当第一个参数传入的是对象，实际上<code>watch</code>监听的是这个对象的引用地址，所以，无法区分<code>newV</code>和<code>oldV</code>，引用的地址是一直不变的，所以打印的结果会发现，这俩值是一样的，都是最新的值。还有个小问题就是，虽然你传入参数的是一个对象，但是在<code>watch</code>方法的内部，依旧是遍历了这个对象所有的<code>key</code>，并且进行取值操作（为的是触发依赖收集）。所以会对性能有所损耗，不过有时候为了方便，还是可以这么去干的（反正内部针对这种情况做了处理，代码写的爽就行了，管他呢）。</p>
<p>我们接下来实现<code>watch</code>的逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /reactivity/src/apiWatch.ts 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; isReactive &#125; <span class="keyword">from</span> <span class="string">&#x27;./reactive&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isFunction, isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactiveEffect</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value, seen = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (seen.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  seen.<span class="title function_">add</span>(value)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 就是单纯的取了下值，比如state.name，为了触发reactive对象中属性的getter</span></span><br><span class="line">      <span class="title function_">traverse</span>(value[key], seen)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 首先导出watch方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, &#123; immediate &#125; = &#123;&#125; <span class="keyword">as</span> <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 2. 分两种情况判断，source是一个响应式对象和source是一个函数</span></span><br><span class="line">  <span class="comment">// 这个getter就相当于是effect中的回调函数</span></span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">    <span class="comment">// 3. 如果source是一个响应式对象，应该对source递归进行取值</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> oldValue</span><br><span class="line">  <span class="comment">// 6. 当触发更新的时候，也就是属性改变的时候，才会执行这个job方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>()</span><br><span class="line">    <span class="title function_">cb</span>(newValue, oldValue)</span><br><span class="line">    oldValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 当new的时候，就会执行getter方法，开始进行依赖收集，数据变化后，会执行cb的回调方法</span></span><br><span class="line">  <span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, job)</span><br><span class="line">  <span class="comment">// 需要立即执行，那么就先执行一次任务</span></span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 将立即执行的effect.run()的结果作为oldValue</span></span><br><span class="line">  oldValue = effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首版代码就算是完成了，代码虽然不多，但是为了方便理解，我们还是需要拆分每个步骤，来进行一一讲解。</p>
<ul>
<li>步骤1：很好理解，导出的<code>watch</code>，放入传参，这里第三个参数<code>options</code>我们只实现<code>immediate</code>的功能；</li>
<li>步骤2：就是上文提到的，对于传入的<code>source</code>，需要进行类型判断，如果是一个函数的话，那就让<code>getter</code>赋值为这个函数；如果是对象的话，那就用函数包一层。</li>
<li>步骤3：但是单独包一层，并不会触发依赖收集，所以就需要对这个响应式对象<code>source</code>进行遍历，然后对每个<code>key</code>进行取值，从而触发依赖收集；代码看上去的效果就是，只是取了下值，实际没有进行其他任何操作。为什么要包装成一个函数呢？别急，看到第4步就明白了。</li>
<li>步骤4：这步是不是非常熟？没错，在上篇写<code>effect</code>原理的时候，我们就是通过 <code>new ReactiveEffect(fn, options.scheduler)</code>进行生成的，所以，此步骤中，我们把<code>getter</code>当成第一个参数进行传参，把<code>job</code>当成第二个参数，也就是当响应式对象的属性发生变化时候，就会主动来调用<code>job</code>方法，如果忘了，可以再去复习下上篇文章。</li>
<li>步骤5：<code>new</code>完后，得到的<code>effect</code>，我们先执行一次<code>effect.run</code>方法，就能拿到最开始的返回值，记为<code>oldValue</code>。</li>
<li>步骤6：就是步骤4中需要传入的<code>job</code>方法，当响应式对象的属性，发生变化，才会执行这个方法，我们在其中调用<code>cb</code>，并且传入<code>oldValue</code>和<code>newValue</code>，大功告成。</li>
</ul>
<p>是不是发现，当我们理解了<code>effect</code>方法原理之后，再去写<code>watch</code>的实现，就变得非常简单了呢？所以说嘛<code>effect</code>是底层方法，很多方法都是基于它进行封装的。</p>
<p>接下来，我们再介绍一个<code>Vue3</code>中<code>watch</code>提供的一个功能，所谓新功能，不是无缘无故就出来的，一定是为了解决相关的场景，所以才会提出的新功能，我们改动下<code>index.html</code>中的示例代码，先看看如下场景，该用什么方法来解决：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timmer = <span class="number">4000</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">resolve</span>(data)</span></span><br><span class="line"><span class="language-javascript">        &#125;, timmer -= <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">age</span>, <span class="keyword">async</span> (newV, oldV) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getData</span>(newV)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span></span><br><span class="line"><span class="language-javascript">      app.<span class="property">innerHTML</span> = result</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 我们这里直接改变响应式对象属性，模拟用户输入</span></span></span><br><span class="line"><span class="language-javascript">    state.<span class="property">age</span> = <span class="number">20</span></span></span><br><span class="line"><span class="language-javascript">    state.<span class="property">age</span> = <span class="number">30</span></span></span><br><span class="line"><span class="language-javascript">    state.<span class="property">age</span> = <span class="number">40</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们来简单说一下上边代码的含义，设想一下页面里有个输入框，每次输入内容，都会发送一个请求，我们这边模拟用户改变了3次值，所以一共发送了3次请求；第一个请求历时4秒钟能拿到返回结果，第二个请求历时3秒能拿到结果，第三个请求历时2秒能拿到结果，那么我们期望的页面显示内容，是以最后一次输入的结果为准，即页面上显示的是<code>state.age = 40</code>的结果。但是根据我们现在的逻辑，会发现，页面上过2秒后确实显示的是<code>state.age = 40</code>的结果，但是又过了1秒钟，<code>state.age = 30</code>这个请求的结果又被显示到页面上，又过了1秒<code>state.age = 20</code>的结果最终显示在了页面上，那显然不合理，我们的输入框中，最后明明是<code>40</code>，但是页面显示的结果却是<code>20</code>的请求结果。</p>
<p>所以我们此时需要来解决这个问题，我们第一反应就是，能不能在每次触发新请求的时候，屏蔽上次请求的结果呢?(注意，请求已经发送了，不能取消)，这样，就能保证就算之前的请求，过了很久才拿到返回值，也不会覆盖最新的结果。那我们来在当前代码中，修改下吧!</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> timmer = <span class="number">4000</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 1. 新建数组，用于存放上一次请求需要的方法</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> arr = []</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">resolve</span>(data)</span></span><br><span class="line"><span class="language-javascript">    &#125;, timmer -= <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">age</span>, <span class="keyword">async</span> (newV, oldV) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> fn</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 2. 每次发送请求前，利用闭包，将上次的结果flag改为false，从而屏蔽结果</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">while</span>(arr.<span class="property">length</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    fn = arr.<span class="title function_">shift</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fn</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 3. 新建一个标识，为true才改变app.innerHTML的内容</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> flag = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 4. 将flag = false的函数，存在arr数组中，方便下次请求前进行调用</span></span></span><br><span class="line"><span class="language-javascript">  arr.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; flag = <span class="literal">false</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getData</span>(newV)</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span></span><br><span class="line"><span class="language-javascript">  flag &amp;&amp; (app.<span class="property">innerHTML</span> = result)</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 我们这里直接改变响应式对象属性，模拟用户输入</span></span></span><br><span class="line"><span class="language-javascript">state.<span class="property">age</span> = <span class="number">20</span></span></span><br><span class="line"><span class="language-javascript">state.<span class="property">age</span> = <span class="number">30</span></span></span><br><span class="line"><span class="language-javascript">state.<span class="property">age</span> = <span class="number">40</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后，我们在页面上再次打印结果，发现，页面上始终显示的是40，也就是最后<code>state.age = 40</code>对应的结果。那么，我们通过在业务逻辑中，的一些代码改良，成功的解决了请求结果顺序错乱的问题。那么在<code>Vue3</code>，<code>watch</code>中提供了新的参数，可以把一些逻辑放在<code>watch</code>的内部，从而达到和上述代码相同的效果，同样，我们先看用法，进而推导下在<code>watch</code>源码中是如何实现的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timmer = <span class="number">4000</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">resolve</span>(data)</span></span><br><span class="line"><span class="language-javascript">        &#125;, timmer -= <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 第三个参数提供了onCleanup，用户可以传入回调</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">age</span>, <span class="keyword">async</span> (newV, oldV, onCleanup) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> flag = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">onCleanup</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        flag = <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getData</span>(newV)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span></span><br><span class="line"><span class="language-javascript">      flag &amp;&amp; (app.<span class="property">innerHTML</span> = result)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 我们这里直接改变响应式对象属性，模拟用户输入</span></span></span><br><span class="line"><span class="language-javascript">    state.<span class="property">age</span> = <span class="number">20</span></span></span><br><span class="line"><span class="language-javascript">    state.<span class="property">age</span> = <span class="number">30</span></span></span><br><span class="line"><span class="language-javascript">    state.<span class="property">age</span> = <span class="number">40</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是发现，代码精简了很多？我们接下来实现一下吧！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /reactivity/src/apiWatch.ts 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; isReactive &#125; <span class="keyword">from</span> <span class="string">&#x27;./reactive&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isFunction, isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactiveEffect</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value, seen = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (seen.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  seen.<span class="title function_">add</span>(value)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 就是单纯的取了下值，比如state.name，为了触发reactive对象中属性的getter</span></span><br><span class="line">      <span class="title function_">traverse</span>(value[key], seen)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 首先导出watch方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, &#123; immediate &#125; = &#123;&#125; <span class="keyword">as</span> <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 2. 分两种情况判断，source是一个响应式对象和source是一个函数</span></span><br><span class="line">  <span class="comment">// 这个getter就相当于是effect中的回调函数</span></span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">    <span class="comment">// 3. 如果source是一个响应式对象，应该对source递归进行取值</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> oldValue</span><br><span class="line">  <span class="comment">// 8. 创建cleanup变量，和onCleanup方法</span></span><br><span class="line">  <span class="keyword">let</span> cleanup</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onCleanup</span> = fn =&gt; &#123;</span><br><span class="line">    cleanup = fn</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 6. 当触发更新的时候，也就是属性改变的时候，才会执行这个job方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 9. 当cleanup存在，就调用我们onCleanup中传入的回调方法</span></span><br><span class="line">    <span class="keyword">if</span> (cleanup) <span class="title function_">cleanup</span>()</span><br><span class="line">    <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>()</span><br><span class="line">    <span class="comment">// 7. 首先在cb中添加这个onCleanup参数</span></span><br><span class="line">    <span class="title function_">cb</span>(newValue, oldValue, onCleanup)</span><br><span class="line">    oldValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 当new的时候，就会执行getter方法，开始进行依赖收集，数据变化后，会执行cb的回调方法</span></span><br><span class="line">  <span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, job)</span><br><span class="line">  <span class="comment">// 需要立即执行，那么就先执行一次任务</span></span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 将立即执行的effect.run()的结果作为oldValue</span></span><br><span class="line">  oldValue = effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看7、8、9三个步骤，其实就是类似于刚才我们写在外边的逻辑，只不过我们现在把这些逻辑写在了<code>watch</code>内部，多读几遍，非常巧妙。</p>
<p>至此为止，关于<code>watch</code>的核心逻辑，我们就已经写完了，是不是看起来，没有想象中的那么难呢？接下来我们还要实现下<code>watchEffect</code>，莫慌，只需要改动几行代码，便可轻松实现。首先，我们将刚才导出的<code>watch</code>改个名字换为<code>doWatch</code>，变成一个通用函数，因为前文说过，<code>watch</code>和<code>watchEffect</code>都是基于<code>effect</code>方法进行封装的，所以二者的逻辑可以说是非常相似的，所以我们没必要再写一遍，那么只要调用通用函数，根据传参不同，即可快速实现：</p>
<h3 id="watchEffect的实现"><a href="#watchEffect的实现" class="headerlink" title="watchEffect的实现"></a><code>watchEffect</code>的实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /reactivity/src/apiWatch.ts 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; isReactive &#125; <span class="keyword">from</span> <span class="string">&#x27;./reactive&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isFunction, isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactiveEffect</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value, seen = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (seen.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  seen.<span class="title function_">add</span>(value)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 就是单纯的取了下值，比如state.name，为了触发reactive对象中属性的getter</span></span><br><span class="line">      <span class="title function_">traverse</span>(value[key], seen)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 首先导出doWatch方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate &#125; = &#123;&#125; <span class="keyword">as</span> <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 2. 分两种情况判断，source是一个响应式对象和source是一个函数</span></span><br><span class="line">  <span class="comment">// 这个getter就相当于是effect中的回调函数</span></span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">    <span class="comment">// 3. 如果source是一个响应式对象，应该对source递归进行取值</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> oldValue</span><br><span class="line">  <span class="comment">// 8. 创建cleanup变量，和onCleanup方法</span></span><br><span class="line">  <span class="keyword">let</span> cleanup</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onCleanup</span> = fn =&gt; &#123;</span><br><span class="line">    cleanup = fn</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 6. 当触发更新的时候，也就是属性改变的时候，才会执行这个job方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 10. 根据传参不同，判断如果有回调函数的话，那么就是watch，如果没有cb那就是watchEffect</span></span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// 9. 当cleanup存在，就调用我们onCleanup中传入的回调方法</span></span><br><span class="line">      <span class="keyword">if</span> (cleanup) <span class="title function_">cleanup</span>()</span><br><span class="line">      <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>()</span><br><span class="line">      <span class="comment">// 7. 首先在cb中添加这个onCleanup参数</span></span><br><span class="line">      <span class="title function_">cb</span>(newValue, oldValue, onCleanup)</span><br><span class="line">      oldValue = newValue</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      effect.<span class="title function_">run</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 当new的时候，就会执行getter方法，开始进行依赖收集，数据变化后，会执行cb的回调方法</span></span><br><span class="line">  <span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, job)</span><br><span class="line">  <span class="comment">// 需要立即执行，那么就先执行一次任务</span></span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 将立即执行的effect.run()的结果作为oldValue</span></span><br><span class="line">  oldValue = effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出watch和watchEffect方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(source, cb, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params">source, options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(source, <span class="literal">null</span>, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改动点仅仅是第10步骤，加了一个判断，那么这样<code>doWatch</code>就是一个通用函数，只需要根据传参不同，在外边再包一层，就是我们平时中项目常用的<code>watch</code>和<code>watchEffect</code>了！怎样，是不是很容易？那我们继续往下看吧</p>
<h3 id="computed的实现"><a href="#computed的实现" class="headerlink" title="computed的实现"></a><code>computed</code>的实现</h3><p>我们还是简单用一下<code>computed</code>，看看有哪几种用法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 1. 可以传入对象，里边自定义get和set的逻辑</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> info = <span class="title function_">computed</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我触发啦！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> state.<span class="property">name</span> + state.<span class="property">age</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 虽然取了2次值，但是只会打印一次&#x27;我触发了&#x27;，因为computed有缓存的效果，依赖的值不变化，就不会多次触发get，要通过.value来取值</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 2. 传入函数，默认就相当于返回了一个get，取值要通过.value来取</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> info = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> state.<span class="property">name</span> + state.<span class="property">age</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>回顾了下基本用法后，我们还是在<code>reactivity/src</code>目录下，新建<code>computed.ts</code>文件，然后在<code>reactivity/src/index.ts</code>中<code>export * from &#39;.computed&#39;</code>，进行导出。接下来，我们便可以在<code>computed.ts</code>中来实现<code>computed</code>的逻辑了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactivity/src/computed.ts 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; isFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactiveEffect</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span> &#123;</span><br><span class="line">  public effect</span><br><span class="line">  public _value</span><br><span class="line">  public __v_isRef = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">getter, public setter</span>) &#123;</span><br><span class="line">    <span class="comment">// 3. 还是通过new ReactiveEffect方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 给value属性，创建get和set，再取值和赋值的时候，触发相应逻辑</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="title function_">run</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newV</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setter</span>(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOrOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 对传入的参数进行分类处理，对函数和对象进行不同的处理。</span></span><br><span class="line">  <span class="keyword">const</span> isGetter = <span class="title function_">isFunction</span>(getterOrOptions)</span><br><span class="line">  <span class="keyword">let</span> getter, setter</span><br><span class="line">  <span class="keyword">if</span> (isGetter) &#123;</span><br><span class="line">    getter = isGetter</span><br><span class="line">    setter = <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span></span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 创建计算属性，返回一个响应式对象，访问的时候，通过.value的方式来访问</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来按步骤一一讲解下</p>
<ul>
<li>步骤1：没错，非常熟悉的套路，和<code>watch</code>处理参数的方式几乎是一模一样；</li>
<li>步骤2：返回一个响应式对象，获取<code>computed</code>的值，需要通过<code>.value</code>的方法；</li>
<li>步骤3：依旧是通过<code>new ReactiveEffect</code>，传入<code>getter</code>进行依赖收集，生成<code>effect</code>实例对象；</li>
<li>步骤4：因为<code>computed</code>返回的对象，是通过<code>.value</code>来访问的，所以要创建<code>get set</code>，执行相应逻辑；</li>
</ul>
<p>至此，我们的<code>computed</code>就可以简单的用起来了，我们先运行一下，其他的问题，我们后边再来解决，我们改变下<code>index.html</code>的代码，查看打印结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> info = <span class="title function_">computed</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我调用啦！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> state.<span class="property">name</span> + state.<span class="property">age</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  set (val) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val) </span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 对info.value取两次值，查看结果</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时，我们会发现，控制台中打印的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">复制代码我调用啦！</span><br><span class="line">张三18</span><br><span class="line">我调用啦！</span><br><span class="line">张三18</span><br></pre></td></tr></table></figure>

<p>这和我们平时用的<code>computed</code>好像哪里有些不同？没错，<code>info</code>中依赖的响应式对象<code>state</code>中的属性，并没有变化，但是却触发了两次<code>computed</code>，并没有实现缓存的效果，那么我们接下来就来实现一下吧！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactivity/src/computed.ts 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; isFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactiveEffect</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span> &#123;</span><br><span class="line">  public effect</span><br><span class="line">  public _value</span><br><span class="line">  <span class="comment">// 5. 创建一个_dirty变量，为true的时候就代表可以重新执行取值操作</span></span><br><span class="line">  public _dirty = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">getter, public setter</span>) &#123;</span><br><span class="line">    <span class="comment">// 3. 还是通过new ReactiveEffect方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 7. 依赖的值变了，判断_dirty是否为false，为false的话，就把_dirty改为true </span></span><br><span class="line">      this_dirty = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 给value属性，创建get和set，再取值和赋值的时候，触发相应逻辑</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 6. 如果_dirty是true的话，才会重新执行`run`方法，重新取值，否则，直接返回原值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">false</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newV</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setter</span>(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOrOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 对传入的参数进行分类处理，对函数和对象进行不同的处理。</span></span><br><span class="line">  <span class="keyword">const</span> isGetter = <span class="title function_">isFunction</span>(getterOrOptions)</span><br><span class="line">  <span class="keyword">let</span> getter, setter</span><br><span class="line">  <span class="keyword">if</span> (isGetter) &#123;</span><br><span class="line">    getter = isGetter</span><br><span class="line">    setter = <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span></span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 创建计算属性，返回一个响应式对象，访问的时候，通过.value的方式来访问</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看捕捉5~7，是不是通过一个<code>_dirty</code>属性，就实现了如果依赖不发生变化，那么就不会多次触发<code>computed</code>对象中的<code>get</code>了呢？还是那句话，<code>computed</code>的实现，依旧是依赖于<code>effect</code>，所以理解<code>effect</code>才是重中之重。</p>
<p>看起来是没啥问题了，但是在有一种场景下，存在着问题，我们改一下<code>index.html</code>代码，来看一下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> info = <span class="title function_">computed</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我调用啦！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> state.<span class="property">name</span> + state.<span class="property">age</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  set (val) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val) </span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  app.<span class="property">innerHTML</span> = info.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  state.<span class="property">age</span> = <span class="number">22</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>没错，就是当我们在<code>effect</code>方法中，使用了<code>computed</code>计算属性，那么页面就不会更新，因为<code>effect</code>中并没有对计算属性进行依赖收集，而<code>computed</code>计算属性中也没有对应的<code>effect</code>方法。那怎么实现呢？我们想一想，是不是很类似于之前写的依赖收集<code>track</code>和触发更新<code>trigger</code>方法呢？没错，我们只需要在<code>computed</code>中增加进行依赖收集和触发更新的逻辑就好了，而这两个逻辑，我们之前也写过，所以可以把通用的代码直接<code>copy</code>过来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactivity/src/computed.ts 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; isFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactiveEffect</span>, activeEffect, trackEffects, triggerEffects &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span> &#123;</span><br><span class="line">  public effect</span><br><span class="line">  public _value</span><br><span class="line">  public dep = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  <span class="comment">// 5. 创建一个_dirty变量，为true的时候就代表可以重新执行取值操作</span></span><br><span class="line">  public _dirty = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">getter, public setter</span>) &#123;</span><br><span class="line">    <span class="comment">// 3. 还是通过new ReactiveEffect方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 7. 依赖的值变了，判断_dirty是否为false，为false的话，就把_dirty改为true </span></span><br><span class="line">      this_dirty = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 9. 触发更新</span></span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 给value属性，创建get和set，再取值和赋值的时候，触发相应逻辑</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 8. 如果计算属性在effect中使用的话，那也要做依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="title function_">trackEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 如果_dirty是true的话，才会重新执行`run`方法，重新取值，否则，直接返回原值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">false</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newV</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setter</span>(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOrOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 对传入的参数进行分类处理，对函数和对象进行不同的处理。</span></span><br><span class="line">  <span class="keyword">const</span> isGetter = <span class="title function_">isFunction</span>(getterOrOptions)</span><br><span class="line">  <span class="keyword">let</span> getter, setter</span><br><span class="line">  <span class="keyword">if</span> (isGetter) &#123;</span><br><span class="line">    getter = isGetter</span><br><span class="line">    setter = <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span></span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 创建计算属性，返回一个响应式对象，访问的时候，通过.value的方式来访问</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// reactivity/src/effect.ts 文件</span><br><span class="line">export function triggerEffects(dep) &#123;</span><br><span class="line">  const effects = [...dep]</span><br><span class="line">  effects &amp;&amp; effects.forEach(effect =&gt; &#123;</span><br><span class="line">    // 正在执行的effect，不要多次执行，防止死循环</span><br><span class="line">    if (effect !== activeEffect) &#123;</span><br><span class="line">      // 如果用户传入了scheduler，那么就执行用户自定义逻辑，否则还是执行run逻辑</span><br><span class="line">      if(effect.scheduler) &#123;</span><br><span class="line">        effect.scheduler()</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        effect.run()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// computed中收集effect的依赖</span><br><span class="line">export function trackEffects(dep) &#123;</span><br><span class="line">  let shouldTrack = !dep.has(activeEffect)</span><br><span class="line">  if(shouldTrack) &#123;</span><br><span class="line">    // 依赖和effect多对多关系保存</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看步骤8，9，依赖收集和触发更新的方法，我们依旧写在<code>effect.ts</code>文件中（可以对比下<code>trigger</code>和<code>track</code>方法，逻辑几乎一模一样）。我们再运行刚才<code>index.html</code>中的代码，发现页面成功的更新了，那么至此，<code>computed</code>的核心逻辑我们就写完啦！</p>
<h3 id="ref的实现"><a href="#ref的实现" class="headerlink" title="ref的实现"></a><code>ref</code>的实现</h3><p>我们在<code>reactivity/src</code>目录下创建<code>ref.ts</code>文件</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; activeEffect, trackEffects, triggerEffects &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;./reactive&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toReactive</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> _value</span><br><span class="line">  <span class="keyword">public</span> dep = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  <span class="keyword">public</span> __v_isRef = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> rawValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断传入的值，如果是对象类型，那么就将其包装成响应式对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(rawValue)</span><br><span class="line">  &#125;</span><br><span class="line">  get value () &#123;</span><br><span class="line">    <span class="keyword">if</span>(activeEffect) &#123;</span><br><span class="line">      <span class="comment">// 2. 进行依赖收集</span></span><br><span class="line">      <span class="title function_">trackEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  set value (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newVal !== <span class="variable language_">this</span>.<span class="property">rawValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rawValue</span> = newVal</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="comment">// 3. 进行触发更新</span></span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了前边的基础，写起<code>ref</code>来，就显得非常得心应手，核心其实就这几行代码，通过注释，我们就不难发现，如果传入的是对象，那么就是利用了之前写的<code>reactive</code>进行包装处理，如果传入了其他类型的数据，那么就和<code>computed</code>中的方法一模一样，需要进行依赖收集和触发更新。</p>
<h3 id="实现toRef和toRefs"><a href="#实现toRef和toRefs" class="headerlink" title="实现toRef和toRefs"></a>实现<code>toRef</code>和<code>toRefs</code></h3><p>这两个方法，其实我们开发中，用的会比较少，所以还是先简单介绍下用法，然后再思考下如何实现，最后再来写一下它们的原理：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125;))</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 单独把name取出来</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> name = state.<span class="property">name</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  app.<span class="property">innerHTML</span> = name</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  state.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是上边的代码可以看到，当我们将<code>let name = state.name</code>单独取出来之后，再修改<code>state.name</code>的值之后，<code>name</code>的值就不会再发生变化了，页面上的名字也不会随之发生变化，也就是所谓的丢失响应式，那么利用<code>toRef</code>就可以解决这种问题：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125;))</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 单独把name取出来</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> name = <span class="title function_">toRef</span>(state, <span class="string">&#x27;name&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  app.<span class="property">innerHTML</span> = name.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  state.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们来思考一下如何实现呢？为了不丢失响应式，所以就需要联系，那么肯定就是在<code>name</code>和<code>state.name</code>之间存在某种联系，当改变<code>state.name</code>值的时候，从而能使得<code>name</code>同步进行变动。既然这样，那不就可以做一层代理，当访问和修改<code>name</code>的时候，实际是去访问和修改<code>state.name</code>的值么？思路有了，我们便可以通过代码来实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactivity/src/ref.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; activeEffect, trackEffects, triggerEffects &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;./reactive&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toReactive</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> _value</span><br><span class="line">  <span class="keyword">public</span> dep = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  <span class="keyword">public</span> __v_isRef = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> rawValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断传入的值，如果是对象类型，那么就将其包装成响应式对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(rawValue)</span><br><span class="line">  &#125;</span><br><span class="line">  get value () &#123;</span><br><span class="line">    <span class="keyword">if</span>(activeEffect) &#123;</span><br><span class="line">      <span class="comment">// 2. 进行依赖收集</span></span><br><span class="line">      <span class="title function_">trackEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  set value (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newVal !== <span class="variable language_">this</span>.<span class="property">rawValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rawValue</span> = newVal</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="comment">// 3. 进行触发更新</span></span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectRefImpl</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> __v_isRef = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> _object, <span class="keyword">public</span> _key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>] = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出toRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">toRef</span>(<span class="params"><span class="built_in">object</span>, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectRefImpl</span>(<span class="built_in">object</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出toRefs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">toRefs</span>(<span class="params"><span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果传入数组，就创建一个空数组，如果是对象，那就创建一个新对象</span></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title function_">isArray</span>(<span class="built_in">object</span>) ? <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="built_in">object</span>.<span class="property">length</span>) : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">object</span>) &#123;</span><br><span class="line">    ret[key] = <span class="title function_">toRef</span>(<span class="built_in">object</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码非常简单，就是进行了一次代理转化，而我们项目中常用的是<code>toRefs</code>，也是遍历每个属性，并借助<code>toRef</code>来实现的。</p>
<h3 id="proxyRef的实现"><a href="#proxyRef的实现" class="headerlink" title="proxyRef的实现"></a><code>proxyRef</code>的实现</h3><p>这个方法可能听起来很陌生，但是只要写过<code>Vue3</code>的项目，就一定会用到这个方法，举个例子就明白了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;张三&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们在代码中，用<code>ref</code>声明了一个字符串类型的数据后，如果在代码中使用这个值，是不是需要通过<code>name.value</code>的方式来调用呢？但是当我们在模板中使用的时候，却可以直接来用这个<code>name</code>而并不需要再<code>.value</code>来取值，诶，这就是<code>Vue3</code>在模板编译的时候，内部调用了这个方法，帮助我们对<code>ref</code>声明变量，进行自动脱钩，那么细心的朋友也发现了，不管是在<code>computed</code>，还是<code>ref</code>代码中，都有一样<code>public __v_isRef = true</code>这个标识，没错，接下来就要用到这个标识了，这个标识就是为了在自动脱钩的时候，来进行分辨的。那么我们来实现这个<code>proxyRef</code>方法吧~</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactivity/src/ref.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; activeEffect, trackEffects, triggerEffects &#125; <span class="keyword">from</span> <span class="string">&#x27;./effect&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;./reactive&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toReactive</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> _value</span><br><span class="line">  <span class="keyword">public</span> dep = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  <span class="keyword">public</span> __v_isRef = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> rawValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断传入的值，如果是对象类型，那么就将其包装成响应式对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(rawValue)</span><br><span class="line">  &#125;</span><br><span class="line">  get value () &#123;</span><br><span class="line">    <span class="keyword">if</span>(activeEffect) &#123;</span><br><span class="line">      <span class="comment">// 2. 进行依赖收集</span></span><br><span class="line">      <span class="title function_">trackEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  set value (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newVal !== <span class="variable language_">this</span>.<span class="property">rawValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rawValue</span> = newVal</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="comment">// 3. 进行触发更新</span></span><br><span class="line">      <span class="title function_">triggerEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出ref</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectRefImpl</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> __v_isRef = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> _object, <span class="keyword">public</span> _key</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>] = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出toRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">toRef</span>(<span class="params"><span class="built_in">object</span>, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectRefImpl</span>(<span class="built_in">object</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出toRefs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">toRefs</span>(<span class="params"><span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果传入数组，就创建一个空数组，如果是对象，那就创建一个新对象</span></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title function_">isArray</span>(<span class="built_in">object</span>) ? <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="built_in">object</span>.<span class="property">length</span>) : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">object</span>) &#123;</span><br><span class="line">    ret[key] = <span class="title function_">toRef</span>(<span class="built_in">object</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isRef</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !!(value &amp;&amp; value.<span class="property">__v_isRef</span> === <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是ref则取ref.value</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">proxyRefs</span>(<span class="params">objectWithRefs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(objectWithRefs, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> v = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(v) ? v.<span class="property">value</span> : v</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">      <span class="comment">// 老的值如果是个ref，那么实际上赋值的时候应该给他的.value进行赋值</span></span><br><span class="line">      <span class="keyword">if</span>(oldValue.<span class="property">__v_isRef</span>) &#123;</span><br><span class="line">        oldValue.<span class="property">value</span> = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况，正常赋值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>proxyRef</code>方法，在后续文章中，会用到，这里只是提前介绍下这个方法。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>那么至此，我们<code>reactivity</code>响应式模块中的一些个核心的方法，基本上已经实现了最核心的逻辑，这样，我们再去阅读源码的时候，就不会变得一头雾水了，好好再熟悉一遍<code>reactivity</code>模块的方法吧，然后再去看下<code>Vue3</code>源码中的<code>reactivity</code>逻辑；我们接下来会继续分析<code>Vue3</code>，其他模块的核心代码。</p>
<p>作者：柠檬soda水<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7203268889462145061">https://juejin.cn/post/7203268889462145061</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

        </div>
        <br />

        <!-- 分享 -->
        <div id="social-share" class="article-social-share"></div>

        <!-- 评论系统 -->
        
            <section id="comments" class="comments">
              <!-- 可以添加样式
              <style>
                .comments{margin:30px;padding:10px;background:#fff}
                @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
              </style> -->
              <!-- 评论系统。在post.ejs中引入 -->
<div class="valine_comment"></div>
<script type="module">
  import { init } from '/js/waline.mjs';
  // import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js'; // 在线url
  init({
    el: '.valine_comment',
    serverURL: 'https://blog.comment.helloallen.cn',
    // serverURL: 'https://allen-blog-vercel.vercel.app', // 未绑定域名的评论url，只能外网访问
  });
</script>
            </section>
        

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Vue/"># Vue</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <!-- 另一种的上一篇下一篇 -->
        <!-- <section class="post-nav">
            
                <a class="prev" rel="prev" href="/72108fd/">从零开始学习Vue3源码（二、Vue3响应式原理（上））</a>
            
            
            <a class="next" rel="next" href="/6a425b5b/">从零开始学习Vue3源码（四、Vue3渲染原理）</a>
            
        </section> -->
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/72108fd/"> &laquo; Prev </a>
            
            
                <a class="next" rel="next" href="/6a425b5b/"> Next &raquo; </a>
            
        </section>


    </article>
</div>

            </div>
            <!-- 分享 -->
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" defer></script>
<link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">

<footer id="footer" class="footer">
    <div>
        <span>
            Allen © 
                2015 - 
                2024  
        </span> |   <!-- 站点访问量统计。在footer.ejs中引入 -->
<script async src="/js/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    <i class="iconfont icon-peoplecopy3"></i>
    <span id="busuanzi_value_site_uv"></span>
</span>&nbsp;


<span class="site-pv">
    <i class="iconfont icon-view"></i>
    <span id="busuanzi_value_site_pv"></span>
</span>

 
    </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & Theme by <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        </span>
    </div>

    <!-- 上个版本的统计当前站点运行时间 -->
    <!-- <div class="copyright">
        <span>© Allen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
        | <span id="timeDate">loading...</span>
        <span id="times" style="text-align: center;font-size: 12px;">载入时分秒...</span>
    </div> -->
</footer>

<!-- <script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("11/06/2020 00:00:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "This site has been running for "+dnum+" days "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    }
    setInterval("createtime()",250);
</script> -->

    </div>

    <!--Start of Tawk.to Script-->
    <script type="text/javascript">
        var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
        (function(){
            var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
            s1.async=true;
            s1.src='https://embed.tawk.to/66b239041601a2195ba16829/1i4k2tesf';
            s1.charset='UTF-8';
            s1.setAttribute('crossorigin','*');
            s0.parentNode.insertBefore(s1,s0);
        })();
    </script>
    <!--End of Tawk.to Script-->
</body>

</html>