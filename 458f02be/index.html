<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="Allen">


    <meta name="subtitle" content="绿衣捧砚催题卷，红袖添香伴读书">




<title>Vite 详解 | 阿伦的个人博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



<!-- 百度统计，在head.ejs中引入 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4089b5476d9d7b1fbf81de2841dc180c";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    


<!-- 搜索 -->
<div id="algolia-search">
  <div class="search-dialog">  
    <nav class="search-nav">
      <span class="search-dialog-title">Search</span>
      <button class="search-close-button">
        <span class="iconfont icon-guanbi"></span>
      </button>
    </nav>
  
    <div class="search-wrap">
      <div id="algolia-search-input"></div>
      <hr />  
      <div id="algolia-search-results">
        <div id="algolia-hits"></div>
        <div id="algolia-pagination"></div>
        <div id="algolia-info">
          <div class="algolia-stats"></div>
          <div class="algolia-poweredBy"></div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="search-mask"></div>
  
  <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.66.1/dist/instantsearch.production.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/algoliasearch/4.23.2/algoliasearch-lite.umd.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/js/algolia.js"></script>
</div>



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="阿伦的个人博客" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
            } else {
                pagebody.classList.remove('dark-theme');
            }
            // mobile
            if (document.getElementById("mobile-toggle-theme")) {
                document.getElementById("mobile-toggle-theme").innerText = isDark ? "· Dark" : "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Allen&#39;s Blog</a></div>
            <div class="menu navbar-right">
                <!-- 其他的导航 -->
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                

                <!-- Search -->
                <span id="search-button" style="padding: 0 8px;cursor: pointer;">
                    <span class="search">Search</span>
                </span>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Allen&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Vite 详解</h1>
            
                <div class="post-meta">
                    
                    <!-- 
                        Author: <a itemprop="author" rel="author" href="/">Allen</a>
                     -->

                    
                        <span class="post-time">
                        
                        <!-- Date: <a href="#">二月 8, 2023&nbsp;&nbsp;14:08:29</a> -->
                        <span class="iconfont icon-date1"></span>
                        二月 8, 2023
                        </span>
                    
                    &nbsp;  &nbsp;
                    
                        <span class="post-category">
                            <span class="iconfont icon-icon-goodscategory"></span>
                            
                                <a href="/categories/Web%E5%89%8D%E7%AB%AF/">Web前端</a>
                            
                        </span>
                    
                    <!-- 展示当前文章所属tags -->
                    
                    &nbsp;  &nbsp;
                    <span class="iconfont icon-tags"></span>
                        <span>
                            
                                <a href="/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/">项目构建 </a>&nbsp;
                            
                        </span>
                    
                    
                    
                        <!-- 文章字数和阅读时间 -->
<div style="display: inline;">
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-post"></span>
      <!-- <span class="post-meta-item-text">  Count: </span> -->
      <span class="post-count">6.2k Words</span>
    </span>
  </span>
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-time"></span>
      <!-- <span class="post-meta-item-text">  Time: </span> -->
      <span class="post-count">24 min</span>
    </span>
  </span>
</div>

                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-vite出现之前"><a href="#1-vite出现之前" class="headerlink" title="1. vite出现之前"></a>1. vite出现之前</h2><p>在Vite没有诞生之前，我们前端大多都是基于 webpack 构建的，主要离不开以下两点：</p>
<ul>
<li>本地开发（热更新HMR）</li>
<li>打包上线</li>
</ul>
<p>webpack的核心简单概括就是将各类资源打包整合在一起，形成bundle的能力。但是随着项目的不断迭代，慢慢演变成一个中大型项目，这时候你会发现打包时间太久了，换句话说构建效率变低了。</p>
<p>而在Bundle工具的演变过程中，我们见证了 webpack、Rollup 和 Parcel 等工具，同时构建效率也在逐步提升。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081410279.png"></p>
<h2 id="2-伴随着浏览器对ES模块-ESM-逐步支持兼容，是不是有更快的方式可以解决构建问题？"><a href="#2-伴随着浏览器对ES模块-ESM-逐步支持兼容，是不是有更快的方式可以解决构建问题？" class="headerlink" title="2. 伴随着浏览器对ES模块(ESM)逐步支持兼容，是不是有更快的方式可以解决构建问题？"></a>2. 伴随着浏览器对ES模块(ESM)逐步支持兼容，是不是有更快的方式可以解决构建问题？</h2><p>那就是基于浏览器支持的 ESM import特性实现的 bundless, 通过利用浏览器进行模块间依赖加载，而不需要在编译时进行。</p>
<p>换句话说我们不再需要构建一个完整的 Bundle（下文我们称为：Bundless）。当我们修改文件时，浏览器只需要重新加载单个文件即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081414605.png"></p>
<h2 id="3-那有哪些-Bundless-解决方案-？"><a href="#3-那有哪些-Bundless-解决方案-？" class="headerlink" title="3. 那有哪些 Bundless 解决方案 ？"></a>3. 那有哪些 Bundless 解决方案 ？</h2><p>Vite就是其一，回顾下Vite的优势：</p>
<p>（1）在开发模式下：基于esbuild 预构建依赖（减少HTTP请求） + 浏览器自主加载对应的模块，热更新页面！</p>
<p>（2）在生产模式下：基于Rollup的打包，速度也有一定提升</p>
<h2 id="4-饭后思考："><a href="#4-饭后思考：" class="headerlink" title="4. 饭后思考："></a>4. 饭后思考：</h2><p>（1）esbuild不是比Rollup更快吗？生产模式下，为何不用esbuild构建？<a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/why.html%23why-not-bundle-with-esbuild">👉 参考答案</a></p>
<p>（2）如果是对于原生ESM不支持的浏览器，开发模式咋处理？ <a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/%23browser-support">👉 参考答案</a></p>
<p>（3）不是说好bundless？为何还要用esbuild 预构建依赖呢？ <a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/dep-pre-bundling.html">👉 参考答案</a></p>
<p>（3.1） 为了处理CommonJs或UMD的兼容性：在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。</p>
<p>（3.2） 为了提高后续页面的加载性能，Vite将那些具有许多内部模块的 ESM 依赖项转换为单个模块。</p>
<p>有些包将它们的 ES 模块构建为许多单独的文件，彼此导入。例如，lodash-es<a target="_blank" rel="noopener" href="https://unpkg.com/browse/lodash-es/"> </a>有超过 600 个内置模块！当我们执行 import { debounce } from ‘lodash-es’ 时，浏览器同时发出 600 多个 HTTP 请求！即使服务器能够轻松处理它们，但大量请求会导致浏览器端的网络拥塞，使页面加载变得明显缓慢。</p>
<p>通过将 lodash-es 预构建成单个模块，现在我们只需要一个HTTP请求！</p>
<p>（4）Bundless方案除了Vite之外，还有哪些？ <a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/comparisons.html">👉 参考答案</a></p>
<p>（5）Vite 的目标是要干掉 Webpack？ <a href="https://link.juejin.cn/?target=https://www.zhihu.com/question/477139054/answer/2156019180">👉 参考答案</a></p>
<h1 id="二、Vite简介"><a href="#二、Vite简介" class="headerlink" title="二、Vite简介"></a>二、Vite简介</h1><h2 id="1-什么是Vite"><a href="#1-什么是Vite" class="headerlink" title="1. 什么是Vite"></a>1. 什么是Vite</h2><blockquote>
<p>Vite是一种新型的前端构建工具，它能显著改善前端开发体验。</p>
</blockquote>
<p>Vite由两个主要部分组成：</p>
<p>（1）dev server：利用浏览器的ESM能力来提供源文件，具有丰富的内置功能并具有高效的HMR</p>
<p>（2）生产构建：生产环境利用Rollup来构建代码，提供指令用来优化构建过程</p>
<p>Vite作为一个基于浏览器原生ESM的构建工具，它省略了开发环境的打包过程，利用浏览器去解析imports，在服务端按需编译返回。同时，在开发环境拥有速度快到惊人的模块热更新，且热更新的速度不会随着模块增多而变慢。因此，使用Vite进行开发，至少会比Webpack快10倍左右。</p>
<h2 id="2-Vite的主要特性"><a href="#2-Vite的主要特性" class="headerlink" title="2. Vite的主要特性"></a>2. Vite的主要特性</h2><ul>
<li>Instant Server Start —— 即时服务启动</li>
<li>Lightning Fast HMR —— 闪电般快速的热更新</li>
<li>Rich Features —— 丰富的功能</li>
<li>Optimized Build —— 经过优化的构建</li>
<li>Universal Plugin Interface —— 通用的Plugin接口</li>
<li>Fully Typed APIs —— 类型齐全的API</li>
</ul>
<h2 id="3-主流构建工具对比"><a href="#3-主流构建工具对比" class="headerlink" title="3. 主流构建工具对比"></a>3. 主流构建工具对比</h2><p>构建工具指能自动对代码执行检验、转换、压缩等功能的工具。常见功能包括：代码转换、代码打包、代码压缩、HMR、代码检验。构建工具也随着前端技术的发展，从Browserify、Gulp到Parcel，从Webpack到Rollup，一直到最近比较火的面向非打包的Snowpack和Vite。</p>
<p>（1）Browserify</p>
<ul>
<li>预编译模块化方案（文件打包工具）</li>
<li>Browserify基于流方式干净灵活</li>
<li>遵循commonJS规范打包JS</li>
<li>可引入插件打包CSS等其他资源（非原生能力）</li>
</ul>
<p>（2）Gulp</p>
<ul>
<li>基于流的自动化构建工具（工程化）</li>
<li>配置复杂度高，偏向编程式，需要定义task处理构建</li>
<li>支持监听读写文件</li>
<li>可搭配Browserify等模块化工具来使用</li>
</ul>
<p>（3）Parcel</p>
<ul>
<li>极速打包（工程化：极速0配置）</li>
<li>零配置，但造成了配置不灵活，内置常见场景的构建方案及其依赖，无需再次安装（babel等）</li>
<li>以html入口，自动检测和打包依赖</li>
<li>不支持SourceMap</li>
<li>无法Tree-shaking</li>
</ul>
<p>（4）Webpack</p>
<ul>
<li>预编译模块化方案（工程化：大而全）</li>
<li>通过配置文件达到一站式配置</li>
<li>loader进行资源转换，功能全面（css+js+icon+front）</li>
<li>插件丰富，灵活扩展</li>
<li>社群庞大</li>
<li>大型项目构建慢</li>
</ul>
<p>（5）Rollup</p>
<ul>
<li>基于ES6打包（模块打包工具）</li>
<li>Tree-shaking</li>
<li>打包文件小且干净，执行效率更高</li>
<li>更专注于JS打包</li>
</ul>
<p>（6）Snowpack</p>
<ul>
<li>基于ESM运行时编译（工程化：ESM运行时）</li>
<li>无需递归循环依赖组装依赖树</li>
<li>默认输出单独的构建模块（未打包），可选择不同打包器（webpack、rollup等）</li>
</ul>
<p>（7）Vite</p>
<ul>
<li>基于ESM运行时打包</li>
<li>借鉴了Snowpack</li>
<li>生产环境使用Rollup，集成度更高，相比Snowpack支持多页面、库模式、动态导入自动polyfill等</li>
</ul>
<h2 id="4-为什么要使用Vite"><a href="#4-为什么要使用Vite" class="headerlink" title="4. 为什么要使用Vite"></a>4. 为什么要使用Vite</h2><p>（1）开发环境⚡️速度的提升</p>
<p>经过上节，我们简单对比了各打包工具之间的差异。可以看到使用JS开发的工具通常需要很长的时间才能启动开发服务器，且这个启动时间与代码量、代码复杂度正相关。即使使用HMR，文件修改后的效果也要几秒钟才能在浏览器中反应出来，代表如Webpack。那么Vite是如何解决如Webpack这样的构建工具一样，在复杂、多模块项目开发中启动慢、HMR慢的问题呢？</p>
<p>我们详细对比了开发环境中的Vite和Webpack，发现主要有如下不同：</p>
<table>
<thead>
<tr>
<th>Webpack</th>
<th>Vite</th>
</tr>
</thead>
<tbody><tr>
<td>先打包生成bundle，再启动开发服务器</td>
<td>先启动开发服务器，利用新一代浏览器的ESM能力，无需打包，直接请求所需模块并实时编译</td>
</tr>
<tr>
<td>HMR时需要把改动模块及相关依赖全部编译</td>
<td>HMR时只需让浏览器重新请求该模块，同时利用浏览器的缓存（源码模块协商缓存，依赖模块强缓存）来优化请求</td>
</tr>
<tr>
<td>内存高效利用</td>
<td>-</td>
</tr>
</tbody></table>
<p>因此，针对开发环境中的启动慢问题，Vite开发环境冷启动无需打包，无需分析模块之间的依赖，同时也无需在启动开发服务器前进行编译，启动时还会使用esbuild来进行预构建。而Webpack 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码，这可满满都是 CPU、IO 操作啊，在 Node 运行时下性能必然是有问题。</p>
<p>针对HMR慢，即使只有很小的改动，Webpack依然需要构建完整的模块依赖图，并根据依赖图来进行转换。而Vite利用了ESM和浏览器缓存技术，更新速度与项目复杂度无关。可以看到，如Snowpack、Vite这类面相非打包的构建工具，在开发环境启动时只需要启动两个Server，一个用于页面加载，一个用于HMR的Websocket。当浏览器发出原生的ESM请求，Server收到请求只需要编译当前文件后返回给浏览器，不需要管理依赖。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081414292.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081416211.png"></p>
<p>（2）使用简单，开箱即用</p>
<p>相比Webpack需要对entry、loader、plugin等进行诸多配置，Vite的使用可谓是相当简单了。只需执行初始化命令，就可以得到一个预设好的开发环境，开箱即获得一堆功能，包括：CSS预处理、html预处理、异步加载、分包、压缩、HMR等。他使用复杂度介于Parcel和Webpack的中间，只是暴露了极少数的配置项和plugin接口，既不会像Parcel一样配置不灵活，又不会像Webpack一样需要了解庞大的loader、plugin生态，灵活适中、复杂度适中。适合前端新手。</p>
<h2 id="5-Vite-开发环境-VS-生产环境"><a href="#5-Vite-开发环境-VS-生产环境" class="headerlink" title="5. Vite 开发环境 VS 生产环境"></a>5. Vite 开发环境 VS 生产环境</h2><p>在上节主流工具对比时我们可以看到Vite的开发环境和生产环境具有较大的差异性。</p>
<p>开发环境不需要对所有资源打包，只是使用esbuild对依赖进行预构建，将CommonJS和UMD发布的依赖转换为浏览器支持的ESM，同时提高了后续页面的加载性能（lodash的请求）。Vite会将于构建的依赖缓存到node_modules/.vite目录下，它会根据几个源来决定是否需要重新运行预构建，包括 packages.json中的dependencies列表、包管理器的lockfile、可能在vite.config.js相关字段中配置过的。只要三者之一发生改变，才会重新预构建。</p>
<p>同时，开发环境使用了浏览器缓存技术，解析后的依赖请求以http头的max-age=31536000,immutable强缓存，以提高页面性能。</p>
<p>在生产环境，由于嵌套导入会导致发送大量的网络请求，即使使用HTTP2.x（多路复用、首部压缩），在生产环境中发布未打包的ESM仍然性能低下。因此，对比在开发环境Vite使用esbuild来构建依赖，生产环境Vite则使用了更加成熟的Rollup来完成整个打包过程。因为esbuild虽然快，但针对应用级别的代码分割、CSS处理仍然不够稳定，同时也未能兼容一些未提供ESM的SDK。</p>
<p>为了在生产环境中获得最佳的加载性能，仍然需要对代码进行tree-shaking、懒加载以及chunk分割（以获得更好的缓存）。</p>
<h1 id="三、Vite原理"><a href="#三、Vite原理" class="headerlink" title="三、Vite原理"></a>三、Vite原理</h1><h2 id="1-ESM-amp-esbuild"><a href="#1-ESM-amp-esbuild" class="headerlink" title="1. ESM &amp; esbuild"></a>1. ESM &amp; esbuild</h2><p>（1）ESM</p>
<p>在ES6没有出现之前，随着js代码日益膨胀，往往会对资源模块化来提效，这也就出现了多个模块化方案。如CommonJS常用于服务端，AMD、CMD规范常用在客户端。ES6出现后，紧接着出现了ESM。ESM是浏览器支持的一种模块化方案，允许在浏览器实现模块化。</p>
<ul>
<li>CommonJS：模块同步，如Browserify会对代码进行解析，整理出代码中的所有模块依赖关系，然后把nodejs的模块编译成浏览器可用的模块，相关的模块代码都打包在一起，形成一个完整的JS文件，这个文件中不会存在 require 这类的模块化语法，变成可以在浏览器中运行的普通JS，运行时加载</li>
<li>AMD：模块异步，依赖前置，是requireJS在推广过程中对模块定义的规范化产出，加载完依赖后立即执行依赖模块，依赖加载成功后执行回调</li>
<li>CMD：模块异步，延迟执行，是seaJS在推广过程中对模块定义的规范化产出，就近依赖，先加载所有依赖模块，运行时才执行require内容，按顺序执行</li>
</ul>
<p>与CommonJS、AMD不同，ESM的对外接口只是一种静态定义，为编译时加载，遇到模块加载命令import，就会生成一个只读引用。等脚本真正执行时，再根据这个只读引用，到被加载的那个模块内取值。由于ESM编译时就能确定模块的依赖关系，因此能够只包含要运行的代码，可以显著减少文件体积，降低浏览器压力。</p>
<p>由于ESM是一个比较新的模块化方案，目前其浏览器能力支持如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081416453.png"></p>
<p>可以看到，除了IE、Opera等，新一代浏览器中绝大部分都已支持。</p>
<p>接下来以Vite创建的模板为例，看一下ESM的解析过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class="line">  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &quot;./components/HelloWorld.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当浏览器解析 import HelloWorld from ‘./components/HelloWorld.vue’ 时，会向当前域名发送一个请求获取对应的资源（ESM支持解析相对路径）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081417840.png"></p>
<p>浏览器下载对应的文件，然后解析成模块记录。接下来会进行实例化，为模块分配内存，然后按照导入、导出语句建立模块和内存的映射关系。最后，运行上述代码，把内存空间填充为真实的值。</p>
<p>（2）esbuild</p>
<p>Vite 对 js/ts 的处理没有使用如 glup, rollup 等传统打包工具，而是使用了 esbuild。esbuild 是一个全新的js打包工具，底层使用了go，大量使用了并行操作，可以充分利用CPU资源。esbuild支持如babel, 压缩等的功能。</p>
<p>对比各打包工具性能，可以看到esbuild比rollup等工具快十几倍。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081417838.png"></p>
<h2 id="2-编译构建原理"><a href="#2-编译构建原理" class="headerlink" title="2. 编译构建原理"></a>2. 编译构建原理</h2><p>Vite 的基本实现原理，就是启动一个 koa 服务器拦截由浏览器请求 ESM的请求。通过请求的路径找到目录下对应的文件做一定的处理最终以 ESM的格式返回给客户端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081417273.png"></p>
<p>Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。依赖 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。</p>
<p>（1）依赖解析</p>
<p>以 Vite 官方 demo 为例，当我们请求 localhost:3000 时，Vite 默认返回 localhost:3000/index.html 的代码。而后发送请求 src/main.js。</p>
<p>main.js 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import &#x27;./index.css&#x27;</span><br><span class="line"></span><br><span class="line">createApp(App).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081418965.png"></p>
<p>可以观察到浏览器请求 vue.js 时， 请求路径是 @modules/vue.js。在 Vite 中约定若 path 的请求路径满足 /^/@modules// 格式时，被认为是一个 node_modules 模块。</p>
<p>平时开发中，webpack &amp; rollup(rollup有对应插件) 等打包工具会帮我们找到模块的路径，但浏览器只能通过相对路径去寻找，而如果是直接使用模块名比如：import vue from ‘vue’，浏览器就会报错，这个时候就需要一个三方包进行处理。Vite 对ESM形式的 js 文件模块使用了 ES Module Lexer 处理。Lexer 会找到代码中以 import 语法导入的模块并以数组形式返回。Vite 通过该数组的值获取判断是否为一个 node_modules 模块。若是则进行对应改写成 @modules/:id 的写法。</p>
<p>重写完路径后，浏览器会发送 path 为 /@modules/:id 的对应请求，接下来会被 Vite 客户端做一层拦截来解析模块的真实位置。</p>
<p>首先正则匹配请求路径，如果是/@modules开头就进行后续处理，否则就跳过。若是，会设置响应类型为js，读取真实模块路径内容，返回给客户端。</p>
<p>客户端注入本质上是创建一个script标签（type=’module’），然后将其插入到head中，这样客户端在解析html是就可以执行代码了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export const moduleRE = /^\/@modules\//// plugin for resolving /@modules/:id requests.</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  if (!moduleRE.test(ctx.path)) &#123;</span><br><span class="line">    return next()</span><br><span class="line">  &#125;</span><br><span class="line">  // path maybe contain encode chars</span><br><span class="line">  const id = decodeURIComponent(ctx.path.replace(moduleRE, &#x27;&#x27;))</span><br><span class="line">  ctx.type = &#x27;js&#x27;</span><br><span class="line">  const serve = async (id: string, file: string, type: string) =&gt; &#123;</span><br><span class="line">    // 在代码中做一个缓存，下次访问相同路径直接从 map 中获取 304 返回</span><br><span class="line">    moduleIdToFileMap.set(id, file)</span><br><span class="line">    moduleFileToIdMap.set(file, ctx.path)</span><br><span class="line">    debug(`($&#123;type&#125;) $&#123;id&#125; -&gt; $&#123;getDebugPath(root, file)&#125;`)</span><br><span class="line">    await ctx.read(file)</span><br><span class="line">    return next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 兼容 alias 情况</span><br><span class="line">const importerFilePath = importer ? resolver.requestToFile(importer) : root</span><br><span class="line">const nodeModulePath = resolveNodeModuleFile(importerFilePath, id)</span><br><span class="line">// 如果是个 node_modules 的模块，读取文件。</span><br><span class="line">if (nodeModulePath) &#123;</span><br><span class="line">  return serve(id, nodeModulePath, &#x27;node_modules&#x27;)</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>（2）依赖预构建</p>
<p>依赖预构建主要有两个目的：</p>
<ul>
<li>CommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</li>
<li>性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li>
</ul>
<p>Vite使用esbuild在初次启动开发服务器前把检测到的依赖进行预构建。Vite 基于ESM，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。</p>
<p>以 lodash-es 为例，代码中以 import { debounce } from ‘lodash’ 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081419865.png"></p>
<p>可以看到一共发送了651个请求。一共花费1.53s。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081419391.png"></p>
<p>Vite 为了优化这个情况，利用esbuild在启动的时候预先把debounce用到的所有内部模块全部打包成一个bundle，这样就浏览器在请求debounce时，便只需要发送一次请求了</p>
<p>可以看到预构建后，只发送了14个请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081419292.webp"></p>
<p>（3）静态资源加载</p>
<p>当请求的路径符合 imageRE, mediaRE, fontsRE 或 JSON 格式，会被认为是一个静态资源。静态资源将处理成ESM模块返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// src/node/utils/pathUtils.ts</span><br><span class="line">const imageRE = /\.(png|jpe?g|gif|svg|ico|webp)(\?.*)?$/const mediaRE = /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/const fontsRE = /\.(woff2?|eot|ttf|otf)(\?.*)?$/iexport const isStaticAsset = (file: string) =&gt; &#123;</span><br><span class="line">return imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file)&#125;</span><br><span class="line"></span><br><span class="line">// src/node/server/serverPluginAssets.ts</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">    if (isStaticAsset(ctx.path) &amp;&amp; isImportRequest(ctx)) &#123;</span><br><span class="line">        ctx.type = &#x27;js&#x27;</span><br><span class="line">        ctx.body = export default $&#123;JSON.stringify(ctx.path)&#125; // 输出是path</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    return next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const jsonPlugin: ServerPlugin = (&#123; app &#125;) =&gt; &#123;</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">    await next()</span><br><span class="line">    // handle .json imports</span><br><span class="line">    // note ctx.body could be null if upstream set status to 304</span><br><span class="line">    if (ctx.path.endsWith(&#x27;.json&#x27;) &amp;&amp; isImportRequest(ctx) &amp;&amp; ctx.body) &#123;</span><br><span class="line">        ctx.type = &#x27;js&#x27;</span><br><span class="line">        ctx.body = dataToEsm(JSON.parse((await readBody(ctx.body))!), &#123;</span><br><span class="line">            namedExports: true,</span><br><span class="line">            preferConst: true</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&#125;</span><br></pre></td></tr></table></figure>

<p>（4）vue文件缓存</p>
<p>当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081420453.png"></p>
<p>如上图中请求 App.vue 获取script 代码 , App.vue?type=template 获取 template, App.vue?type=style。这些代码都被插入在 App.vue 返回的代码中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/202402081420685.png"></p>
<p>（5） js/ts处理</p>
<p>Vite使用esbuild将ts转译到js，约是tsc速度的20～30倍，同时HMR更新反应到浏览器的时间会小于50ms。但是，由于esbuild转换ts到js对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用tsc –noEmit。</p>
<p>将ts转换成js后，浏览器便可以利用ESM直接拿到js资源。</p>
<h2 id="3-热更新原理"><a href="#3-热更新原理" class="headerlink" title="3. 热更新原理"></a>3. 热更新原理</h2><p>Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。</p>
<ul>
<li><p>服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。</p>
</li>
<li><p>客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const clientPublicPath = `/vite/client`</span><br><span class="line">const devInjectionCode = `\n&lt;script type=&quot;module&quot;&gt;import &quot;$&#123;clientPublicPath&#125;&quot;&lt;/script&gt;\n`</span><br><span class="line">async function rewriteHtml(importer: string, html: string) &#123;</span><br><span class="line">    return injectScriptToHtml(html, devInjectionCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当request.path 路径是 /vite/client 时，请求获取已经提前写好的关于 websocket 的代码。因此在客户端中我们创建了一个 websocket 服务并与服务端建立了连接。</p>
<p>Vite 会接受到来自客户端的消息。通过不同的消息触发一些事件。做到浏览器端的即时热模块更换（热更新）。包括 connect、vue-reload、vue-rerender 等事件，分别触发组件vue 的重新加载，render等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// Listen for messages</span><br><span class="line">socket.addEventListener(&#x27;message&#x27;, async (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">  const payload = JSON.parse(data) as HMRPayload | MultiUpdatePayload</span><br><span class="line">  if (payload.type === &#x27;multi&#x27;) &#123;</span><br><span class="line">    payload.updates.forEach(handleMessage)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    handleMessage(payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async function handleMessage(payload: HMRPayload) &#123;</span><br><span class="line">  const &#123; path, changeSrcPath, timestamp &#125; = payload as UpdatePayload</span><br><span class="line">  console.log(path)</span><br><span class="line">  switch (payload.type) &#123;</span><br><span class="line">    case &#x27;connected&#x27;:</span><br><span class="line">      console.log(`[vite] connected.`)</span><br><span class="line">      break</span><br><span class="line">    case &#x27;vue-reload&#x27;:</span><br><span class="line">      queueUpdate(</span><br><span class="line">        import(`$&#123;path&#125;?t=$&#123;timestamp&#125;`)</span><br><span class="line">          .catch((err) =&gt; warnFailedFetch(err, path))</span><br><span class="line">          .then((m) =&gt; () =&gt; &#123;</span><br><span class="line">            __VUE_HMR_RUNTIME__.reload(path, m.default)</span><br><span class="line">            console.log(`[vite] $&#123;path&#125; reloaded.`)</span><br><span class="line">          &#125;)</span><br><span class="line">      )</span><br><span class="line">      break</span><br><span class="line">    case &#x27;vue-rerender&#x27;:</span><br><span class="line">      const templatePath = `$&#123;path&#125;?type=template`</span><br><span class="line">      import(`$&#123;templatePath&#125;&amp;t=$&#123;timestamp&#125;`).then((m) =&gt; &#123;</span><br><span class="line">        __VUE_HMR_RUNTIME__.rerender(path, m.render)</span><br><span class="line">        console.log(`[vite] $&#123;path&#125; template updated.`)</span><br><span class="line">      &#125;)</span><br><span class="line">      break</span><br><span class="line">    case &#x27;style-update&#x27;:</span><br><span class="line">      // check if this is referenced in html via &lt;link&gt;</span><br><span class="line">      const el = document.querySelector(`link[href*=&#x27;$&#123;path&#125;&#x27;]`)</span><br><span class="line">      if (el) &#123;</span><br><span class="line">        el.setAttribute(</span><br><span class="line">          &#x27;href&#x27;,</span><br><span class="line">          `$&#123;path&#125;$&#123;path.includes(&#x27;?&#x27;) ? &#x27;&amp;&#x27; : &#x27;?&#x27;&#125;t=$&#123;timestamp&#125;`</span><br><span class="line">        )</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">      const importQuery = path.includes(&#x27;?&#x27;) ? &#x27;&amp;import&#x27; : &#x27;?import&#x27;</span><br><span class="line">      await import(`$&#123;path&#125;$&#123;importQuery&#125;&amp;t=$&#123;timestamp&#125;`)</span><br><span class="line">      console.log(`[vite] $&#123;path&#125; updated.`)</span><br><span class="line">      break</span><br><span class="line">    case &#x27;js-update&#x27;:</span><br><span class="line">      queueUpdate(updateModule(path, changeSrcPath, timestamp))</span><br><span class="line">      break</span><br><span class="line">    case &#x27;custom&#x27;:</span><br><span class="line">      const cbs = customUpdateMap.get(payload.id)</span><br><span class="line">      if (cbs) &#123;</span><br><span class="line">        cbs.forEach((cb) =&gt; cb(payload.customData))</span><br><span class="line">      &#125;</span><br><span class="line">      break</span><br><span class="line">    case &#x27;full-reload&#x27;:</span><br><span class="line">      if (path.endsWith(&#x27;.html&#x27;)) &#123;</span><br><span class="line">        // if html file is edited, only reload the page if the browser is</span><br><span class="line">        // currently on that page.</span><br><span class="line">        const pagePath = location.pathname</span><br><span class="line">        if (</span><br><span class="line">          pagePath === path ||</span><br><span class="line">          (pagePath.endsWith(&#x27;/&#x27;) &amp;&amp; pagePath + &#x27;index.html&#x27; === path)</span><br><span class="line">        ) &#123;</span><br><span class="line">          location.reload()</span><br><span class="line">        &#125;</span><br><span class="line">        return</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        location.reload()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h1><h2 id="1-构建工具和打包工具的区别？"><a href="#1-构建工具和打包工具的区别？" class="headerlink" title="1. 构建工具和打包工具的区别？"></a>1. 构建工具和打包工具的区别？</h2><blockquote>
<p>构建过程应该包括 预编译、语法检查、词法检查、依赖处理、文件合并、文件压缩、单元测试、版本管理等 。打包工具更注重打包这一过程，主要包括依赖管理和版本管理。</p>
</blockquote>
<h2 id="2-Vite有什么缺点？"><a href="#2-Vite有什么缺点？" class="headerlink" title="2. Vite有什么缺点？"></a>2. Vite有什么缺点？</h2><ul>
<li>目前 Vite 还是使用的 es module 模块不能直接使用生产环境（兼容性问题）。默认情况下，无论是 dev 还是 build 都会直接打出 ESM 版本的代码包，这就要求客户浏览器需要有一个比较新的版本，这放在现在的国情下还是有点难度的。不过 Vite 同时提供了一些弥补的方法，使用 build.polyfillDynamicImport 配置项配合 @vitejs/plugin-legacy 打包出一个看起来兼容性比较好的版本。</li>
<li>生产环境使用 rollup 打包会造成开发环境与生产环境的不一致。</li>
<li>很多 第三方 sdk 没有产出 ems 格式的的代码，这个需要自己去做一些兼容。</li>
</ul>
<h2 id="3-Vite生产环境用了Rollup，那能在生产环境中直接使用-esm-吗？"><a href="#3-Vite生产环境用了Rollup，那能在生产环境中直接使用-esm-吗？" class="headerlink" title="3. Vite生产环境用了Rollup，那能在生产环境中直接使用 esm 吗？"></a>3. Vite生产环境用了Rollup，那能在生产环境中直接使用 esm 吗？</h2><ul>
<li>其实目前的主要问题可能还是兼容性问题。</li>
<li>如果你的项目不需要兼容 IE11 等低版本的浏览器，自然是可以使用的。</li>
<li>但是更通用的方案可能还是类似 ployfill.io 的原理实现， 提前构建好 bundle.js 与 es module 两个版本的代码，根据浏览器的实际兼容性去动态选择导入哪个模块。</li>
</ul>
<h2 id="4-对于一些-没有产出-commonjs-的模块，如何去兼容呢？"><a href="#4-对于一些-没有产出-commonjs-的模块，如何去兼容呢？" class="headerlink" title="4. 对于一些 没有产出 commonjs 的模块，如何去兼容呢？"></a>4. 对于一些 没有产出 commonjs 的模块，如何去兼容呢？</h2><p>首先业界是有一些如 lebab 的方法可以将 commjs 代码快速转化为 esm 的，但是对于一些格式不规范的代码，可能还是需要单独处理。</p>
<h2 id="5-如果组件嵌套层级比较深，会影响速度吗？"><a href="#5-如果组件嵌套层级比较深，会影响速度吗？" class="headerlink" title="5. 如果组件嵌套层级比较深，会影响速度吗？"></a>5. 如果组件嵌套层级比较深，会影响速度吗？</h2><ul>
<li>可以看到请求 lodash 时 651 个请求只耗时 1.53s。这个耗时是完全可以接受的。</li>
<li>Vite 是完全按需加载的，在页面初始化时只会请求初始化页面的一些组件，也就是说即使层级深，但如果未展示可以不加载。</li>
</ul>
<h1 id="五、展望"><a href="#五、展望" class="headerlink" title="五、展望"></a>五、展望</h1><p><a target="_blank" rel="noopener" href="https://vitejs.cn/vite3-cn/">vite官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/cpMorMqdRY1K-Ahir0s9Ew">尤雨溪：Vite 的现状与未来展望</a></p>

        </div>
        <br />

        <!-- 分享 -->
        <div id="social-share" class="article-social-share"></div>

        <!-- 评论系统 -->
        
            <section id="comments" class="comments">
              <!-- 可以添加样式
              <style>
                .comments{margin:30px;padding:10px;background:#fff}
                @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
              </style> -->
              <!-- 评论系统。在post.ejs中引入 -->
<div class="valine_comment"></div>
<script type="module">
  import { init } from '/js/waline.mjs';
  // import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js'; // 在线url
  init({
    el: '.valine_comment',
    serverURL: 'https://blog.comment.helloallen.cn',
    // serverURL: 'https://allen-blog-vercel.vercel.app', // 未绑定域名的评论url，只能外网访问
  });
</script>
            </section>
        

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"># 项目构建</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <!-- 另一种的上一篇下一篇 -->
        <!-- <section class="post-nav">
            
                <a class="prev" rel="prev" href="/cf259748/">npx：npm包中可执行文件的工具</a>
            
            
            <a class="next" rel="next" href="/9e69b221/">认识 Babel</a>
            
        </section> -->
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/cf259748/"> &laquo; Prev </a>
            
            
                <a class="next" rel="next" href="/9e69b221/"> Next &raquo; </a>
            
        </section>


    </article>
</div>

            </div>
            <!-- 分享 -->
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" defer></script>
<link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">

<footer id="footer" class="footer">
    <div>
        <span>
            Allen © 
                2015 - 
                2024  
        </span> |   <!-- 站点访问量统计。在footer.ejs中引入 -->
<script async src="/js/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    <i class="iconfont icon-peoplecopy3"></i>
    <span id="busuanzi_value_site_uv"></span>
</span>&nbsp;


<span class="site-pv">
    <i class="iconfont icon-view"></i>
    <span id="busuanzi_value_site_pv"></span>
</span>

 
    </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & Theme by <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        </span>
    </div>

    <!-- 上个版本的统计当前站点运行时间 -->
    <!-- <div class="copyright">
        <span>© Allen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
        | <span id="timeDate">loading...</span>
        <span id="times" style="text-align: center;font-size: 12px;">载入时分秒...</span>
    </div> -->
</footer>

<!-- <script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("11/06/2020 00:00:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "This site has been running for "+dnum+" days "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    }
    setInterval("createtime()",250);
</script> -->

    </div>

    <!--Start of Tawk.to Script-->
    <script type="text/javascript">
        var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
        (function(){
            var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
            s1.async=true;
            s1.src='https://embed.tawk.to/66b239041601a2195ba16829/1i4k2tesf';
            s1.charset='UTF-8';
            s1.setAttribute('crossorigin','*');
            s0.parentNode.insertBefore(s1,s0);
        })();
    </script>
    <!--End of Tawk.to Script-->
</body>

</html>