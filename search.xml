<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GMT时间、UTC时间、CST时间</title>
    <url>/2020/11/09/GMT%E6%97%B6%E9%97%B4%E3%80%81UTC%E6%97%B6%E9%97%B4%E3%80%81CST%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h5 id="1-UTC时间-世界标准时间-与-GMT时间-格林威治时间"><a href="#1-UTC时间-世界标准时间-与-GMT时间-格林威治时间" class="headerlink" title="1.UTC时间(世界标准时间) 与 GMT时间(格林威治时间"></a>1.UTC时间(世界标准时间) 与 GMT时间(格林威治时间</h5><p>我们可以认为格林威治时间就是世界协调时间（GMT=UTC），格林威治时间和UTC时间均用秒数来计算的。<br>世界标准时间 (UTC, Coordinated Universal Time) 是当今民用时间的基础。它使用一天 24 小时时间制，并结合了地球的自转时间与原子钟的高精度度量。<br>UTC是一个标准，而不是一个时区。UTC 是一个全球通用的时间标准。全球各地都同意将各自的时间进行同步协调 (coordinated)，这也是 UTC 名字的来源：Universal Coordinated Time。</p>
<span id="more"></span>

<h5 id="2-UTC时间-与-本地时"><a href="#2-UTC时间-与-本地时" class="headerlink" title="2.UTC时间 与 本地时"></a>2.UTC时间 与 本地时</h5><p>UTC + 时区差 ＝ 本地时间<br>时区差东为正，西为负。在此，把东八区时区差记为 +0800，</p>
<p>UTC + (＋0800) = 本地（北京）时间 (1)</p>
<p>那么，UTC = 本地时间（北京时间)）- 0800 (2)</p>
<h5 id="3-UTC-与-Unix时间戳"><a href="#3-UTC-与-Unix时间戳" class="headerlink" title="3.UTC 与 Unix时间戳"></a>3.UTC 与 Unix时间戳</h5><p>在计算机中看到的UTC时间都是从（1970年01月01日 0:00:00)开始计算秒数的。所看到的UTC时间那就是从1970年这个时间点起到具体时间共有多少秒。 这个秒数就是Unix时间戳。</p>
<h5 id="4-其他时间"><a href="#4-其他时间" class="headerlink" title="4.其他时间"></a>4.其他时间</h5><p>ISO：标准时间<br>CST：北京时间(中国标准时间)</p>
<p><img src="https://img-blog.csdnimg.cn/20190131093542454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxOTAyNzA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议的 Request Payload 和 Form Data 的区别</title>
    <url>/2020/11/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84-Request-Payload-%E5%92%8C-Form-Data-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在一个前后端分离的新项目中，前端执行post请求，后端springMVC的 @RequestMapping 接收不到对应的请求参数。开始以为是前端webpack的proxy（将请求跨域代理到后台服务）配置问题。然而，并不是这样…</p>
<p><strong>proxy配置如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;proxy&quot;: &#123;</span><br><span class="line">	&quot;api&quot;: &#123;</span><br><span class="line">		&quot;target&quot;: &quot;http://localhost:7000/&quot;,</span><br><span class="line">		&quot;changeOrigin&quot;: true,</span><br><span class="line">		&quot;pathRewrite&quot;: &#123; &quot;^/api/v1&quot;: &quot;&quot; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>前端post请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case &#x27;post&#x27;:</span><br><span class="line">	return axios.post(url, data) // data = &#123;name: &#x27;xiaoming&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后端接收参数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SysAccount: private String name;</span><br><span class="line">@PostMapping(&quot;/accounts&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt;createAccount(SysAccount account) &#123;</span><br><span class="line">	&quot;dahuang&quot;.equsls(account.getName()); // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了前端发起的请求，请求正文并不是熟悉的Form Data，而是Request Payload。</p>
<h1 id="区别？"><a href="#区别？" class="headerlink" title="区别？"></a>区别？</h1><h2 id="Request-Payload"><a href="#Request-Payload" class="headerlink" title="Request Payload"></a>Request Payload</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzQucG5n?x-oss-process=image/format,png" alt="Request Payload"><br>对于Request Payload的HTTP请求报文格式大概如下，请求头部Content-Type: application/json，并且请求正文是一个json格式的字符串。（适用于一些复杂的数据对象，例如对象里面再嵌套数组）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123; &quot;foo&quot; : &quot;bar&quot;, &quot;name&quot; : &quot;John&quot; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Form-Data"><a href="#Form-Data" class="headerlink" title="Form Data"></a>Form Data</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzUucG5n?x-oss-process=image/format,png" alt="Form Data"><br>Form Data 大概格式如下，请求头部的 Content-Type: application/x-www-form-urlencoded，并且请求正文是类似 get 请求 url 的请求参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">foo=bar&amp;name=John</span><br></pre></td></tr></table></figure>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="后端处理"><a href="#后端处理" class="headerlink" title="后端处理"></a>后端处理</h2><p>对于 Request Payload 请求， 必须加 @RequestBody 才能将请求正文解析到对应的 bean 中，通过 request.getReader() 来获取请求正文内容（一说可以使用getRequestPayload方法来获取）。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzgucG5n?x-oss-process=image/format,png" alt="Request Payload"><br>对于Form Data请求，springmvc 会自动使用 MessageConverter 将请求参数解析到对应的 bean，且通过 request.getParameter(…) 能获取请求参数。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzkucG5n?x-oss-process=image/format,png" alt="Form Data"></p>
<h2 id="前端处理"><a href="#前端处理" class="headerlink" title="前端处理"></a>前端处理</h2><p>在前端使用Form Data的方式来发起请求，使用qs库将json对象转化为字符串。<br>(如 { name: ‘dahuang’,age: 11 } 转化为 name=dahuang&amp;age=11)<br>所以，通过下面的方法来解决:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将</span><br><span class="line">axios.post(url, cloneData)</span><br><span class="line">// 改写为</span><br><span class="line">axios.post(url, qs.stringify(cloneData))</span><br><span class="line">// 或者</span><br><span class="line">axios.post(url, &#123;data: &#123;&#125;,</span><br><span class="line">	headers: &#123;</span><br><span class="line">		content-type: &#x27;application/x-www-form-unlencoded&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>当请求头的Content-Type为application/json时浏览器认为该请求为复杂请求，这时浏览器会先进行一次预请求,执行一次OPTIONS 请求，向服务器求证该请求是否合法，如果服务器没有给出正确回应浏览器会报跨域请求导致请求失败。<br>一般这三种方式会导致这种现象:</p>
<ol>
<li>请求的方法不是GET/HEAD/POST</li>
<li>POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain</li>
<li>请求设置了自定义的header字段<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="传统的Form表单提交"><a href="#传统的Form表单提交" class="headerlink" title="传统的Form表单提交"></a>传统的Form表单提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;name&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;password&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
如果我这里点击提交按钮，就会触发浏览器的提交功能，那结果是什么样呢？<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzExLnBuZw?x-oss-process=image/format,png"><br>可以看到Content-Type为application/x-www-form-urlencoded。值得形式是以key1=value1&amp;key2=value2的形式提交的。<h2 id="传统的Ajax提交"><a href="#传统的Ajax提交" class="headerlink" title="传统的Ajax提交"></a>传统的Ajax提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function submit2() &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.timeout = 3000;</span><br><span class="line">    var obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">    xhr.open(&#x27;POST&#x27;, &#x27;/&#x27;);</span><br><span class="line">    xhr.send(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先我们构造一个简单的函数，然后触发它：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzEyLnBuZw?x-oss-process=image/format,png"></li>
<li>默认的Content-Type为text/plain。</li>
<li>Request Payload会对非字符串做字符串转换。</li>
<li>通过xhr.send(JSON.stringify(obj));可修正要发的内容<h2 id="axios方式提交"><a href="#axios方式提交" class="headerlink" title="axios方式提交"></a>axios方式提交</h2>由于axios已经是vue、react的准标配请求方式了，所以这里探究一下它。<br>首先我门看axios的文档，当post提交时候可以传递什么类型参数：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzEzLnBuZw?x-oss-process=image/format,png"><br>注意这个类型，我们分别构造两个场景。对应它。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function submit3() &#123;</span><br><span class="line">    var sence1 = &#x27;name=123&amp;val=456&#x27;;</span><br><span class="line">    var sence2 = &#123;name: 123, val: 456&#125;;</span><br><span class="line">    axios.post(&#x27;/&#x27;, sence1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
分别传递字符串与对象，提交post请求，然后观察结果:<br>场景1 — 传递字符串时候的结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzE0LnBuZw?x-oss-process=image/format,png"><br>场景2 — 传递对象的结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA1LzE1LnBuZw?x-oss-process=image/format,png"><br>当我们传递字符串的时候，Content-Type自动转为xxx-form-xxx的形式。当为对象的时候，自动转化为xxx/json。字符串的时候以key1=val1&amp;key2=val2的形式体现，对象以JSON字符串形式体现。</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客的 Next 主题配置</title>
    <url>/2020/11/06/Hexo%20%E5%8D%9A%E5%AE%A2%E7%9A%84%20Next%20%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>经过一番不懈的努力，我们终于按照 <a href="http://blog.helloallen.cn/archives/%E4%BD%BF%E7%94%A8githubpages%E5%92%8Chexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F">使用 Github Pages 和 Hexo 快速搭建博客系统</a> 搭建好了一个属于自己的博客，并且还安装了一个Next主题，但是我们的博客一开始还是很简陋的，我们需要把她装修一下。</p>
<blockquote>
<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。<br>以下所有终端执行的命令都在你的Hexo根目录下</p>
</blockquote>
<span id="more"></span>

<h1 id="一、基本信息配置"><a href="#一、基本信息配置" class="headerlink" title="一、基本信息配置"></a>一、基本信息配置</h1><blockquote>
<p>基本信息包括：博客标题、作者、描述、语言等等。</p>
</blockquote>
<p>打开 站点配置文件 ，找到Site模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>
<p>关于 站点配置文件 中的其他配置可参考<a href="https://hexo.io/zh-cn/docs/configuration.html">站点配置</a></p>
<h1 id="二、菜单和侧栏设置"><a href="#二、菜单和侧栏设置" class="headerlink" title="二、菜单和侧栏设置"></a>二、菜单和侧栏设置</h1><h2 id="1、菜单设置"><a href="#1、菜单设置" class="headerlink" title="1、菜单设置"></a>1、菜单设置</h2><blockquote>
<p>菜单包括：首页、归档、分类、标签、关于等等</p>
</blockquote>
<p>我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到 Menu Settings</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                          //首页</span><br><span class="line">  archives: /archives/ || archive          //归档</span><br><span class="line">  categories: /categories/ || th           //分类</span><br><span class="line">  tags: /tags/ || tags                     //标签</span><br><span class="line">  about: /about/ || user                   //关于</span><br><span class="line">  #schedule: /schedule/ || calendar        //日程表</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap        //站点地图</span><br><span class="line">  #commonweal: /404/ || heartbeat          //公益404</span><br></pre></td></tr></table></figure>

<p>看看你需要哪个菜单就把哪个取消注释打开就行了；<br>关于后面的格式，以archives: /archives/ || archive为例：<br>|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改<br>||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自<a href="https://fontawesome.com/icons">Font Awesome</a></p>
<h2 id="2、侧栏设置"><a href="#2、侧栏设置" class="headerlink" title="2、侧栏设置"></a>2、侧栏设置</h2><blockquote>
<p>侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等</p>
</blockquote>
<p>打开 主题配置文件 找到sidebar字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"># Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  position: left        //靠左放置</span><br><span class="line">  #position: right      //靠右放置</span><br><span class="line"></span><br><span class="line"># Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效）</span><br><span class="line">  #display: post        //默认行为，在文章页面（拥有目录列表）时显示</span><br><span class="line">  display: always       //在所有页面中都显示</span><br><span class="line">  #display: hide        //在所有页面中都隐藏（可以手动展开）</span><br><span class="line">  #display: remove      //完全移除</span><br><span class="line"></span><br><span class="line">  offset: 12            //文章间距（只对Pisces | Gemini两种风格有效）</span><br><span class="line"></span><br><span class="line">  b2t: false            //返回顶部按钮（只对Pisces | Gemini两种风格有效）</span><br><span class="line"></span><br><span class="line">  scrollpercent: true   //返回顶部按钮的百分比</span><br></pre></td></tr></table></figure>

<h1 id="三、主题样式和头像设置"><a href="#三、主题样式和头像设置" class="headerlink" title="三、主题样式和头像设置"></a>三、主题样式和头像设置</h1><h2 id="1、主题样式设置"><a href="#1、主题样式设置" class="headerlink" title="1、主题样式设置"></a>1、主题样式设置</h2><p>我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 主题配置文件 找到Scheme Settings</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<h2 id="2、头像设置"><a href="#2、头像设置" class="headerlink" title="2、头像设置"></a>2、头像设置</h2><p>打开 主题配置文件 找到Sidebar Avatar字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar: /images/header.jpg</span><br></pre></td></tr></table></figure>
<p>这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！</p>
<h1 id="四、添加分类模块"><a href="#四、添加分类模块" class="headerlink" title="四、添加分类模块"></a>四、添加分类模块</h1><p>1、新建一个分类页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为title: 分类<br>3、打开 主题配置文件 找到menu，将categorcies取消注释<br>4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中<br>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 分类测试文章标题</span><br><span class="line">categories: 分类名</span><br></pre></td></tr></table></figure>

<h1 id="五、添加标签模块"><a href="#五、添加标签模块" class="headerlink" title="五、添加标签模块"></a>五、添加标签模块</h1><p>1、新建一个标签页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签<br>3、打开 主题配置文件 找到menu，将tags取消注释<br>4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中<br>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标签测试文章标题</span><br><span class="line">tags: </span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h1 id="六、添加关于模块"><a href="#六、添加关于模块" class="headerlink" title="六、添加关于模块"></a>六、添加关于模块</h1><p>1、新建一个关于页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>
<p>2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。<br>3、打开 主题配置文件 找到menu，将about取消注释</p>
<h1 id="七、添加搜索功能"><a href="#七、添加搜索功能" class="headerlink" title="七、添加搜索功能"></a>七、添加搜索功能</h1><p>1、安装 <a href="https://github.com/theme-next/hexo-generator-search">hexo-generator-searchdb</a> 插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>2、打开 站点配置文件 找到Extensions在下面添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>3、打开 主题配置文件 找到Local search，将enable设置为true</p>
<h1 id="八、添加阅读全文按钮"><a href="#八、添加阅读全文按钮" class="headerlink" title="八、添加阅读全文按钮"></a>八、添加阅读全文按钮</h1><p>因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>其后面的部分就不会显示了，只能点击阅读全文才能看</p>
<h1 id="九、添加评论系统"><a href="#九、添加评论系统" class="headerlink" title="九、添加评论系统"></a>九、添加评论系统</h1><blockquote>
<p>目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。<br>本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。<br>后来选择了友言</p>
</blockquote>
<p>1、进入友言官网注册、登录步骤我就不介绍了<br>2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=1234567<br>3、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了</p>
<blockquote>
<p>更多有趣的个性化配置参考：<a href="https://segmentfault.com/a/1190000009544924">https://segmentfault.com/a/1190000009544924</a></p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的本地存储</title>
    <url>/2023/07/09/JS%E4%B8%AD%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h5 id="HTML-本地存储"><a href="#HTML-本地存储" class="headerlink" title="HTML 本地存储"></a>HTML 本地存储</h5><p>HTML5 本地存储提供了两个在客户端存储数据的对象</p>
<ul>
<li>window.localStorage - 存储没有截至日期的数据（永久性本地存储）</li>
<li>window.sessionStorage - 针对一个session来存储数据（会话级别本地存储）</li>
</ul>
<p>在使用本地存储时，请检测 localStorage 和 sessionStorage 的浏览器支持：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (typeof(Storage) !== &quot;undefined&quot;) &#123;</span><br><span class="line">    // 针对 localStorage/sessionStorage 的代码</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 抱歉！不支持 Web Storage ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、localStorage 对象<br>localStorage 对象存储的是没有截至日期的数据。当浏览器被关闭时数据不会被删除，在下一天、周或年中，都是可用的。H5标准要求浏览器至少支持到4MB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 存储</span><br><span class="line">localStorage.setItem(&quot;lastname&quot;, &quot;Gates&quot;)</span><br><span class="line">或</span><br><span class="line">localStorage.lastname = Gates</span><br><span class="line">// 取回</span><br><span class="line">localStorage.getItem(&quot;lastname&quot;)</span><br><span class="line">或</span><br><span class="line">localStorage.lastname</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">localStorage.removeItem(&quot;lastname&quot;)</span><br></pre></td></tr></table></figure>
<p>2、sessionStorage 对象<br>sessionStorage 对象等同 localStorage 对象，不同之处在于只对一个 session 存储数据。如果用户关闭具体的浏览器标签页，数据也会被删除。</p>
<p>3、本地数据库<br><a href="https://www.cnblogs.com/fly_dragon/p/3946012.html">逆天了的本地数据库</a></p>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>html4时代只能通过Cookie处理浏览器端的存储问题，有如下限制：</p>
<ul>
<li>大多数浏览器支持最大为4096字节的Cookie</li>
<li>浏览器还限制站点可以在用户计算机上存储的 Cookie 的数量。大多数浏览器只允许每个站点存储 20 个 Cookie；如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。</li>
<li>有些浏览器还会对它们将接受的来自所有站点的 Cookie 总数作出绝对限制，通常为 300 个。</li>
<li>Cookie默认情况都会随着Http请求发送到后台服务器，但并不是所有请求都需要Cookie的，比如：js、css、图片等请求则不需要cookie。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS判断当前设备</title>
    <url>/2020/11/09/JS%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h6 id="根据User-Agent判断打开设备为PC-手机"><a href="#根据User-Agent判断打开设备为PC-手机" class="headerlink" title="根据User-Agent判断打开设备为PC/手机"></a>根据User-Agent判断打开设备为PC/手机</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;</span><br><span class="line">    alert(&#x27;您正在通过手机访问&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&quot;您在PC端访问&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h6 id="判断客户端是否是iOS或者Android手机移动端："><a href="#判断客户端是否是iOS或者Android手机移动端：" class="headerlink" title="判断客户端是否是iOS或者Android手机移动端："></a>判断客户端是否是iOS或者Android手机移动端：</h6><p>通过判断浏览器的 userAgent，用正则来判断手机是否是ios和Android客户端。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var u = navigator.userAgent;</span><br><span class="line">    var isAndroid = u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Adr&#x27;) &gt; -1; //android终端</span><br><span class="line">    var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端</span><br><span class="line">    alert(&#x27;是否是Android：&#x27;+isAndroid);</span><br><span class="line">    alert(&#x27;是否是iOS：&#x27;+isiOS);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h6 id="下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端（Mobile）、ipad、iphone、微信、QQ等。"><a href="#下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端（Mobile）、ipad、iphone、微信、QQ等。" class="headerlink" title="下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端（Mobile）、ipad、iphone、微信、QQ等。"></a>下面一个比较全面的浏览器检查函数，提供更多的检查内容，你可以检查是否是移动端（Mobile）、ipad、iphone、微信、QQ等。</h6><p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    //判断访问终端</span><br><span class="line">    var browser=&#123;</span><br><span class="line">        versions:function()&#123;</span><br><span class="line">            var u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">            return &#123;</span><br><span class="line">                trident: u.indexOf(&#x27;Trident&#x27;) &gt; -1, //IE内核</span><br><span class="line">                presto: u.indexOf(&#x27;Presto&#x27;) &gt; -1, //opera内核</span><br><span class="line">                webKit: u.indexOf(&#x27;AppleWebKit&#x27;) &gt; -1, //苹果、谷歌内核</span><br><span class="line">                gecko: u.indexOf(&#x27;Gecko&#x27;) &gt; -1 &amp;&amp; u.indexOf(&#x27;KHTML&#x27;) == -1,//火狐内核</span><br><span class="line">                mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端</span><br><span class="line">                ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端</span><br><span class="line">                android: u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Adr&#x27;) &gt; -1, //android终端</span><br><span class="line">                iPhone: u.indexOf(&#x27;iPhone&#x27;) &gt; -1 , //是否为iPhone或者QQHD浏览器</span><br><span class="line">                iPad: u.indexOf(&#x27;iPad&#x27;) &gt; -1, //是否iPad</span><br><span class="line">                webApp: u.indexOf(&#x27;Safari&#x27;) == -1, //是否web应该程序，没有头部与底部</span><br><span class="line">                weixin: u.indexOf(&#x27;MicroMessenger&#x27;) &gt; -1, //是否微信 （2015-01-22新增）</span><br><span class="line">                qq: u.match(/\sQQ/i) == &quot; qq&quot; //是否QQ</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(),</span><br><span class="line">        language:(navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">    //使用方法：</span><br><span class="line">    //判断是否IE内核</span><br><span class="line">    if(browser.versions.trident)&#123; alert(&quot;is IE&quot;); &#125;</span><br><span class="line">    //判断是否webKit内核</span><br><span class="line">    if(browser.versions.webKit)&#123; alert(&quot;is webKit&quot;); &#125;</span><br><span class="line">    //判断是否移动端</span><br><span class="line">    if(browser.versions.mobile||browser.versions.android||browser.versions.ios)&#123;</span><br><span class="line">        alert(&quot;移动端&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>检测浏览器语言</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentLang = navigator.language;   //判断除IE外其他浏览器使用语言</span><br><span class="line">if(!currentLang)&#123;//判断IE浏览器使用语言</span><br><span class="line">    currentLang = navigator.browserLanguage;</span><br><span class="line">&#125;</span><br><span class="line">alert(currentLang);</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123;</span><br><span class="line">    //alert(navigator.userAgent);  </span><br><span class="line">    window.location.href =&quot;iPhone.html&quot;;</span><br><span class="line">&#125; else if (/(Android)/i.test(navigator.userAgent)) &#123;</span><br><span class="line">    //alert(navigator.userAgent); </span><br><span class="line">    window.location.href =&quot;Android.html&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    window.location.href =&quot;pc.html&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以通过这样来适配，然后直接转跳到移动端页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mobile_device_detect(url)&#123;</span><br><span class="line">  var thisOS=navigator.platform;</span><br><span class="line">  var os=new Array(&quot;iPhone&quot;,&quot;iPod&quot;,&quot;iPad&quot;,&quot;android&quot;,&quot;Nokia&quot;,&quot;SymbianOS&quot;,&quot;Symbian&quot;,&quot;Windows Phone&quot;,&quot;Phone&quot;,&quot;Linux armv71&quot;,&quot;MAUI&quot;,&quot;UNTRUSTED/1.0&quot;,&quot;Windows CE&quot;,&quot;BlackBerry&quot;,&quot;IEMobile&quot;);</span><br><span class="line">  for(var i=0;i&lt;os.length;i++)&#123;</span><br><span class="line">    if(thisOS.match(os[i]))&#123;</span><br><span class="line">      window.location.href=url;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(navigator.platform.indexOf(&#x27;iPad&#x27;) != -1)&#123;</span><br><span class="line">    window.location.href=url;</span><br><span class="line">  &#125;</span><br><span class="line">  var check = navigator.appVersion;</span><br><span class="line">  if( check.match(/linux/i) )&#123;</span><br><span class="line">    if(check.match(/mobile/i) || check.match(/X11/i))&#123;</span><br><span class="line">      window.location.href=url;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.w3h5.com/post/70.html">参考地址</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库的基本应用</title>
    <url>/2020/11/09/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="数据库使用"><a href="#数据库使用" class="headerlink" title="数据库使用"></a>数据库使用</h1><p>1、开启 mongodb 服务：要管理数据库，必须先开启服务，开启服务使用 <code>mongod --dbpath c:\mongodb</code><br><img src="https://img-blog.csdnimg.cn/img_convert/ad68308a4921cdf7e5987c5553109f80.png"></p>
<p>2、管理 mongodb 数据库：mongo (一定要在新的 cmd 中输入)<br><img src="https://img-blog.csdnimg.cn/img_convert/d2a3691bb5bb4d2002ac800e9c84117d.png"></p>
<span id="more"></span>

<p>3、其他命令<br>清屏：cls<br>查看所有数据库列表：show dbs</p>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>1、使用数据库、创建数据库：use student<br>如果真的想把这个数据库创建成功，那么必须插入一个数据。<br>数据库中不能直接插入数据，只能往集合(collections)中插入数据。不需要专门创建集合，只需要写点语法插入数据就会创建集合：<br><code>db.student.insert(&#123;“name”:”xiaoming”&#125;)</code><br>db.student 系统发现 student 是一个陌生的集合名字，所以就自动创建了集合。</p>
<p>2、显示当前的数据集合（mysql 中叫表）: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure>

<p>3、删除数据库，删除当前所在的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>

<p>4、删除集合，删除指定的集合 删除表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 删除集合 db.COLLECTION_NAME.drop()</span><br><span class="line">db.user.drop()</span><br></pre></td></tr></table></figure>

<h1 id="插入（增加）数据"><a href="#插入（增加）数据" class="headerlink" title="插入（增加）数据"></a>插入（增加）数据</h1><p>插入数据，随着数据的插入，数据库创建成功了，集合也创建成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.表名.insert(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;); student 集合名称（表）</span><br></pre></td></tr></table></figure>

<h1 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h1><p>1、查询所有记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find();</span><br><span class="line">相当于：select* from userInfo;</span><br></pre></td></tr></table></figure>

<p>2、查询去掉后的当前聚集集合中的某列的重复数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.distinct(&quot;name&quot;);</span><br><span class="line">会过滤掉 name 中的相同数据</span><br><span class="line">相当于：select distict name from userInfo;</span><br></pre></td></tr></table></figure>

<p>3、查询 age = 22 的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;&quot;age&quot;: 22&#125;);</span><br><span class="line">相当于： select * from userInfo where age = 22;</span><br></pre></td></tr></table></figure>

<p>4、查询 age &gt; 22 的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;age: &#123;$gt: 22&#125;&#125;);</span><br><span class="line">相当于：select * from userInfo where age &gt;22;</span><br></pre></td></tr></table></figure>

<p>5、查询 age &lt; 22 的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;age: &#123;$lt: 22&#125;&#125;);</span><br><span class="line">相当于：select * from userInfo where age &lt;22;</span><br></pre></td></tr></table></figure>

<p>6、查询 age &gt;= 25 的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;);</span><br><span class="line">相当于：select * from userInfo where age &gt;= 25;</span><br></pre></td></tr></table></figure>

<p>7、查询 age &lt;= 25 的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;age: &#123;$lte: 25&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>8、查询 age &gt;= 23 并且 age &lt;= 26 注意书写格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;age: &#123;$gte: 23, $lte: 26&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>9、查询 name 中包含 mongo 的数据 模糊查询用于搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;name: /mongo/&#125;);</span><br><span class="line">//相当于%%</span><br><span class="line">select * from userInfo where name like ‘%mongo%’;</span><br></pre></td></tr></table></figure>

<p>10、查询 name 中以 mongo 开头的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;name: /^mongo/&#125;);</span><br><span class="line">select * from userInfo where name like ‘mongo%’;</span><br></pre></td></tr></table></figure>

<p>11、查询指定列 name、age 数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;&#125;, &#123;name: 1, age: 1&#125;);</span><br><span class="line">相当于：select name, age from userInfo;</span><br></pre></td></tr></table></figure>
<p>当然 name 也可以用 true 或 false,当用 ture 的情况下和 name:1 效果一样，如果用 false 就是排除 name，显示 name 以外的列信息。</p>
<p>12、查询指定列 name、age 数据, age &gt; 25</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;);</span><br><span class="line">相当于：select name, age from userInfo where age &gt;25;</span><br></pre></td></tr></table></figure>

<p>13、按照年龄排序 1 升序 -1 降序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">升序：db.userInfo.find().sort(&#123;age: 1&#125;);</span><br><span class="line">降序：db.userInfo.find().sort(&#123;age: -1&#125;);</span><br></pre></td></tr></table></figure>

<p>14、查询 name = zhangsan, age = 22 的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;name: &#x27;zhangsan&#x27;, age: 22&#125;);</span><br><span class="line">相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’;</span><br></pre></td></tr></table></figure>

<p>15、查询前 5 条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find().limit(5);</span><br><span class="line">相当于：selecttop 5 * from userInfo;</span><br></pre></td></tr></table></figure>

<p>16、查询 10 条以后的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find().skip(10);</span><br><span class="line">相当于：select * from userInfo where id not in (selecttop 10 * from userInfo);</span><br></pre></td></tr></table></figure>

<p>17、查询在 5-10 之间的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find().limit(10).skip(5);</span><br><span class="line">可用于分页，limit 是 pageSize，skip 是第几页*pageSize</span><br></pre></td></tr></table></figure>

<p>18、or 与 查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;);</span><br><span class="line">相当于：select * from userInfo where age = 22 or age = 25;</span><br></pre></td></tr></table></figure>

<p>19、findOne 查询第一条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.findOne();</span><br><span class="line">相当于：selecttop 1 * from userInfo;</span><br><span class="line">db.userInfo.find().limit(1);</span><br></pre></td></tr></table></figure>

<p>20、查询某个结果集的记录条数 统计数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;).count();</span><br><span class="line">相当于：select count(*) from userInfo where age &gt;= 20;</span><br></pre></td></tr></table></figure>
<p>如果要返回限制之后的记录数量，要使用 count(true)或者 count(非 0)<br>db.users.find().skip(10).limit(5).count(true);</p>
<h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><p>1、修改里面还有查询条件。你要改谁，要告诉 mongo。<br>查找名字叫做小明的，把年龄更改为 16 岁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;小明&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:16&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>2、查找数学成绩是 70，把年龄更改为 33 岁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.student.update(&#123;&quot;score.shuxue&quot;:70&#125;,&#123;$set:&#123;&quot;age&quot;:33&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>3、更改所有匹配项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.student.update(&#123;&quot;sex&quot;:&quot;男&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:33&#125;&#125;,&#123;multi: true&#125;);</span><br></pre></td></tr></table></figure>
<p>完整替换，不出现$set 关键字了： 注意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;小明&quot;&#125;,&#123;&quot;name&quot;:&quot;大明&quot;,&quot;age&quot;:16&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.users.update(&#123;name: &#x27;Lisi&#x27;&#125;, &#123;$inc: &#123;age: 50&#125;&#125;, false, true);</span><br><span class="line">相当于：update users set age = age + 50 where name = ‘Lisi’;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.users.update(&#123;name: &#x27;Lisi&#x27;&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: &#x27;hoho&#x27;&#125;&#125;, false, true);</span><br><span class="line">相当于：update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’;</span><br></pre></td></tr></table></figure>


<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collectionsNames.remove( &#123; &quot;borough&quot;: &quot;Manhattan&quot; &#125; )</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.users.remove(&#123;age: 132&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs 操作 MongoDb 数据库</title>
    <url>/2021/11/09/Nodejs-%E6%93%8D%E4%BD%9C-MongoDb-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="在-Nodejs-中使用-MongoDB"><a href="#在-Nodejs-中使用-MongoDB" class="headerlink" title="在 Nodejs 中使用 MongoDB"></a>在 Nodejs 中使用 MongoDB</h1><p>需要引包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install mongodb --save-dev</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Nodejs-连接-MongoDB-数据库"><a href="#Nodejs-连接-MongoDB-数据库" class="headerlink" title="Nodejs 连接 MongoDB 数据库"></a>Nodejs 连接 MongoDB 数据库</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//数据库引用</span><br><span class="line">var MongoClient = require(&#x27;mongodb&#x27;).MongoClient;</span><br><span class="line">var app = express();</span><br><span class="line">//数据库连接的地址，最后的斜杠表示数据库名字</span><br><span class="line">var shujukuURL = &#x27;mongodb://localhost:27017/news&#x27;;</span><br><span class="line">app.get(&quot;/&quot;,</span><br><span class="line">function(req, res) &#123;</span><br><span class="line">    //连接数据库，这是一个异步的操作</span><br><span class="line">    MongoClient.connect(shujukuURL,</span><br><span class="line">    function(err, db) &#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &quot;Content-Type&quot;: &quot;text/html;charset=UTF8&quot;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.send(&quot;数据库连接失败&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        res.write(&quot;恭喜，数据库已经成功连接 \n&quot;);</span><br><span class="line">        db.collection(&quot;user&quot;).insertOne(&#123;</span><br><span class="line">            &quot;name&quot;: &quot;哈哈&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        function(err, result) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                res.send(&quot;数据库写入失败&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            res.write(&quot;恭喜，数据已经成功插入&quot;);</span><br><span class="line">            res.end();</span><br><span class="line">            //关闭数据库</span><br><span class="line">            db.close();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8020);</span><br></pre></td></tr></table></figure>

<h1 id="Nodejs-查找-MongoDB-数据库集合"><a href="#Nodejs-查找-MongoDB-数据库集合" class="headerlink" title="Nodejs 查找 MongoDB 数据库集合"></a>Nodejs 查找 MongoDB 数据库集合</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MongoClient.connect(dbUrl,</span><br><span class="line">function(err, db) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        /*数据库连接失败*/</span><br><span class="line">        console.log(&#x27;数据库连接失败&#x27;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var result = [];</span><br><span class="line">    var userRel = db.collection(&#x27;user&#x27;).find();</span><br><span class="line">    //res.send(userRel);</span><br><span class="line">    userRel.each(function(err, doc) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.write(&quot;游标遍历错误&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (doc != null) &#123;</span><br><span class="line">            result.push(doc);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">            //遍历完毕</span><br><span class="line">            db.close();</span><br><span class="line">            res.render(&quot;index&quot;, &#123;</span><br><span class="line">                &quot;result&quot;: result</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Nodejs-给-MongoDB-增加数据"><a href="#Nodejs-给-MongoDB-增加数据" class="headerlink" title="Nodejs 给 MongoDB 增加数据"></a>Nodejs 给 MongoDB 增加数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MongoClient.connect(dbUrl,</span><br><span class="line">function(err, db) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    db.collection(&#x27;user&#x27;).insertOne(&#123;</span><br><span class="line">        &quot;name&quot;: name,</span><br><span class="line">        &quot;age&quot;: age,</span><br><span class="line">        &quot;score&quot;: &#123;</span><br><span class="line">            &quot;shuxue&quot;: shuxuechengji,</span><br><span class="line">            &quot;yuwen&quot;: yuwenchengji</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    function(err, result) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(&#x27;写入数据失败&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭数据库</span><br><span class="line">        db.close();</span><br><span class="line">        //res.redirect(&#x27;/add&#x27;);</span><br><span class="line">        res.redirect(&#x27;/&#x27;);</span><br><span class="line">        /*路由跳转*/</span><br><span class="line">        res.end();</span><br><span class="line">        ////res.location(&#x27;/add&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Nodejs-修改-MongoDB-数据"><a href="#Nodejs-修改-MongoDB-数据" class="headerlink" title="Nodejs 修改 MongoDB 数据"></a>Nodejs 修改 MongoDB 数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MongoClient.connect(dbUrl,</span><br><span class="line">function(err, db) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.log(&#x27;数据库连接错误&#x27;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    db.collection(&#x27;user&#x27;).updateOne(&#123;</span><br><span class="line">        &quot;_id&quot;: ObjectID(id)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: name,</span><br><span class="line">        &quot;age&quot;: age,</span><br><span class="line">        &quot;score&quot;: &#123;</span><br><span class="line">            &quot;shuxue&quot;: shuxue,</span><br><span class="line">            &quot;yuwen&quot;: yuwen</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    function(err, results) &#123;</span><br><span class="line">        console.log(results);</span><br><span class="line">        db.close();</span><br><span class="line">        res.redirect(&#x27;/&#x27;);</span><br><span class="line">        /*路由跳转*/</span><br><span class="line">        res.end(&#x27;end&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Nodejs-删除-MongoDB-数据"><a href="#Nodejs-删除-MongoDB-数据" class="headerlink" title="Nodejs 删除 MongoDB 数据"></a>Nodejs 删除 MongoDB 数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MongoClient.connect(dbUrl,</span><br><span class="line">function(err, db) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        throw new Error(&quot;数据库连接失败&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    db.collection(&#x27;user&#x27;).deleteOne(&#123;</span><br><span class="line">        &quot;_id&quot;: ObjectID(id)</span><br><span class="line">    &#125;,</span><br><span class="line">    function(error, result) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            throw new Error(&#x27;删除数据失败&#x27;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        db.close();</span><br><span class="line">        res.redirect(&#x27;/&#x27;);</span><br><span class="line">        /*路由跳转*/</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs实战之一（一个最简单的 express 应用）</title>
    <url>/2021/11/09/Nodejs%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%EF%BC%88%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-express-%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 <a href="http://localhost:3000/">http://localhost:3000/</a> 时，输出 Hello World。</p>
<span id="more"></span>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>1、安装nvm工具以用其安装指定版本的node</p>
<ul>
<li>安装nvm（ <a href="https://github.com/creationix/nvm%EF%BC%89">https://github.com/creationix/nvm）</a></li>
<li>安装Node<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装v0.12版本的node</span><br><span class="line">$ nvm install 0.12</span><br><span class="line">// 安装完成后查看一下</span><br><span class="line">$ nvm ls</span><br><span class="line">// 这时候可以看到自己安装的所有Node版本，前面有绿色小箭头的表示当前正在使用的版本，如果安装了多个版本需要进行切换使用命令：</span><br><span class="line">$ nvm use 0.12</span><br><span class="line">// 查看是否安装成功</span><br><span class="line">$ node</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2、包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。</p>
<p>在上步安装node时里面已经自动带了npm。npm 可以自动管理包的依赖。 只需要安装你想要的包, 不必考虑这个包的依赖包.</p>
<p>在 PHP 中, 包管理使用的 Composer, python 中，包管理使用 easy_install 或者 pip，ruby 中我们使用 gem。而在 Node.js 中，对应就是 npm，npm 是 Node.js Package Manager 的意思。</p>
<p>3、框架 express 。学习新建 express 实例，并定义 routes ，产生输出。<br>express 是 Node.js 应用最广泛的 web 框架，现在是 4.x 版本，它非常薄。跟 Rails 比起来，完全两个极端。</p>
<p>express 的官网是 <a href="http://expressjs.com/">http://expressjs.com/</a> ，我常常上去看它的 API。</p>
<h1 id="实现内容"><a href="#实现内容" class="headerlink" title="实现内容"></a>实现内容</h1><blockquote>
<p>本实例假设大家都是在 Linux 或者 Mac 下面</p>
</blockquote>
<p>1、新建一个文件夹叫lesson1，进去里面安装express</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir lesson1 &amp;&amp; cd lesson1</span><br><span class="line"># 这里没有从官方 npm 安装，而是使用了大淘宝的 npm 镜像</span><br><span class="line">$ npm install express --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装完成后，我们的 lesson1 目录下应该会出现一个 node_modules 文件夹，ls 看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls node_modules</span><br></pre></td></tr></table></figure>
<p>里面如果出现 express 文件夹则说明安装成功。</p>
<p>或者 npm命令提供更清晰直观的显示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm list</span><br></pre></td></tr></table></figure>
<p>我们继续应用程序的编写。</p>
<p>新建一个 app.js 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch app.js</span><br></pre></td></tr></table></figure>
<p>copy 进去这些代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这句的意思就是引入 `express` 模块，并将它赋予 `express` 这个变量等待使用。</span><br><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。</span><br><span class="line">// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。</span><br><span class="line">// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。</span><br><span class="line">// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。</span><br><span class="line">app.get(&#x27;/&#x27;, function (req, res) &#123;</span><br><span class="line">  res.send(&#x27;Hello World&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。</span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&#x27;app is listening at port 3000&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node app.js</span><br></pre></td></tr></table></figure>
<p>这时候我们的 app 就跑起来了，终端中会输出 app is listening at port 3000。这时我们打开浏览器，访问 <a href="http://localhost:3000/%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0">http://localhost:3000/，会出现</a> Hello World。如果没有出现的话，肯定是上述哪一步弄错了，自己调试一下。</p>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs实战之三（使用 eventproxy 控制并发）</title>
    <url>/2021/11/09/Nodejs%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%89%EF%BC%88%E4%BD%BF%E7%94%A8-eventproxy-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%EF%BC%89/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>建立一个 lesson3 项目，在其中编写代码。</p>
<p>代码的入口是 app.js，当调用 node app.js 时，它会输出 CNode(<a href="https://cnodejs.org/">https://cnodejs.org/</a> ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。</p>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;【公告】发招聘帖的同学留意一下这里&quot;,</span><br><span class="line">    &quot;href&quot;: &quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;,</span><br><span class="line">    &quot;comment1&quot;: &quot;呵呵呵呵&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;,</span><br><span class="line">    &quot;href&quot;: &quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;,</span><br><span class="line">    &quot;comment1&quot;: &quot;沙发！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>1、体会 Node.js 的 callback hell 之美<br>2、学习使用 eventproxy 这一利器控制并发</p>
<h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><p><em>注意，cnodejs.org 网站有并发连接数的限制，所以当请求发送太快的时候会导致返回值为空或报错。建议一次抓取3个主题即可。文中的40只是为了方便讲解</em></p>
<p>这一章我们来到了 Node.js 最牛逼的地方——异步并发的内容了。</p>
<p>上一课我们介绍了如何使用 superagent 和 cheerio 来取主页内容，那只需要发起一次 http get 请求就能办到。但这次，我们需要取出每个主题的第一条评论，这就要求我们对每个主题的链接发起请求，并用 cheerio 去取出其中的第一条评论。</p>
<p>CNode 目前每一页有 40 个主题，于是我们就需要发起 1 + 40 个请求，来达到我们这一课的目标。</p>
<p>后者的 40 个请求，我们并发地发起，而且不会遇到多线程啊锁什么的，Node.js 的并发模型跟多线程不同，抛却那些观念。更具体一点的话，比如异步到底为何异步，Node.js 为何单线程却能并发这类走近科学的问题，我就不打算讲了。对于这方面有兴趣的同学，强烈推荐 @朴灵 的 《九浅一深Node.js》： <a href="http://book.douban.com/subject/25768396/">http://book.douban.com/subject/25768396/</a> 。</p>
<p>有些逼格比较高的朋友可能听说过 promise 和 generator 这类概念。不过我呢，只会讲 callback，主要原因是我个人只喜欢 callback。</p>
<p>这次课程我们需要用到三个库：superagent cheerio eventproxy(<a href="https://github.com/JacksonTian/eventproxy">https://github.com/JacksonTian/eventproxy</a> )</p>
<p>手脚架的工作各位自己来，我们一步一步来一起写出这个程序。</p>
<p>首先 app.js 应该长这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var eventproxy = require(&#x27;eventproxy&#x27;);</span><br><span class="line">var superagent = require(&#x27;superagent&#x27;);</span><br><span class="line">var cheerio = require(&#x27;cheerio&#x27;);</span><br><span class="line">// url 模块是 Node.js 标准库里面的</span><br><span class="line">// http://nodejs.org/api/url.html</span><br><span class="line">var url = require(&#x27;url&#x27;);</span><br><span class="line"></span><br><span class="line">var cnodeUrl = &#x27;https://cnodejs.org/&#x27;;</span><br><span class="line"></span><br><span class="line">superagent.get(cnodeUrl)</span><br><span class="line">  .end(function (err, res) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      return console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    var topicUrls = [];</span><br><span class="line">    var $ = cheerio.load(res.text);</span><br><span class="line">    // 获取首页所有的链接</span><br><span class="line">    $(&#x27;#topic_list .topic_title&#x27;).each(function (idx, element) &#123;</span><br><span class="line">      var $element = $(element);</span><br><span class="line">      // $element.attr(&#x27;href&#x27;) 本来的样子是 /topic/542acd7d5d28233425538b04</span><br><span class="line">      // 我们用 url.resolve 来自动推断出完整 url，变成</span><br><span class="line">      // https://cnodejs.org/topic/542acd7d5d28233425538b04 的形式</span><br><span class="line">      // 具体请看 http://nodejs.org/api/url.html#url_url_resolve_from_to 的示例</span><br><span class="line">      var href = url.resolve(cnodeUrl, $element.attr(&#x27;href&#x27;));</span><br><span class="line">      topicUrls.push(href);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(topicUrls);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>OK，这时候我们已经得到所有 url 的地址了，接下来，我们把这些地址都抓取一遍，就完成了，Node.js 就是这么简单。</p>
<p>抓取之前，还是得介绍一下 eventproxy 这个库。</p>
<p>用 js 写过异步的同学应该都知道，如果你要并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。</p>
<p>先定义一个 var count = 0，然后每次抓取成功以后，就 count++。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 count === 3。当值为真时，使用另一个函数继续完成操作。</p>
<p>而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来。</p>
<p>假设我们不使用 eventproxy 也不使用计数器时，抓取三个源的写法是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参考 jquery 的 $.get 的方法</span><br><span class="line">$.get(&quot;http://data1_source&quot;, function (data1) &#123;</span><br><span class="line">  // something</span><br><span class="line">  $.get(&quot;http://data2_source&quot;, function (data2) &#123;</span><br><span class="line">    // something</span><br><span class="line">    $.get(&quot;http://data3_source&quot;, function (data3) &#123;</span><br><span class="line">      // something</span><br><span class="line">      var html = fuck(data1, data2, data3);</span><br><span class="line">      render(html);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述的代码大家都写过吧。先获取 data1，获取完成之后获取 data2，然后再获取 data3，然后 fuck 它们，进行输出。</p>
<p>但大家应该也想到了，其实这三个源的数据，是可以并行去获取的，data2 的获取并不依赖 data1 的完成，data3 同理也不依赖 data2。</p>
<p>于是我们用计数器来写，会写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  var count = 0;</span><br><span class="line">  var result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  $.get(&#x27;http://data1_source&#x27;, function (data) &#123;</span><br><span class="line">    result.data1 = data;</span><br><span class="line">    count++;</span><br><span class="line">    handle();</span><br><span class="line">    &#125;);</span><br><span class="line">  $.get(&#x27;http://data2_source&#x27;, function (data) &#123;</span><br><span class="line">    result.data2 = data;</span><br><span class="line">    count++;</span><br><span class="line">    handle();</span><br><span class="line">    &#125;);</span><br><span class="line">  $.get(&#x27;http://data3_source&#x27;, function (data) &#123;</span><br><span class="line">    result.data3 = data;</span><br><span class="line">    count++;</span><br><span class="line">    handle();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  function handle() &#123;</span><br><span class="line">    if (count === 3) &#123;</span><br><span class="line">      var html = fuck(result.data1, result.data2, result.data3);</span><br><span class="line">      render(html);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>丑的一逼，也不算丑，主要我写代码好看。</p>
<p>如果我们用 eventproxy，写出来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ep = new eventproxy();</span><br><span class="line">ep.all(&#x27;data1_event&#x27;, &#x27;data2_event&#x27;, &#x27;data3_event&#x27;, function (data1, data2, data3) &#123;</span><br><span class="line">  var html = fuck(data1, data2, data3);</span><br><span class="line">  render(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.get(&#x27;http://data1_source&#x27;, function (data) &#123;</span><br><span class="line">  ep.emit(&#x27;data1_event&#x27;, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$.get(&#x27;http://data2_source&#x27;, function (data) &#123;</span><br><span class="line">  ep.emit(&#x27;data2_event&#x27;, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$.get(&#x27;http://data3_source&#x27;, function (data) &#123;</span><br><span class="line">  ep.emit(&#x27;data3_event&#x27;, data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>好看多了是吧，也就是个高等计数器嘛。</p>
<p>ep.all(‘data1_event’, ‘data2_event’, ‘data3_event’, function (data1, data2, data3) {});</p>
<p>这一句，监听了三个事件，分别是 data1_event, data2_event, data3_event，每次当一个源的数据抓取完成时，就通过 ep.emit() 来告诉 ep 自己，某某事件已经完成了。</p>
<p>当三个事件未同时完成时，ep.emit() 调用之后不会做任何事；当三个事件都完成的时候，就会调用末尾的那个回调函数，来对它们进行统一处理。</p>
<p>eventproxy 提供了不少其他场景所需的 API，但最最常用的用法就是以上的这种，即：</p>
<p>先 var ep = new eventproxy(); 得到一个 eventproxy 实例。<br>告诉它你要监听哪些事件，并给它一个回调函数。ep.all(‘event1’, ‘event2’, function (result1, result2) {})。<br>在适当的时候 ep.emit(‘event_name’, eventData)。<br>eventproxy 这套处理异步并发的思路，我一直觉得就像是汇编里面的 goto 语句一样，程序逻辑在代码中随处跳跃。本来代码已经执行到 100 行了，突然 80 行的那个回调函数又开始工作了。如果你异步逻辑复杂点的话，80 行的这个函数完成之后，又激活了 60 行的另外一个函数。并发和嵌套的问题虽然解决了，但老祖宗们消灭了几十年的 goto 语句又回来了。</p>
<p>至于这套思想糟糕不糟糕，我个人倒是觉得还是不糟糕，用熟了看起来蛮清晰的。不过 js 这门渣渣语言本来就乱嘛，什么变量提升（<a href="http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html">http://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html</a> ）啊，没有 main 函数啊，变量作用域啊，数据类型常常简单得只有数字、字符串、哈希、数组啊，这一系列的问题，都不是事儿。</p>
<p>编程语言美丑啥的，咱心中有佛就好。</p>
<p>回到正题，之前我们已经得到了一个长度为 40 的 topicUrls 数组，里面包含了每条主题的链接。那么意味着，我们接下来要发出 40 个并发请求。我们需要用到 eventproxy 的 #after API。</p>
<p>大家自行学习一下这个 API 吧：<a href="https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C">https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C</a></p>
<p>我代码就直接贴了哈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 得到 topicUrls 之后</span><br><span class="line"></span><br><span class="line">// 得到一个 eventproxy 的实例</span><br><span class="line">var ep = new eventproxy();</span><br><span class="line"></span><br><span class="line">// 命令 ep 重复监听 topicUrls.length 次（在这里也就是 40 次） `topic_html` 事件再行动</span><br><span class="line">ep.after(&#x27;topic_html&#x27;, topicUrls.length, function (topics) &#123;</span><br><span class="line">  // topics 是个数组，包含了 40 次 ep.emit(&#x27;topic_html&#x27;, pair) 中的那 40 个 pair</span><br><span class="line"></span><br><span class="line">  // 开始行动</span><br><span class="line">  topics = topics.map(function (topicPair) &#123;</span><br><span class="line">    // 接下来都是 jquery 的用法了</span><br><span class="line">    var topicUrl = topicPair[0];</span><br><span class="line">    var topicHtml = topicPair[1];</span><br><span class="line">    var $ = cheerio.load(topicHtml);</span><br><span class="line">    return (&#123;</span><br><span class="line">      title: $(&#x27;.topic_full_title&#x27;).text().trim(),</span><br><span class="line">      href: topicUrl,</span><br><span class="line">      comment1: $(&#x27;.reply_content&#x27;).eq(0).text().trim(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.log(&#x27;final:&#x27;);</span><br><span class="line">  console.log(topics);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">topicUrls.forEach(function (topicUrl) &#123;</span><br><span class="line">  superagent.get(topicUrl)</span><br><span class="line">    .end(function (err, res) &#123;</span><br><span class="line">      console.log(&#x27;fetch &#x27; + topicUrl + &#x27; successful&#x27;);</span><br><span class="line">      ep.emit(&#x27;topic_html&#x27;, [topicUrl, res.text]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>完整的app.js代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var eventproxy = require(&#x27;eventproxy&#x27;);</span><br><span class="line">var superagent = require(&#x27;superagent&#x27;);</span><br><span class="line">var cheerio = require(&#x27;cheerio&#x27;);</span><br><span class="line">var url = require(&#x27;url&#x27;);</span><br><span class="line"></span><br><span class="line">var cnodeUrl = &#x27;https://cnodejs.org/&#x27;;</span><br><span class="line"></span><br><span class="line">superagent.get(cnodeUrl)</span><br><span class="line">  .end(function (err, res) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      return console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    var topicUrls = [];</span><br><span class="line">    var $ = cheerio.load(res.text);</span><br><span class="line">    $(&#x27;#topic_list .topic_title&#x27;).each(function (idx, element) &#123;</span><br><span class="line">      var $element = $(element);</span><br><span class="line">      var href = url.resolve(cnodeUrl, $element.attr(&#x27;href&#x27;));</span><br><span class="line">      topicUrls.push(href);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    var ep = new eventproxy();</span><br><span class="line"></span><br><span class="line">    ep.after(&#x27;topic_html&#x27;, topicUrls.length, function (topics) &#123;</span><br><span class="line">      topics = topics.map(function (topicPair) &#123;</span><br><span class="line">        var topicUrl = topicPair[0];</span><br><span class="line">        var topicHtml = topicPair[1];</span><br><span class="line">        var $ = cheerio.load(topicHtml);</span><br><span class="line">        return (&#123;</span><br><span class="line">          title: $(&#x27;.topic_full_title&#x27;).text().trim(),</span><br><span class="line">          href: topicUrl,</span><br><span class="line">          comment1: $(&#x27;.reply_content&#x27;).eq(0).text().trim(),</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      console.log(&#x27;final:&#x27;);</span><br><span class="line">      console.log(topics);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    topicUrls.forEach(function (topicUrl) &#123;</span><br><span class="line">      superagent.get(topicUrl)</span><br><span class="line">        .end(function (err, res) &#123;</span><br><span class="line">          console.log(&#x27;fetch &#x27; + topicUrl + &#x27; successful&#x27;);</span><br><span class="line">          ep.emit(&#x27;topic_html&#x27;, [topicUrl, res.text]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs实战之二（使用 superagent 与 cheerio 完成简单爬虫）</title>
    <url>/2021/11/09/Nodejs%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BA%8C%EF%BC%88%E4%BD%BF%E7%94%A8-superagent-%E4%B8%8E-cheerio-%E5%AE%8C%E6%88%90%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%EF%BC%89/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>建立一个 lesson2 项目，在其中编写代码。</p>
<p>当在浏览器中访问 <a href="http://localhost:3000/">http://localhost:3000/</a> 时，输出 CNode(<a href="https://cnodejs.org/">https://cnodejs.org/</a> ) 社区首页的所有帖子标题和链接，以 json 的形式。</p>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;【公告】发招聘帖的同学留意一下这里&quot;,</span><br><span class="line">    &quot;href&quot;: &quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;,</span><br><span class="line">    &quot;href&quot;: &quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>1、学习使用 superagent 抓取网页</p>
<p><a href="http://visionmedia.github.io/superagent/">superagent</a> 是个 http 方面的库，可以发起 get 或 post 请求。</p>
<p>2、学习使用 cheerio 分析网页</p>
<p><a href="https://github.com/cheeriojs/cheerio">cheerio</a> 大家可以理解成一个 Node.js 版的 jquery，用来从网页中以 css selector 取数据，使用方式跟 jquery 一样一样的。</p>
<h1 id="实现内容"><a href="#实现内容" class="headerlink" title="实现内容"></a>实现内容</h1><p>1、新建一个文件夹，进去之后 npm init<br>2、安装依赖 npm install –save PACKAGE_NAME，此处需要三个包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;cheerio&quot;: &quot;^0.17.0&quot;,</span><br><span class="line">&quot;express&quot;: &quot;^4.9.5&quot;,</span><br><span class="line">&quot;superagent&quot;: &quot;^0.20.0&quot;</span><br></pre></td></tr></table></figure>
<p>3、新建app.js并写应用逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var cheerio = require(&#x27;cheerio&#x27;);</span><br><span class="line">var superagent = require(&#x27;superagent&#x27;);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, function (req, res, next) &#123;</span><br><span class="line">  // 用 superagent 去抓取 https://cnodejs.org/ 的内容</span><br><span class="line">  superagent.get(&#x27;https://cnodejs.org/&#x27;)</span><br><span class="line">    .end(function (err, sres) &#123;</span><br><span class="line">      // 常规的错误处理</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        return next(err);</span><br><span class="line">      &#125;</span><br><span class="line">      // sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load 之后</span><br><span class="line">      // 就可以得到一个实现了 jquery 接口的变量，我们习惯性地将它命名为 `$`</span><br><span class="line">      // 剩下就都是 jquery 的内容了</span><br><span class="line">      var $ = cheerio.load(sres.text);</span><br><span class="line">      var items = [];</span><br><span class="line">      $(&#x27;#topic_list .topic_title&#x27;).each(function (idx, element) &#123;</span><br><span class="line">        var $element = $(element);</span><br><span class="line">        items.push(&#123;</span><br><span class="line">          title: $element.attr(&#x27;title&#x27;),</span><br><span class="line">          href: $element.attr(&#x27;href&#x27;)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      res.send(items);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&#x27;app is listening at port 3000&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>4、在lesson2文件夹下执行node app.js<br>5、浏览器输入<a href="http://localhost:3000/%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81">http://localhost:3000/进行验证</a></p>
<p>OK，一个简单的爬虫就是这么简单。这里我们还没有利用到 Node.js 的异步并发特性。不过下两章内容(Nodejs实战之三、四)都是关于异步控制的。</p>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs实战之四（使用 async 控制并发）</title>
    <url>/2021/11/09/Nodejs%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9B%9B%EF%BC%88%E4%BD%BF%E7%94%A8-async-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%EF%BC%89/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>建立一个 lesson4 项目，在其中编写代码。</p>
<p>代码的入口是 app.js，当调用 node app.js 时，它会输出 CNode(<a href="https://cnodejs.org/">https://cnodejs.org/</a> ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。</p>
<p>注意：与上节课不同，并发连接数需要控制在 5 个。</p>
<p>输出示例：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;【公告】发招聘帖的同学留意一下这里&quot;,</span><br><span class="line">    &quot;href&quot;: &quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;,</span><br><span class="line">    &quot;comment1&quot;: &quot;呵呵呵呵&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;,</span><br><span class="line">    &quot;href&quot;: &quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;,</span><br><span class="line">    &quot;comment1&quot;: &quot;沙发！&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>1、学习 async(<a href="https://github.com/caolan/async">https://github.com/caolan/async</a> ) 的使用。这里有个详细的 async demo 演示：<a href="https://github.com/alsotang/async_demo">https://github.com/alsotang/async_demo</a></p>
<p>2、学习使用 async 来控制并发连接数。</p>
<h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><p>lesson3 的代码其实是不完美的。为什么这么说，是因为在 lesso3 中，我们一次性发了 40 个并发请求出去，要知道，除去 CNode 的话，别的网站有可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的 IP 封掉。</p>
<p>我们在写爬虫的时候，如果有 1000 个链接要去爬，那么不可能同时发出 1000 个并发链接出去对不对？我们需要控制一下并发的数量，比如并发 10 个就好，然后慢慢抓完这 1000 个链接。</p>
<p>用 async 来做这件事很简单。</p>
<p>这次我们要介绍的是 async 的 mapLimit(arr, limit, iterator, callback) 接口。另外，还有个常用的控制并发连接数的接口是 queue(worker, concurrency)，大家可以去 <a href="https://github.com/caolan/async#queueworker-concurrency">https://github.com/caolan/async#queueworker-concurrency</a> 看看说明。</p>
<p>这回我就不带大家爬网站了，我们来专注知识点：并发连接数控制。</p>
<p>对了，还有个问题是，什么时候用 eventproxy，什么时候使用 async 呢？它们不都是用来做异步流程控制的吗？</p>
<p>我的答案是：</p>
<p>当你需要去多个源(一般是小于 10 个)汇总数据的时候，用 eventproxy 方便；当你需要用到队列，需要控制并发数，或者你喜欢函数式编程思维时，使用 async。大部分场景是前者，所以我个人大部分时间是用 eventproxy 的。</p>
<p>正题开始。</p>
<p>首先，我们伪造一个 fetchUrl(url, callback) 函数，这个函数的作用就是，当你通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetchUrl(&#x27;http://www.baidu.com&#x27;, function (err, content) &#123;</span><br><span class="line">  // do something with `content`</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>调用它时，它会返回 <a href="http://www.baidu.com/">http://www.baidu.com</a> 的页面内容回来。</p>
<p>当然，我们这里的返回内容是假的，返回延时是随机的。并且在它被调用时，会告诉你它现在一共被多少个地方并发调用着。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 并发连接数的计数器</span><br><span class="line">var concurrencyCount = 0;</span><br><span class="line">var fetchUrl = function (url, callback) &#123;</span><br><span class="line">  // delay 的值在 2000 以内，是个随机的整数</span><br><span class="line">  var delay = parseInt((Math.random() * 10000000) % 2000, 10);</span><br><span class="line">  concurrencyCount++;</span><br><span class="line">  console.log(&#x27;现在的并发数是&#x27;, concurrencyCount, &#x27;，正在抓取的是&#x27;, url, &#x27;，耗时&#x27; + delay + &#x27;毫秒&#x27;);</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    concurrencyCount--;</span><br><span class="line">    callback(null, url + &#x27; html content&#x27;);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们接着来伪造一组链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var urls = [];</span><br><span class="line">for(var i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">  urls.push(&#x27;http://datasource_&#x27; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，我们使用 async.mapLimit 来并发抓取，并获取结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async.mapLimit(urls, 5, function (url, callback) &#123;</span><br><span class="line">  fetchUrl(url, callback);</span><br><span class="line">&#125;, function (err, result) &#123;</span><br><span class="line">  console.log(&#x27;final:&#x27;);</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，一开始，并发链接数是从 1 开始增长的，增长到 5 时，就不再增加。当其中有任务完成时，再继续抓取。并发连接数始终控制在 5 个。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>app.js 完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var async = require(&#x27;async&#x27;);</span><br><span class="line"></span><br><span class="line">var concurrencyCount = 0;</span><br><span class="line">var fetchUrl = function (url, callback) &#123;</span><br><span class="line">  var delay = parseInt((Math.random() * 10000000) % 2000, 10);</span><br><span class="line">  concurrencyCount++;</span><br><span class="line">  console.log(&#x27;现在的并发数是&#x27;, concurrencyCount, &#x27;，正在抓取的是&#x27;, url, &#x27;，耗时&#x27; + delay + &#x27;毫秒&#x27;);</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    concurrencyCount--;</span><br><span class="line">    callback(null, url + &#x27; html content&#x27;);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var urls = [];</span><br><span class="line">for(var i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">  urls.push(&#x27;http://datasource_&#x27; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async.mapLimit(urls, 5, function (url, callback) &#123;</span><br><span class="line">  fetchUrl(url, callback);</span><br><span class="line">&#125;, function (err, result) &#123;</span><br><span class="line">  console.log(&#x27;final:&#x27;);</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 从入门到自定义 系列一（准备阶段）</title>
    <url>/2023/07/09/Promise-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89-%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%88%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%89/</url>
    <content><![CDATA[<h1 id="区别实例对象和函数对象"><a href="#区别实例对象和函数对象" class="headerlink" title="区别实例对象和函数对象"></a>区别实例对象和函数对象</h1><ul>
<li>函数对象：将函数作为对象使用时，简称为函数对象</li>
<li>实例对象：new 函数产生的对象，简称为对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Fn() &#123; // Fn函数</span><br><span class="line">&#125;</span><br><span class="line">const fn = new Fn() // Fn是构造函数，fn是实例对象（简称对象）</span><br><span class="line">console.log(Fn.prototype) // Fn是函数对象</span><br><span class="line">Fn.bind(&#123;&#125;) // 调用Fn函数对象的bind方法</span><br><span class="line"></span><br><span class="line">$(&#x27;#test&#x27;) // jquery函数</span><br><span class="line">$.get(&#x27;/test&#x27;) // 调用jquery函数对象的get方法</span><br></pre></td></tr></table></figure>
<span id="more"></span>

</li>
</ul>
<h1 id="两种类型的回调函数"><a href="#两种类型的回调函数" class="headerlink" title="两种类型的回调函数"></a>两种类型的回调函数</h1><ul>
<li>同步回调<br>理解：立即执行，完全执行完成后才结束，不会放到回调队列中<br>例子：数组遍历相关的回调函数、Promise的excutor函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr=[1,3,5]</span><br><span class="line">arr.forEach(item =&gt; &#123;</span><br><span class="line">	console.log(item) // 先执行</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;forEach()后面&#x27;) // 后执行</span><br></pre></td></tr></table></figure></li>
<li>异步回调<br>理解：不会立即执行，会放入回调队列中将来执行<br>例子：定时器、ajax回调、Promise的成功或失败的回调<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;timeout callback()&#x27;) // 后执行</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(&#x27;setTimeout()后面&#x27;) // 先执行</span><br></pre></td></tr></table></figure>
<h1 id="JS的error处理"><a href="#JS的error处理" class="headerlink" title="JS的error处理"></a>JS的error处理</h1></li>
<li>错误的类型</li>
</ul>
<ol>
<li><p>Error: 所有错误的父类型</p>
</li>
<li><p>ReferenceError: 引用的变量不存在</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a) // Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>TypeError: 数据类型不正确的错误</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let b=null</span><br><span class="line">// Uncaught TypeError: Cannot read property &#x27;xx&#x27; of null</span><br><span class="line">console.log(b.xx)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>RangeError: 数据值不在其所允许的范围内</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Uncaught RangeError: Maximum call stack size exceeded</span><br><span class="line">function fn()&#123;</span><br><span class="line">	fn()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>SyntaxError: 语法错误</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const c=&quot;&quot;&quot;&quot; // Uncaught SyntaxError: Unexpected string</span><br></pre></td></tr></table></figure>

<ul>
<li>错误处理</li>
</ul>
<ol>
<li>捕获错误： try…catch<br>如果没有捕获错误，则错误之后的代码不会执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	let d</span><br><span class="line">	console.log(d.xxx)</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">	console.log(error.message)</span><br><span class="line">	console.log(error.stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>抛出错误：throw error</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function something() &#123;</span><br><span class="line">	if (Date.now()%2===1) &#123;</span><br><span class="line">		console.log(&#x27;当时间为奇数时，可执行任务&#x27;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 抛出异常</span><br><span class="line">		throw new Error(&#x27;当前时间为偶数无法执行任务&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 捕获异常</span><br><span class="line">try &#123;</span><br><span class="line">	something()</span><br><span class="line">&#125; catch(error) &#123;</span><br><span class="line">	alert(error.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>错误对象</li>
</ul>
<ol>
<li>message属性：错误相关信息</li>
<li>stack属性：函数调用栈记录信息</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 从入门到自定义 系列二（promise的理解和使用）</title>
    <url>/2023/07/09/Promise-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89-%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%88promise%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Promise是什么？"><a href="#Promise是什么？" class="headerlink" title="Promise是什么？"></a>Promise是什么？</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>抽象表达：Promise是JS中进行异步编程的新的解决方案（旧的是谁？纯回调）<br>具体表达：从语法上讲，Promise是一个构造函数（通过创建实例来使用）；从功能上说，Promise对象用来封装一个异步操作并可以获取其结果。</p>
<h2 id="promise的状态改变"><a href="#promise的状态改变" class="headerlink" title="promise的状态改变"></a>promise的状态改变</h2><ol>
<li>pending变为resolved</li>
</ol>
<ol start="2">
<li>pending变为rejected</li>
</ol>
<p>说明：只有这两种，且一个promise对象只能改变一次；无论变为成功还是失败，都会有一个结果数据；成功的结果数据一般称为value，失败的结果数据一般称为reason。</p>
<span id="more"></span>

<h2 id="promise的基本流程"><a href="#promise的基本流程" class="headerlink" title="promise的基本流程"></a>promise的基本流程</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvYWxsZW4uY24vdXBsb2FkLzIwMjAvMDYvcHJvbWlzZS1lYWMzMTE5ZmI3MjU0MDdjYTdmOGEwNTQzMjg1ZWFhZS5wbmc?x-oss-process=image/format,png" alt="promise.png"></p>
<h2 id="promise的基本使用"><a href="#promise的基本使用" class="headerlink" title="promise的基本使用"></a>promise的基本使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 创建一个新的promise对象</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123; // 执行器函数</span><br><span class="line">	// 2. 执行异步操作任务</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		// 3.1 如果成功了，调用resolve(value)</span><br><span class="line">		if (time%2==0) &#123;</span><br><span class="line">			resolve(&#x27;成功的数据，time=&#x27;, + time)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 3.2 如果失败了，调用reject(reason)</span><br><span class="line">			reject(&#x27;失败的数据, time=&#x27;, + time)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	value =&gt; &#123; // 接收得到成功的value数据 onResolved</span><br><span class="line">		console.log(&#x27;成功的回调&#x27;, value)</span><br><span class="line">	&#125;,</span><br><span class="line">	reason =&gt; &#123; // 接收得到失败的reason数据 onRejected</span><br><span class="line">		console.log(&#x27;失败的回调&#x27;, reason)</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="为什么要用Promsie？"><a href="#为什么要用Promsie？" class="headerlink" title="为什么要用Promsie？"></a>为什么要用Promsie？</h1><h2 id="指定回调函数的方式更加灵活"><a href="#指定回调函数的方式更加灵活" class="headerlink" title="指定回调函数的方式更加灵活"></a>指定回调函数的方式更加灵活</h2><p>旧的：必须在启动异步任务前指定<br>promise：启动异步任务-&gt;返回promise对象-&gt;给promise对象绑定回调函数（甚至可以在异步任务后指定）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以下为伪代码不能执行，说明了旧的回调方式回调函数必须在异步任务前指定，而promise指定回调函数更加灵活</span><br><span class="line">function successCallback(resule) &#123;</span><br><span class="line">	console.log(&#x27;声音文件创建成功:&#x27;+resule)</span><br><span class="line">&#125;</span><br><span class="line">function failureCallback(error) &#123;</span><br><span class="line">	console.log(&#x27;声音文件创建失败:&#x27;+error)</span><br><span class="line">&#125;</span><br><span class="line">// 1. 使用纯回调函数</span><br><span class="line">createAudioFileAsync(audioSettings, successCallback, failureCallback)</span><br><span class="line">// 2. 使用promise</span><br><span class="line">const promise = createAudioFileAsync(audioSettings)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">	promise.then(successCallback,failureCallback)</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure>

<h2 id="支持链式调用，可以解决回调地狱问题"><a href="#支持链式调用，可以解决回调地狱问题" class="headerlink" title="支持链式调用，可以解决回调地狱问题"></a>支持链式调用，可以解决回调地狱问题</h2><p>什么是回调地狱？回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件。<br>回调地狱的缺点？不便于阅读、不便于异步处理<br>解决方案？promise链式调用<br>终极解决方案？async/await</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 回调地狱</span><br><span class="line">doSomething(function(result)&#123;</span><br><span class="line">	doSomethingElse(result, function(newResult)&#123;</span><br><span class="line">		doThirdThing(newResult, function(finalResult)&#123;</span><br><span class="line">			console.log(&#x27;Got the final result:&#x27; + finalResult)</span><br><span class="line">		&#125;, failureCallback)</span><br><span class="line">	&#125;, failureCallback)</span><br><span class="line">&#125;, failureCallback)</span><br><span class="line"></span><br><span class="line">// 2. 使用promise的链式调用解决回调地狱</span><br><span class="line">doSomething().then(function(result)&#123;</span><br><span class="line">	return doSomethingElse(result)</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(newResult) &#123;</span><br><span class="line">	return doThirdThing(newResult)</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(finalResult)&#123;</span><br><span class="line">	console.log(&#x27;Got the final result:&#x27;+finalResult)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback)</span><br><span class="line"></span><br><span class="line">// 3. async/await：回调地狱的终极解决方案</span><br><span class="line">async function request() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		const result=await doSomething()</span><br><span class="line">		const newResult=await doSomethingElse(result)</span><br><span class="line">		const finalResult=await soThirdThing(newResult)</span><br><span class="line">		console.log(&#x27;Got the final result&#x27;+finalResult)</span><br><span class="line">	&#125; catch(error) &#123;</span><br><span class="line">		failureCallback(error)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何使用Promise？"><a href="#如何使用Promise？" class="headerlink" title="如何使用Promise？"></a>如何使用Promise？</h1><blockquote>
<p>主要讲解Promise的API</p>
</blockquote>
<p>1、Promise构造函数：Promise(excutor){}<br>excutor函数：同步执行 (resolve, reject)=&gt;{}<br>resolve函数：内部定义成功时我们调用的函数 value=&gt;{}<br>reject函数：内部定义失败时我们调用的函数 reason=&gt;{}<br>说明：excutor会在Promise内部立即同步回调，异步操作在执行器中执行</p>
<p>2、Promise.prototype.then方法：(onResolved, onRejected)=&gt;{}<br>onResolved函数：成功的回调函数 (value)=&gt;{}<br>onRejected函数：失败的回调函数 (reason)=&gt;{}<br>说明：指定用于得到成功value的成功回调和用于得到失败reason的失败回调，返回一个新的promise对象</p>
<p>3、Promise.prototype.catch方法：(onRejected)=&gt;{}<br>onRejected函数：失败的回调函数 (reason)=&gt;{}<br>说明：then()的语法糖，相当于：then(undefined, onRejected)</p>
<p>4、Promise.resolve方法：(value)=&gt;{}<br>value: 成功的数据或promise对象<br>说明：返回一个成功/失败的promise对象</p>
<p>5、Promise.reject方法：(reason)=&gt;{}<br>reason：失败的原因<br>说明：返回一个失败的promise对象</p>
<p>6、Promise.all方法：(promises)=&gt;{}<br>promises：包含n个promise的数组<br>说明：返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败了就直接失败</p>
<p>7、Promise.race方法：(promises)=&gt;{}<br>promises: 包含n个promise数组<br>说明：返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123; // 模拟异步</span><br><span class="line">		resolve(&#x27;成功的数据&#x27;)</span><br><span class="line">		// reject(&#x27;失败的数据&#x27;)</span><br><span class="line">	&#125;, 1000)</span><br><span class="line">&#125;).then(</span><br><span class="line">	value=&gt;&#123;</span><br><span class="line">		console.log(&#x27;onResolved()&#x27;, value)</span><br><span class="line">	&#125;</span><br><span class="line">).catch(</span><br><span class="line">	reason=&gt;&#123;</span><br><span class="line">		console.log(&#x27;onRejected()&#x27;, reason)</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 产生一个成功值为1的promise对象</span><br><span class="line">const p1=new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">	resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">// 产生一个成功值为2的promise对象</span><br><span class="line">const p2=Promise.resolve(2)  // 语法糖</span><br><span class="line">const p3=Promise.reject(3)</span><br><span class="line"></span><br><span class="line">p1.then(value=&gt;&#123;console.log(value)&#125;) //1</span><br><span class="line">p2.then(value=&gt;&#123;console.log(value)&#125;) //2</span><br><span class="line">p3.catch(reason=&gt;&#123;console.log(reason)&#125;) //3</span><br><span class="line"></span><br><span class="line">// 一个失败的话返回失败的数据，成功的话返回成功的数组</span><br><span class="line">const pAll = Promise.all([p1,p2,p3])</span><br><span class="line">pAll.then(</span><br><span class="line">	values=&gt;&#123;&#125;,</span><br><span class="line">	reason=&gt;&#123;</span><br><span class="line">		console.log(&#x27;all onRejected()&#x27;, reason) // 3</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const pRace = Promise.race([p1,p2,p3])</span><br><span class="line">pRace.then(</span><br><span class="line">	value=&gt;&#123;</span><br><span class="line">		console.log(&#x27;race onResolved()&#x27;, value)</span><br><span class="line">	&#125;,</span><br><span class="line">	reason=&gt;&#123;</span><br><span class="line">		console.log(&#x27;race onRejected()&#x27;, reason)</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目中两种文件下载方式</title>
    <url>/2021/11/09/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%A4%E7%A7%8D%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>以下载（导出）Excel文件为例</p>
</blockquote>
<h1 id="不需要携带token"><a href="#不需要携带token" class="headerlink" title="不需要携带token"></a>不需要携带token</h1><p>直接调用后台接口，携带需要传递的参数，具体实现代码如下：</p>
<span id="more"></span>

<p><strong>1、在main.js中封装指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let baseDownloadUrl = &#x27;http://xxxxxxx:8080&#x27; // 域名</span><br><span class="line">const PATH = &#123;</span><br><span class="line">    userList：&#x27;vue/export/userList&#x27; // 后台接口地址</span><br><span class="line">&#125;</span><br><span class="line">// 封装v-out指令</span><br><span class="line">Vue.directive(&#x27;out&#x27;, &#123;</span><br><span class="line">    inserted: (el, binding) = &gt;&#123;</span><br><span class="line">        el.addEventListener(&#x27;click&#x27;, () = &gt;&#123;</span><br><span class="line">            console.log(binding.value) // 自定义指令传请求参数</span><br><span class="line">            let a = document.createElement(&#x27;a&#x27;) // 创建a标签</span><br><span class="line">            // 处理请求参数，在url后面拼接</span><br><span class="line">            let params = &#x27;?&#x27;</span><br><span class="line">            for (let key in binding.value.params) &#123;</span><br><span class="line">                params = params + key + &#x27;=&#x27; + binding.value.params[key] + &#x27;&amp;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(params) a.style.display = &#x27;none&#x27;</span><br><span class="line">            // 测试导出文件</span><br><span class="line">            // link.href =	&#x27;https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7BA381F257-9F2F-3652-F0EC-56B9B2C86F92%7D%26lang%3Dzh-CN%26browser%3D4%26usagestats%3D1%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers%26ap%3Dx64-stable-statsdef_1%26installdataindex%3Dempty/update2/installers/ChromeSetup.exe&#x27;</span><br><span class="line">            // a标签添加导出地址</span><br><span class="line">            a.href = baseDownloadUrl + PATH[binding.value.pathName] + putCode + (params || &#x27;&#x27;) a.setAttribute(&#x27;download&#x27;, &#x27;文件名&#x27;) // a标签添加download属性，导出文件名需要就添加，不需要则为空</span><br><span class="line">            document.body.appendChild(a) a.click() // 触发a标签点击事件</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2、在需要导出的页面应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button</span><br><span class="line">  size=&quot;small&quot;  </span><br><span class="line">  type=&quot;primary&quot;	</span><br><span class="line">  v-out=&quot;&#123;</span><br><span class="line">    pathName: &#x27;userList&#x27;,</span><br><span class="line">    params: //&#123;请求参数&#125;</span><br><span class="line">  &#125;&quot;	</span><br><span class="line">&gt;导出&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
<h1 id="携带token下载"><a href="#携带token下载" class="headerlink" title="携带token下载"></a>携带token下载</h1><p>token封装在请求头里，在请求头里发送给后端。调用导出接口时，需要加参数：responseType: ‘blob’ （必须要有的）</p>
<p><strong>1、封装导出请求文件exportOut.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function expotOut (searchList, pathName, xlsName) &#123;</span><br><span class="line">  // 获取时间，这一步是在下载时文件名带下载日期，例如：用户信息2020-04-27.xls,如无需要可以去掉</span><br><span class="line">  let d = new Date()</span><br><span class="line">  let month = (d.getMonth() + 1)</span><br><span class="line">  let day = d.getDate()</span><br><span class="line">  let time = d.getFullYear() + &#x27;-&#x27; + (String(month).length &gt; 1 ? month : &#x27;0&#x27; + month) + &#x27;-&#x27; + (String(day).length &gt; 1 ? day : &#x27;0&#x27; + day)</span><br><span class="line">  // 地址</span><br><span class="line">  let baseURL = &#x27;http://xxxxxxx:8080&#x27;  // 域名</span><br><span class="line">  const PATH = &#123;</span><br><span class="line">    userList：&#x27;vue/export/userList&#x27;, // 后台接口地址</span><br><span class="line">  &#125;</span><br><span class="line">  // 参数</span><br><span class="line">  let params = &#x27;?&#x27;</span><br><span class="line">  for (let key in searchList) &#123;</span><br><span class="line">    params = params + key + &#x27;=&#x27; + searchList[key] + &#x27;&amp;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function createObjectURL (object) &#123; return (window.URL) ? window.URL.createObjectURL(object) : window.webkitURL.createObjectURL(object) &#125;</span><br><span class="line">  var xhr = new XMLHttpRequest()</span><br><span class="line">  var formData = new FormData()</span><br><span class="line">  xhr.open(&#x27;get&#x27;, baseURL + PATH[pathName] + params) // url填写后台的接口地址，如果是post，在formData append参数（参考原文地址）</span><br><span class="line">  xhr.setRequestHeader(&#x27;token&#x27;, localStorage.getItem(&#x27;token&#x27;))</span><br><span class="line">  xhr.responseType = &#x27;blob&#x27;</span><br><span class="line">  xhr.onload = function (e) &#123;</span><br><span class="line">    if (this.status === 200) &#123;</span><br><span class="line">      var blob = this.response</span><br><span class="line">      // xls文件名称</span><br><span class="line">      var filename = `$&#123;xlsName&#125;$&#123;time&#125;.xls`</span><br><span class="line">      if (window.navigator.msSaveOrOpenBlob) &#123;</span><br><span class="line">        navigator.msSaveBlob(blob, filename)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        var a = document.createElement(&#x27;a&#x27;)</span><br><span class="line">        var url = createObjectURL(blob)</span><br><span class="line">        a.href = url</span><br><span class="line">        a.download = filename</span><br><span class="line">        document.body.appendChild(a)</span><br><span class="line">        a.click()</span><br><span class="line">        window.URL.revokeObjectURL(url)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(formData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、vue文件中使用导出功能</strong></p>
<ul>
<li>引入exportOut.js<br><code>import &#123; expotOut &#125; from &#39;../http/exportOut&#39;</code></li>
<li>使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    // 导出</span><br><span class="line">    outFile () &#123;</span><br><span class="line">      expotOut(this.searchList, // 导出请求参数</span><br><span class="line">        &#x27;userList&#x27;, // 后台地址PATH对象的key</span><br><span class="line">        &#x27;用户信息&#x27;// 导出文件名字</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>从第一代 iPhone 细数到 iPhone 12，iPhone 屏幕尺寸进化历程背后的 app 设计哲学</title>
    <url>/2022/11/09/%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%BB%A3-iPhone-%E7%BB%86%E6%95%B0%E5%88%B0-iPhone-12%EF%BC%8CiPhone-%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E8%BF%9B%E5%8C%96%E5%8E%86%E7%A8%8B%E8%83%8C%E5%90%8E%E7%9A%84-app-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[<blockquote>
<p>相关概念：</p>
</blockquote>
<ol>
<li><strong>像素（px）</strong>：是画面中最小的点（单位色块）。</li>
<li><strong>分辨率</strong>：画面水平方向的像素值 * 画面垂直方向的像素值。</li>
<li><strong>位色</strong>：色彩位数以二进制的位(bit)为单位，用位的多少表示色彩数的多少。在颜色中的三原色RGB各自分为256级灰度，组合出来的256×256×256=16700万色，也就是通常说的24位或24bit色(2的24次方)。256种颜色要用8位二进制数表示，即2的8次方，因此我们把256色图形叫做8位图。同理，能显示65536种颜色的话，就是16位图，也就是2的16次方。总之色彩位数越高，就可以得到更大的色彩动态范围。也就是说，对颜色的区分能够更加细腻。</li>
</ol>
<span id="more"></span>

<blockquote>
<p>本文重点概念：</p>
</blockquote>
<ol>
<li><strong>point(pt)点</strong>：iphone4、4s和iphone3G、3GS相比，屏幕尺寸都为3.5英寸，但是屏幕分辨率是之前的2倍。如果开发app出图时，针对不同代产品，图片的实际大小相同，但像素不同，会导致沟通和操作成本，所以引入了pt。它与屏幕上的像素密度无关，只与屏幕上的内容多少有关。</li>
<li><strong>逻辑分辨率</strong>：使用「point 点」这个单位表示的分辨率我们可以称之为逻辑分辨率。比如iphone3代是(320 x 480)pt@1x，iphone4代是(320 x 480)pt@2x。@2x是比例因子</li>
<li><strong>渲染分辨率</strong>：使用「px 像素」这个单位表示的分辨率我们可以称之为渲染分辨率。比如iphone3代是(320 x 480)px</li>
<li><strong>屏幕物理分辨率</strong>：iPhone 6 Plus 有一点比较特殊的地方，其渲染分辨率为 1242px × 2208px，但其设备真实的屏幕物理分辨率只有 1080px × 1920px，也即处理器渲染的图像分辨率比屏幕自身物理分辨率更高，在实际显示时相当于将渲染的图像缩小了 1.15 倍。图像在屏幕上显示时如果能做到像素一对一显示效果才能最完美，但 Apple 在此机型上作出了妥协，究其原因可能是因为当时 1080p 的屏幕的广泛使用可以削减手机成本、加快出货日期，同时也可以有更好的续航能力。</li>
</ol>
<blockquote>
<p>正文从这开始~~</p>
</blockquote>
<p>从 2007 年发布的第一代 iPhone 到 2019 年发布的 iPhone 11 系列，iPhone 的屏幕尺寸已涵盖 3.5 寸、4 寸、4.7 寸、5.5 寸、5.8 寸、6.1 寸、6.5 寸七种，传闻将于今年秋季发布的 iPhone 12 还会增加 5.4 寸、6.7 寸两种尺寸。随着时间轴的推移，iPhone 的屏幕尺寸已经变得越来越多，越来越复杂，一个 app 要适配所有的这些屏幕尺寸，在从设计、开发到推广的整个过程中都需要考虑诸多因素。</p>
<p>在 iOS 14 Beta 3 版本中，有用户发现 5.8 寸的 iPhone X/Xs/11 Pro 机型新增了「放大显示」功能，进而发现 iOS 14 可以以 960 x 2079 像素这个新的分辨率正常运行。而在之前的版本中，5.8 寸的 iPhone 机型上一直没有放大显示功能，结合新发现的运行分辨率，我们有理由推测 Apple 正在为一款小屏幕手机做准备，而这个分辨率很可能就是传闻中即将发布的 5.4 寸 iPhone 12 的准确分辨率 。</p>
<p>在这 13 年间 iPhone 的屏幕尺寸是怎样一步步进化到此的？基于软硬一体的设计，屏幕物理尺寸的变化背后包含着怎样的进化规律？这些变化对我们朝夕相处的手机 app 又产生了什么影响？根据已有的进化规律，我们是否可以展望未来的 iPhone 还会走向何方？基于 iOS 14 Beta 中发现的新线索，我们又可以推断出 iPhone 12 的哪些更多信息呢？本文就来说道说道。</p>
<h1 id="iPhone-起源：从-3-5-寸的小屏幕开始"><a href="#iPhone-起源：从-3-5-寸的小屏幕开始" class="headerlink" title="iPhone 起源：从 3.5 寸的小屏幕开始"></a>iPhone 起源：从 3.5 寸的小屏幕开始</h1><h2 id="从第一代-iPhone-到-iPhone-4s"><a href="#从第一代-iPhone-到-iPhone-4s" class="headerlink" title="从第一代 iPhone 到 iPhone 4s"></a>从第一代 iPhone 到 iPhone 4s</h2><p>第一代 iPhone 于 2007 年发布，配备 320 × 480 像素（pixel，可简写为 px）的 3.5 寸屏幕，PPI （表示每英寸所具有的像素数，数字越大清晰度越好）为 163，这块支持多点触控的小屏幕开创了 iPhone 历史的先河。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cefb1708538313d6ef72a0d2246be182.png"></p>
<p>2008 年 iPhone 3G 发布，其搭载的 iPhone OS 2.0 系统首次支持了 App Store 功能，自此第三方 app 开始逐渐在 iPhone 上大放异彩；2009 年 iPhone 3GS 发布，相比前一代，其屏幕从 18 位色升级到了 24 位色，屏幕表现更加丰富。iPhone 3G 和 iPhone 3GS 这两代的屏幕尺寸和分辨率与初代 iPhone 完全相同，即 320px × 480px 的 3.5 寸屏幕，PPI 为 163。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/05e7363e4b3284adaf362e20ef9519ac.png"></p>
<p>2010 年具有全新硬件设计的 iPhone 4 发布，其屏幕分辨率升级为 640px × 960px，是前几代 iPhone 的两倍，屏幕尺寸仍然保持 3.5 英寸，PPI 达到了 326。在如此高的像素密度下，人眼已经几乎看不到屏幕上的像素点，因此 Apple 称之为「Retina/视网膜屏幕」。2011 年发布的 iPhone 4s 与前一代的屏幕分辨率和尺寸保持相同。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dad1c8f937867e3baf8d8b4ae98c7d0a.png"></p>
<p>至此 iPhone 的屏幕分辨率由一种变化到两种，在同样大小的 3.5 寸手机屏幕上，更高的分辨率不是为了显示更多的内容，而是为了让屏幕上的内容更加清晰。Retina 屏幕在渲染图像时，每四个像素成为一组，输出原来屏幕的一个像素显示的大小区域内的图像，以此提供了更高的图像精细度，下面的对比图可以直观地看出这种变化，右边的图片明显比左边的图片更加清晰锐利。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4e1dcef81527c06331ee2a52e30959ab.png"></p>
<p>如果一个 app 还没有适配新的 Retina 屏幕分辨率，在 Retina 屏幕上显示就会显得很模糊。</p>
<p>既然存在两种不同的分辨率，在 app 设计上就需要针对它们提供不同尺寸的设计图，比如下面的这个照相机的图片，在非 Retina 屏幕上它的高度是 44 像素，而在 Retina 屏幕上的高度就变成了88 像素，是非 Retina 屏幕上的两倍。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2b05135b23e0e6ae1d8b59dc91ee7787.png"></p>
<p>但我们知道，无论是不是 Retina 屏幕，这个照相机的图片在 3.5 寸屏幕上的实际显示大小是相同的，而如果用像素去表示的话，它们的数字却是不同的，这会带来很多沟通和操作成本，需要一种更好的方法去表示这个照相机图片的尺寸，「Point 点」的概念应运而生。</p>
<h2 id="脱离像素密度：Point-点的诞生"><a href="#脱离像素密度：Point-点的诞生" class="headerlink" title="脱离像素密度：Point 点的诞生"></a>脱离像素密度：Point 点的诞生</h2><p>Point 点（可简写为 pt）是专门为 Apple 操作系统设计的一个单位，它与屏幕上的像素密度无关，只与屏幕上的内容多少有关。</p>
<p>在第一代 iPhone 到 iPhone 3GS 的非 Retina 屏幕上，一个点就等于一像素，可以表示为 @1x；而在 iPhone 4 到 iPhone 4s 的 Retina 屏幕上，一个点等于两个像素，可以表示为 @2x。而日后发布的一些设备（如 iPhone 6 Plus、iPhone X）还会出现一个点等于三个像素的情况，可以表示为 @3x，这种 @1x、@2x、@3x 可以称之为「比例因子」。</p>
<p>从下面的图示可以看出，在物理尺寸相同时，从 @1x 到 @3x 图像清晰度依次递增。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1d74670901daeefeca41452c3f633ae3.png"></p>
<p>回到上一部分提到的照相机的图片，它的高度就可以直接统一表示成 44pt，不再需要提及是什么设备、什么样的屏幕，这样极大地减少了沟通成本，剔除了设计时无关的干扰因素。设计师在进行设计时可以直接按照 44pt 的高度进行设计，设计好的图像对应导出「<a href="mailto:&#x63;&#x61;&#x6d;&#101;&#114;&#97;&#64;&#x31;&#120;&#46;&#x70;&#110;&#x67;">&#x63;&#x61;&#x6d;&#101;&#114;&#97;&#64;&#x31;&#120;&#46;&#x70;&#110;&#x67;</a>」和「<a href="mailto:&#x63;&#x61;&#109;&#x65;&#x72;&#97;&#64;&#x32;&#x78;&#x2e;&#112;&#110;&#103;">&#x63;&#x61;&#109;&#x65;&#x72;&#97;&#64;&#x32;&#x78;&#x2e;&#112;&#110;&#103;</a>」两张图片，非 Retina 屏幕的 iPhone 在显示时会自动调用第一张图片，Retina 屏幕的 iPhone 在显示时会自动调用第二张图片。</p>
<p>用与像素密度无关的单位「point 点」来表示设计内容的尺寸的优势在日后 iPhone 的屏幕尺寸变得更加复杂之后会更加凸显。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/414393edef51cdfab6b1bcebad5789b7.png"></p>
<p>进一步，第一代 iPhone 到 iPhone 3GS 的屏幕分辨率可以表示为 320pt × 480pt @1x，iPhone 4、iPhone 4s 的屏幕分辨率可以表示为 320pt × 480pt @2x。而使用「point 点」这个单位表示的分辨率我们可以称之为「逻辑分辨率」，而使用「px 像素」这个单位表示的分辨率我们可以称之为「渲染分辨率」。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6d261977c5ddb566e9c17b00ba06d1f2.png"></p>
<p>通过「逻辑分辨率」我们可以比较屏幕上显示内容的多少，前五代 iPhone 的逻辑分辨率相同，所以显示内容的数量没有差别；通过「渲染分辨率」以及屏幕尺寸我们可以计算出 PPI，进一步比较屏幕的清晰度，iPhone 4、iPhone 4s 相比前几代 iPhone 的屏幕尺寸相同，但渲染分辨率更高，PPI 更高，所以屏幕更加清晰锐利。</p>
<p>不只 Apple 的操作系统中有 point 这样的与像素密度无关的单位，在其他平台上为了设计和开发方便，也同样存在类似的表示方法，比如 Android 平台上的单位「dp」，想要了解更多可以查看 Android 设计规范。</p>
<h1 id="iPhone-非全面屏时代：屏幕尺寸渐大渐多"><a href="#iPhone-非全面屏时代：屏幕尺寸渐大渐多" class="headerlink" title="iPhone 非全面屏时代：屏幕尺寸渐大渐多"></a>iPhone 非全面屏时代：屏幕尺寸渐大渐多</h1><h2 id="4-寸、4-7-寸、5-5-寸全面开花"><a href="#4-寸、4-7-寸、5-5-寸全面开花" class="headerlink" title="4 寸、4.7 寸、5.5 寸全面开花"></a>4 寸、4.7 寸、5.5 寸全面开花</h2><p>2012 年 Apple 发布了配备 4 寸屏幕的 iPhone 5，这是历史上 iPhone 屏幕尺寸的第一次改变，屏幕的分辨率为 640px x 1136 px，PPI 仍然为 326，也即相比 iPhone 4s 屏幕清晰度没有变化，其比例因子仍然为 @2x，其逻辑分辨率为 320pt × 568pt 。iPhone 5 搭载的 iOS 6 系统是 iOS 系统拟物化设计的最后一个版本，也是最成熟的一个版本</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/844d6c067dab30dd6fea4bceb3e67936.png"></p>
<p>仔细观察上面的数字我们可以发现，相比 iPhone 4s，iPhone 5 在横向上的内容宽度与前一代保持一致，但纵向上增多了 88pt，也即在纵向上可以显示更多的内容了。</p>
<p>如果一个 app 没有适配新的 iPhone 5，它将会在 iPhone 5 上以 iPhone 4s 的大小样式显示，也即上下会各留出 44pt 的黑边。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/20f2ed2850020a7ff388de2201717c98.png"></p>
<p>这种通过屏幕逻辑分辨率「横向不变、纵向变长」来增长屏幕尺寸的方式是 iPhone 屏幕进化的重要方式之一【解读：逻辑分辨率由4代的320x480pt@2x变为320x568pt@2x】，在日后还会多次看到，同时由于这种变化导致的 app 上下存在黑边的适配问题也同样会多次出现。</p>
<p>2013 年 Apple 发布了相比 iPhone 5 屏幕没有发生变化的 iPhone 5s 和 iPhone 5c，它们的屏幕逻辑分辨率仍然为 320pt × 568pt @2x。同年 Apple 推出了 iOS 7，从此设计风格由拟物化风格转向扁平化风格。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/da3b63c9a0ba6ba322ec154c5e4782e9.png"></p>
<p>由于屏幕的逻辑分辨率没有发生变化，app 就不需要为新机型的屏幕进行适配。凡是可以运行在 iPhone 5 上的 app 都可以在 iPhone 5s、iPhone 5c 上正常显示。</p>
<p>2014 年 iPhone 6 和 iPhone 6 Plus 同时发布，iPhone 的屏幕尺寸再次发生重大变化，根据不同人群的使用需求和偏好，由之前的一种主流尺寸衍变成了一大一小两种尺寸。</p>
<p>小屏旗舰 iPhone 6 采用 4.7 寸屏幕，屏幕逻辑分辨率为 375pt × 667pt，比例因子为 @2x，PPI 为 326；大屏旗舰 iPhone 6 Plus 采用 5.5 寸屏幕，屏幕逻辑分辨率为 414pt × 736pt，比例因子首次采用 @3x【解读：说明UI出图时需要做414x736px的3倍像素图】，PPI 为 401。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cfaae7efa08555fe39ae05fe36282b31.png"></p>
<p>这次的 iPhone 6 Plus 有一点比较特殊的地方，其渲染分辨率为 1242px × 2208px，但其设备真实的屏幕物理分辨率只有 1080px × 1920px，也即处理器渲染的图像分辨率比屏幕自身物理分辨率更高，在实际显示时相当于将渲染的图像缩小了 1.15 倍。图像在屏幕上显示时如果能做到像素一对一显示效果才能最完美，但 Apple 在此机型上作出了妥协，究其原因可能是因为当时 1080p 的屏幕的广泛使用可以削减手机成本、加快出货日期，同时也可以有更好的续航能力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2020/09/13.png"></p>
<p>这是历史上 iPhone 屏幕尺寸的第二次重大变化，但与之前的 4 寸 iPhone 5s 仔细对比观察，你会发现新的 4.7 寸和 5.5 寸的屏幕与以前的 4 寸屏幕宽高比例是相同的，所以可以理解成 4 寸的屏幕分别「等比放大」了约 1.17 倍和 1.29 倍，变成了现在的 4.7 寸和 5.5 寸屏幕。屏幕逻辑分辨率在宽度和高度上的增加，可以让屏幕上一次性展示更多内容，减少用户滚动屏幕的频率。</p>
<p>至此，从屏幕逻辑分辨率的宽度来看，分化出了三种：320pt、375pt、414pt。在 app 设计时一般以 375pt 宽度为基准，其他宽度 app 的设计进行针对性处理。实际上，这三种宽度的逻辑分辨率一直到 2019 年都没有再发生变化。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ea67d163ae73d8e5a86f50afaf658158.png"></p>
<p>如果没有适配新机型的 app 在显示时，由于和上代 iPhone 具有相同的屏幕比例，所以会直接将 iPhone 5s 的 app 放大显示到屏幕上。用户的直观感受就是虽然屏幕变大了，但仅仅是将原有的内容放大了，而不是在屏幕上可以一次性展示更多内容。而且因为不是像素一对一显示，屏幕上的内容看上去会不够清晰锐利。</p>
<p>这种通过将屏幕逻辑分辨率「等比放大」来增长屏幕尺寸的方式也同样是 iPhone 屏幕进化的重要方式之一，在日后也会多次看到，同时由于这种变化导致的 app 被整体放大显示的适配问题也同样会多次出现。</p>
<p>2015 年到 2017 年 Apple 相继发布了 iPhone 6s 和 iPhone 6s Plus、iPhone 7 和 iPhone 7 Plus、iPhone 8 和 iPhone 8 Plus，它们的屏幕参数与 iPhone 6、iPhone 6 Plus 保持了一致。4.7 寸和 5.5 寸屏幕的 iPhone 也在四年间迅速普及。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/94762a12674094e8be6e06e17b73a230.png"></p>
<p>至此，iPhone 非全面屏时代可以基本宣告结束了。</p>
<h2 id="屏幕不断被放大的产物：放大显示功能"><a href="#屏幕不断被放大的产物：放大显示功能" class="headerlink" title="屏幕不断被放大的产物：放大显示功能"></a>屏幕不断被放大的产物：放大显示功能</h2><p>如前文所讲，iPhone 5s 的 4 寸屏幕、iPhone 6 的 4.7 寸屏幕、iPhone 6 Plus 的 5.5 寸屏幕的宽高比例是相同的，它们是依次放大的。于是从 iPhone 6、iPhone 6 Plus 开始，iOS 新增了一个这些机型独有的功能——「放大显示」，简单来看它将屏幕上的内容放大显示以便于存在视力障碍的用户更轻松使用 iPhone，当然你也可以根据自己的偏好选择使用放大显示模式。</p>
<p>将屏幕上的内容，特别是包含了众多第三方 app 的内容进行整体放大而不让布局错乱并不是一件简单的事，为了减少不必要的设计和开发成本，放大显示功能巧妙地利用了已有的屏幕逻辑分辨率。具体来说，放大显示的实质是将高一级的逻辑分辨率降级到同一比例的低一级的逻辑分辨率，比如当放大显示模式开启时， 5.5 寸屏幕可以使用 4.7 寸屏幕的逻辑分辨率来显示内容，4.7 寸屏幕可以使用 4 寸屏幕的逻辑分辨率来显示内容。将低一级的逻辑分辨率放到更大的屏幕上展示，自然会有放大效果，适配了大屏幕 iPhone 的 app 自然也适配了更小屏幕的 iPhone，这样就可以完全没有额外的设计和开发成本。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/036e44a373dc419b1e79ae9392c12cec.png"></p>
<h2 id="适配不同尺寸屏幕的布局工具：Auto-Layout"><a href="#适配不同尺寸屏幕的布局工具：Auto-Layout" class="headerlink" title="适配不同尺寸屏幕的布局工具：Auto Layout"></a>适配不同尺寸屏幕的布局工具：Auto Layout</h2><p>随着 iPhone 机型越来越多，屏幕尺寸越来越多，屏幕的逻辑分辨率也越来越多。设计师和开发者在设计和开发 app 时需要对多种屏幕布局进行适配调整，才能让 app 在每一台 iPhone 上完美运行。</p>
<p>iPhone 上的 app 中的内容包含文字、图片、按钮、输入框、导航栏等各种各样的形式，我们可以把这些不同形式的元素统称为「View 视图」。要确定 iPhone app 中每一个 view 在屏幕上的布局，可以想到的最直观的方式就是确定这每一个 view 的摆放位置和尺寸，摆放位置可以通过在屏幕上建立坐标系后利用横纵坐标（x, y）来表示，尺寸可以通过描述一个 view 的宽度和高度来表示。这种确定了每一个 view 的位置和尺寸的布局方式不会受内部或者外部因素所影响，可以称之为「绝对布局」。</p>
<p>例如下图中的这个例子，在 iPhone 8 上有一个 app，app 的界面中展示有四个不同颜色的方块。按照绝对布局的方法来确定四个方块的位置和尺寸：</p>
<p>红色方块的位置坐标是（138，32），宽度为 100，高度为 100；</p>
<p>黄色方块的位置坐标是（138，156），宽度为 100，高度为 100；</p>
<p>绿色方块的位置坐标是（138，280），宽度为 100，高度为 100；</p>
<p>蓝色方块的位置坐标是（138，404），宽度为 100，高度为 100。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/76bafef1b5b68f6232cc83de98d40f63.png"></p>
<p>当把上面确定的每个方块的绝对布局参数放到 iPhone 8 Plus 的屏幕上显示时，我们就会发现四个方块在屏幕上显示的位置有些奇怪。仔细思考下，在 iPhone 8 的屏幕上四个方块的位置坐标之所以可以确定下来，是因为我们想要这四个方块在屏幕水平方向上是居中对齐的。当移动到 iPhone 8 Plus 的屏幕上，屏幕的逻辑分辨率发生了变化，屏幕变宽了，如果还是按照之前的位置参数放置四个方块，其自然不会在屏幕水平方向上处于居中对齐的位置了。</p>
<p>要想要 iPhone 8 Plus 屏幕上的四个方块在水平方向上也能居中对齐显示，那四个方块的位置坐标就需要相对应发生变化。这种「分而治之」的处理方式固然可以面面俱到，但其耗费的成本也是巨大的，在屏幕尺寸不断变复杂的时间点上，需要一套方法去整合不同屏幕上的 app 布局，这套方法就是诞生于 iOS 6 并逐渐发展成熟的「Auto Layout 自动布局」方案。</p>
<p>Auto Layout 是一种相对布局的方案，它不要求直接给出每一个 view 的位置和尺寸信息，而是通过建立 view 之间的约束关系（constraint），动态计算出在不同情景时每个 view 的具体位置和尺寸。</p>
<p>来看下图中的这个例子，蓝色方块命名为「BlueView」，红色方块命名为「RedView」，它们之间的距离是 8，通过图中所示的等式就可以表示出这两个 view 之间的约束关系，用自然语言来描述就是：</p>
<blockquote>
<p>红色方块的左端 = 1.0 × 蓝色方块的右端 + 8</p>
</blockquote>
<p>这里特别提及的一点是，在描述蓝色方块右端和红色方块的左端之所以不直接使用「right 右」和「left 左」这两个单词，而是使用了「trailing 尾」和「leading 头」这两个单词，是因为这样的描述可以更好地兼顾从右向左书写的语言（如阿拉伯语）的 app 的适配，利于 app 实现国际化。</p>
<p>通过两个方块之间相对的约束关系，不论在任何尺寸的屏幕上，这两个方块之间的距离都是 8，不会因为两个方块各自的位置和尺寸而变动。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2b9751f388db590ec1befed63f47d202.png"></p>
<p>回到上面绝对布局中所举的例子，现在用相对布局的方法来思考下四个不同颜色的方块该如何布局，按照 Auto Layout 的思想，可以确定界面上 view 的几个约束关系：</p>
<p>红色方块的宽和高 = 黄色方块的宽和高 = 绿色方块的宽和高 = 蓝色方块的宽和高 = 100；</p>
<p>红色方块的顶部 = 屏幕顶部 + 32；</p>
<p>纵向上不同颜色方块之间的距离 = 24</p>
<p>红色方块的 X 轴中心位置 = 黄色方块的 X 轴中心位置 = 绿色方块的 X 轴中心位置 = 蓝色方块的 X 轴中心位置 = 屏幕的 X 轴中心位置。</p>
<p>通过上面确定的四个约束关系，四个方块的尺寸固定了下来，但在屏幕上的位置并没有完全固定，会相对于屏幕尺寸发生动态变化。这样当整个界面显示在 iPhone 8 Plus 或者其他尺寸的屏幕上时，四个方块就能始终在屏幕水平方向上居中对齐。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/19e306027a0235f4ab16acc78b1a6a44.png"></p>
<p>通过 Auto Layout 这个武器，利用相对布局的思想，设计师和开发者确定好不同 view 之间的约束关系，就能让整个界面在不同尺寸的设备上都能正确地显示，不再需要一个设备一套设计方案，这样的设计也被称为「适应性布局设计」。</p>
<p>以上示例只是 Auto Layout 的一个简单示意，在实际情况中，app 界面上包含各种 view，约束关系自然更加复杂，Auto Layout 的作用也会更加明显。且从更大范围来看，不只屏幕尺寸变化，Auto Layout 的这种适应性布局设计方案还可以适应各种外部和内部变化：</p>
<p>外部变化：</p>
<p>不同屏幕尺寸；</p>
<p>不同 Size Class（下一部分会讲到）；</p>
<p>旋转设备改变使用方向；</p>
<p>iPad 上进入或退出 Slide Over、Split View 模式；</p>
<p>来电和录音时状态栏变高。</p>
<p>内部变化：</p>
<p>App 自身改变导致的内容变化；</p>
<p>App 支持国际化；</p>
<p>App 支持「Dynamic Type 动态类型」。</p>
<p>想要了解更多可参考 Apple 提供给开发者的「Auto Layout Guide」。</p>
<h2 id="iOS-、iPadOS-生态下的重要武器：Size-Class"><a href="#iOS-、iPadOS-生态下的重要武器：Size-Class" class="headerlink" title="iOS 、iPadOS 生态下的重要武器：Size Class"></a>iOS 、iPadOS 生态下的重要武器：Size Class</h2><p>通过 Auto Layout，不同屏幕尺寸的设备都可以用一套设计方案来布局内容，但这并不代表不同尺寸的屏幕上显示的内容布局都应该是一样的，比如同一个 app 在 iPhone 和 iPad 上的布局一般是不一样的，更何况屏幕在使用时还需要区分横竖和竖屏的使用场景，app 横屏和竖屏显示的内容布局也会不一样。从 iOS 8 开始推出的「Size Class 尺寸级别」就是为了解决这个问题。</p>
<p>Size Class 根据 app 的实际使用场景定义了不同尺寸的屏幕、不同方向的屏幕在「width 宽度」和「height 高度」上的尺寸级别，较短的宽度/高度定义其级别为「compact」，意为紧凑，可放置较少的内容；较长的宽度/高度定义其级别为「regular」，意为普通，可放置较多的内容。宽度和高度与这两个级别相互组合就形成了四种尺寸级别。特别注意的是，同一个尺寸的设备，横屏和竖屏的尺寸级别并不一定是完全相反的。</p>
<p>如下图，iPhone 8 在竖屏时的 Size Class 是「compact width，regular height」，在横屏时是「compact width，compact height」；iPhone 8 Plus 在竖屏时是「compact width，regular height」，在横屏时是「regular width，compact height」，与 iPhone 8 并不相同，因为 iPhone 8 Plus 屏幕尺寸更大。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ab377be71757267faaa76be2bf38e165.png"></p>
<p>不同屏幕尺寸、不同屏幕方向的 iPad 也同样有 Size Class 的定义，如 iPad Pro 11 寸在竖屏时是「regular width，regular height」，在横屏时也是「regular width，regular height」。特别的，从 iOS 9 开始，iPad 上的 app 支持以 Slide Over 侧拉或者 Split View 分屏浏览的形式显示，在这些使用场景中，它们也被定义了 Size Class。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/594c47e5146cb19c354b016b8b42de65.png"></p>
<p>在不同尺寸的设备上让 app 都大放异彩：尺寸级别和核心要素 Size Classes and Core Components</p>
<p>有了 Size Class，设计师和开发者在设计和开发 app 时就不需要根据繁多的屏幕尺寸和屏幕使用方向等多个内外因素来确定 app 内容布局，新的屏幕尺寸出现时也无需再单独适配。来看几个具体的 Size Class 应用实例。</p>
<p>第一个例子，2018 年 6.5 寸屏幕的 iPhone Xs Max 发布前，有人在 iOS 12 的 Beta 版本中发现当让 iPhone 模拟器运行在传闻中的 iPhone Xs Max 分辨率之下时，部分系统自带 app 在横屏时的内容布局与 5.8 寸的 iPhone X 不一样，比如「信息」app 横屏时，5.8 寸屏幕只能显示某个联系人的短信内容，但 6.5 寸屏幕就可以分左右两边显示短信列表和具体的短信内容。据此进一步印证了 6.5 寸的 iPhone Xs Max 的存在。</p>
<p>同一个 app 在不同屏幕尺寸的屏幕上显示的内容布局不同，究其原因，如下图所示，在屏幕宽度上 5.8 寸屏幕的 Size Class 是「compact width」，6.5 寸屏幕的 Size Class 是「regular width」，Size Class 不同，所以它们的 app 内容显示布局不一样。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/00bfbae3024410e4aa3931f647ae2eb8.png"></p>
<p>第二个例子，再次回到在 Auto Layout 中提到的 app，基于已经确定的四个方块的约束关系，当在 iPhone 横屏使用时，我们会发现由于四个方块是竖直排列的，所以不能在横屏时的屏幕上显示完全，左右两侧还有较大的空间被浪费掉了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/57b719e53d9a7354546059a863db5a43.png"></p>
<p>当利用 Size Class 对不同情况下的内容进行布局，iPhone 竖屏也即 Size Class 为「compact width，regular height」时，四个方块在屏幕上水平居中对齐，纵向排列；iPhone 横屏也即 Size Class 为「any width，compact height」（any 包括 compact 和 regular 两种情况）时，四个方块在屏幕上竖直居中对齐，横向排列，这时的布局约束关系为：</p>
<p>红色方块的宽和高 = 黄色方块的宽和高 = 绿色方块的宽和高 = 蓝色方块的宽和高 = 100；</p>
<p>红色方块的左侧 = 屏幕左侧 + 110；</p>
<p>横向上不同颜色方块之间的距离 = 24</p>
<p>红色方块的 Y 轴中心位置 = 黄色方块的 Y 轴中心位置 = 绿色方块的 Y 轴中心位置 = 蓝色方块的 Y 轴中心位置 = 屏幕的 Y 轴中心位置。</p>
<p>进一步，当 app 运行在 iPad 上，也即 Size Class 为「regular width，regular height」时，四个组成一个方块组，分两行排列，整个方块组在屏幕上竖直居中对齐，这时的布局约束关系为：</p>
<p>红色方块的宽和高 = 黄色方块的宽和高 = 绿色方块的宽和高 = 蓝色方块的宽和高 = 100；</p>
<p>整个方块组的左侧 = 屏幕左侧 + 485；</p>
<p>纵向、横向上不同颜色方块之间的距离 = 24</p>
<p>整个方块组的 Y 轴中心位置 = 屏幕的 Y 轴中心位置。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2cc3f517afcc08b18795238687032bfb.png"></p>
<p>这样同样的内容在 iPhone 横屏、竖屏和 iPad 的不同设备和使用场景上布局不同，把上面三种情况的内容布局的约束关系总结概括一下：</p>
<p>共用约束关系：</p>
<p>红色方块的宽和高 = 黄色方块的宽和高 = 绿色方块的宽和高 = 蓝色方块的宽和高 = 100。</p>
<p>Size Class 为「compact width，regular height」，也即 iPhone 竖屏时：</p>
<p>红色方块的顶部 = 屏幕顶部 + 32；</p>
<p>不同颜色方块之间的距离 = 24</p>
<p>红色方块的 X 轴中心位置 = 黄色方块的 X 轴中心位置 = 绿色方块的 X 轴中心位置 = 蓝色方块的 X 轴中心位置 = 屏幕的 X 轴中心位置。</p>
<p>Size Class 为「any width，compact height」，也即 iPhone 横屏时：</p>
<p>红色方块的左侧 = 屏幕左侧 + 110；</p>
<p>横向上不同颜色方块之间的距离 = 24</p>
<p>红色方块的 Y 轴中心位置 = 黄色方块的 Y 轴中心位置 = 绿色方块的 Y 轴中心位置 = 蓝色方块的 Y 轴中心位置 = 屏幕的 Y 轴中心位置。</p>
<p>Size Class 为「regular width，regular height」，也即 iPad 横竖屏时：</p>
<p>整个方块组的左侧 = 屏幕左侧 + 485；</p>
<p>纵向、横向上不同颜色方块之间的距离 = 24</p>
<p>整个方块组的 Y 轴中心位置 = 屏幕的 Y 轴中心位置。</p>
<p>第三个例子，随着 iPad 的定位在逐渐向电脑靠拢，人们对 iPad 上的 app 生产力要求越来越高，需要利用好 iPad 这块大屏幕的空间、更容易地在 app 内进行导航，所以在 iPadOS 14 中，iPad app 增加了侧边栏这个导航样式，用户可以在侧边栏上更容易找到 app 不同层级的内容入口。但由于侧边栏占据了较大的显示面积，所以侧边栏不适合内容显示区域较小的情景。</p>
<p>例如下图中的「音乐」app，在 iPad Pro 11 寸上全屏展示时，此时 Size Class 为「regular width，regular height」，app 使用侧边栏作为导航方式；当「音乐」app 以 Slide Over 形式运行时，此时 Size Class 为「compact width，regular height」，横向上显示空间有限，所以 app 改用以前的标签栏作为导航方式。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/16924797375e322cffc8eb36b8374678.png"></p>
<p>有了 Size Class 这个武器，在 iPhone 和 iPad 上进行 app 的自适应布局设计变得更加方便统一。但目前的 Size Class 并不是完美的，因为 iPad 横屏和竖屏时的 Size Class 在最初设计时都被定义为了「regular width，regular height」，所以当想要针对 iPad 横屏和竖屏有不同的内容布局方案时，Size Class 并不能满足，还需要依靠其他判断条件。随着 iPad app 的地位的提高，也许以后的 Size Class 会进化出更多的级别以应对上述情况。</p>
<h1 id="iPhone-转向全面屏时代：不规则屏幕的出现"><a href="#iPhone-转向全面屏时代：不规则屏幕的出现" class="headerlink" title="iPhone 转向全面屏时代：不规则屏幕的出现"></a>iPhone 转向全面屏时代：不规则屏幕的出现</h1><h2 id="全面屏的-5-8-寸、6-1-寸、6-5-寸"><a href="#全面屏的-5-8-寸、6-1-寸、6-5-寸" class="headerlink" title="全面屏的 5.8 寸、6.1 寸、6.5 寸"></a>全面屏的 5.8 寸、6.1 寸、6.5 寸</h2><p>2017 年 iPhone 转向全面屏时代，搭载 iOS 11、配有 5.8 寸屏幕的 iPhone X 发布，屏幕分辨率为 1125px × 2436px，PPI 达到 458，屏幕尺寸和屏幕分辨率都发生了重大变化，而且屏幕由以前的 LCD 屏改为了 OLED 屏。由于从非全面屏到全面屏的进化，iPhone 去除了 Home 键，由软件层面的 Home Indicator 代替；去除了 Touch ID，由刘海内的Face ID 代替；屏幕的四角也变成了圆角，整块屏幕不再是规则的矩形。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1d6466357685c9a1893724554ecd20ab.png"></p>
<p>5.8 寸的 iPhone X 的逻辑分辨率为 375pt × 812pt，比例因子为 @3x。逻辑分辨率在横向上是与 4.7 寸的 iPhone 8 的屏幕相同的，在纵向上比 iPhone 8 多了 145 pt，纵向上可以显示更多内容了。所以 iPhone X 的逻辑分辨率实际上是对 iPhone 8 的逻辑分辨率「横向不变，纵向变长」得来的，这与从 iPhone 4s 到 iPhone 5 的屏幕进化方式相同。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/32c97b2e007d333a4302e2f5cf0dc0b1.png"></p>
<p>屏幕变长，未适配新机型的 app 将会在 iPhone X 上以 iPhone 8 的大小显示，上下留有黑边。同时，由于刘海和 Home Indicator 的加入、屏幕四角改为圆角，在全面屏 iPhone 上设计开发 app 还需要综合考虑这些改变，具体可参考文章：</p>
<p>Designing For iPhone X —— iPhone 上有了刘海，设计和开发到底该咋整? - 向远公园 | Step Park</p>
<p>2018 年 5.8 寸的 iPhone Xs 发布，与 iPhone X 的屏幕保持一致，同时全面屏 iPhone 家族新增了 6.5 寸的 iPhone Xs Max，屏幕分辨率为 1242px × 2688px，PPI 为 458。2019 年 5.8 寸的 iPhone 11 Pro 和 6.5 寸的 iPhone 11 Pro Max 发布，与上一代的屏幕保持一致。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cc6aa6dca4675e84f8ff2c988c167e54.png"></p>
<p>2018 年 Apple 还同时发布了 6.1 寸屏幕的 iPhone Xʀ，屏幕分辨率为 828px × 1792px，PPI 为 326；2019 年 iPhone Xʀ 的继承者 iPhone 11 发布，与上一代的屏幕保持一致。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/78a0fdb667f069de12e05d3ef433b1f0.png"></p>
<p>2018 年和 2019 年全面屏 iPhone 家族新增的 6.1 寸屏幕和 6.5 寸屏幕，它们虽然屏幕尺寸不同，但逻辑分辨率相同，都为 414pt × 896pt，不同的是 6.1 寸的比例因子为 @2x，6.5 寸的比例因子为 @3x，所以它们显示的内容数量是相同的，但 6.5 寸的屏幕清晰度更高。</p>
<p>这两个机型的逻辑分辨率在横向上是与 5.5 寸的 iPhone 8 Plus 相同的，都为 414pt，在纵向上比 iPhone 8 Plus 多了 160pt，所以也是采用「横向不变，纵向变长」的逻辑进化而来。5.8 寸的全面屏 iPhone 是由 4.7 寸的非全面屏 iPhone 进化而来，6.1 寸/6.5 寸的全面屏 iPhone 是由 5.5 寸的非全面屏 iPhone 进化而来，同时 4 寸、4.7 寸、5.5 寸的非全面屏 iPhone 的宽高比例是相同的，5.8 寸、6.1 寸、6.5 寸的全面屏 iPhone 的宽高比例也是相同的，6.1 寸、6.5 寸也可以看做是由 5.8 寸屏幕「等比放大」而来。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e36f8e64ff1981d5501d42aaa979a8a2.png"></p>
<p>如果 app 没有适配新的机型，将会在 6.1 寸和 6.5 寸的屏幕上把 iPhone X 的 app放大到全屏显示，清晰度不如已经适配的 app；如果 app 连 iPhone X 都没有适配，则会以 iPhone 8 Plus 的大小显示，上下留有黑边。有关于更大屏幕的全面屏 iPhone 适配和设计，可参考我的文章：</p>
<p>Designing For iPhone Xs、iPhone Xs Max、iPhone Xʀ — 比大还大，更大的刘海屏 iPhone app 如何适配 - 向远公园 | Step Park</p>
<p>不止是 iPhone，iPad Pro 系列也在 2018 年的产品迭代中提高了屏占比例，引入了 Face ID 和 Home Indicator，使软件层面的操作逻辑与 iPhone 保持一致，iPad Pro 的屏幕进化也发生了与 iPhone 屏幕进化类似的过程，并且由于 iPad app 支持 Slide Over、Split View 显示模式，对 app 的适配和设计提出了更高的要求，有关于这一部分可参考我的文章：</p>
<p>Designing For New iPad Pro and Apple Pencil — 适配没有刘海的 iPad Pro 与有刘海的 iPhone Xs 有什么不同? - 向远公园 | Step Park</p>
<p>为了推动 app 生态的进化，Apple 在之前也向开发者发出通知，2020 年 6 月 30 日之后，所有要更新或新上架的 iPhone app 必须支持所有的 iPhone 屏幕尺寸，iPad app 必须支持所有的 iPad 屏幕尺寸。同时强烈鼓励开发者对 iPad app 支持多窗口、多任务功能（侧拉、分屏浏览、画中画）。</p>
<h2 id="适应屏幕新变化：Safe-Area"><a href="#适应屏幕新变化：Safe-Area" class="headerlink" title="适应屏幕新变化：Safe Area"></a>适应屏幕新变化：Safe Area</h2><p>在非全面屏 iPhone 的时代，从 iOS 7 开始，为了让 app 在设计和开发时更容易、更正确地进行布局，Apple 引入了「Layout Guide 布局指导」的概念。简单来说，显示在 iPhone 上的 app 中不仅包括 app 本身要显示的内容，如文字、图片等，还包括一些让 app 更易用、更统一的系统控件，如状态栏、导航栏、标签栏、搜索栏、工具栏等。这些系统控件一般会在屏幕顶部或底部占据一定的区域，而除去这部分才是 app 真正显示内容的区域。</p>
<p>如下图所示，在 iPhone 8 上，屏幕顶部的状态栏、导航栏、搜索栏的区域称为「Top Layout Guide」，屏幕底部的标签栏的区域称为「Bottom Layout Guide」，app 内真正显示的内容应该在这两者之间进行布局。</p>
<p>由于屏幕是一个规则的矩形，无论是竖屏还是横屏，系统控件只会出现在屏幕顶部和底部，屏幕左右两侧是不受约束的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/13e3052ece237c47a2e83915cdfab0be.png"></p>
<p>进入全面屏时代，刘海的加入，屏幕四角由直角改为圆角使得屏幕不再是一块规则的矩形，同时软件层面 Home Indicator 变成了常驻系统控件，原先的 Top Layout Guide 和 Bottom Layout Guide 已经不能再适应新需求，从 iOS 11 开始进化成了「Safe Area 安全区域」。</p>
<p>如下图所示，Safe Area 是一块可供自定义内容展示的规则矩形。在竖屏时，由于顶部刘海和底部 Home Indicator 的存在，需要空出这两块区域；在横屏时，由于一侧有刘海，一侧没有，但为保证内容对称，所以左右两侧需空出等宽的区域，而屏幕底部也需要为 Home Indicator 空出一定的区域。进一步，当放置了系统控件之后，Safe Area 会在上面的基础上进一步缩小。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a1aa489ad9a32c69fe5e36c10253ff01.png"></p>
<p>在使用 Auto Layout 对界面上的 View 确定布局约束时，就可以直接利用上 Safe Area 以适应不同的使用场景。举一个简单的例子，下图中红色方块的其中一条布局约束就可以定义为：</p>
<p>Size Class 为「compact width，regular height」，也即 iPhone 竖屏时：</p>
<p>红色方块的顶部 = Safe Area 的顶部 + 32；</p>
<p>Size Class 为「any width，compact height」，也即 iPhone 横屏时：</p>
<p>红色方块的头部 = Safe Area 的头部 + 110。</p>
<p>这样利用 Safe Area 确定的布局方案会根据不同机型的 Safe Area 的不同进行自动调整，不再需要为每个机型单独适配，界面上的元素也就不会出现被遮挡的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2a3f47e0337bd5fb24fb6664520aad33.png"></p>
<p>总的来看，有了 Safe Area 的定义，app 在设计和布局自定义内容时应该处于 Safe Area 之内，避免与屏幕的圆角、刘海、Home Indicator 发生重叠或裁切，但对于可滚动的内容以及控件/页面的背景颜色，可以让其延伸到屏幕边缘，以形成连续显示的效果。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a6a90cc07de3f741c995efc4ce4bff50.png"></p>
<p>可以说全面屏 iPhone 的诞生催生了 Safe Area，让 Layout Guide 更加完善，为众多第三方 app 在设计和开发时提供了内容布局指导，以让它们在整个 iOS 系统中保持一致性。</p>
<h2 id="OLED-屏的影响：支持深色模式"><a href="#OLED-屏的影响：支持深色模式" class="headerlink" title="OLED 屏的影响：支持深色模式"></a>OLED 屏的影响：支持深色模式</h2><p>iPhone 从非全面屏向全面屏进化的过程中，部分型号的屏幕也从 LCD 屏幕进化到了 OLED 屏幕，同时伴随 iPhone 的屏幕尺寸越来越大，耗电自然也会增多，续航变成了用户日常使用手机的重要关注点。</p>
<p>基于 OLED 材质屏幕的显示特点，当屏幕显示黑色的面积越大越省电，这也是从 iOS 13 开始 app 在系统级别上支持了深色模式的一个原因。适配了深色模式的 app 可以让用户根据需要和偏好选择使用浅色模式还是深色模式，深色模式可以让用户更加聚焦于内容本身，更加适合在灯光条件较暗的环境下使用手机。但有一点特别注意的是，深色模式不等于低对比度，因为开启了深色模式而使得 app 上的内容识别度和可读性下降，这不是一种正确的做法。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fa2efbd03d98e06cfd00d84c88163663.png"></p>
<h2 id="更长更大的屏幕下的交互变化"><a href="#更长更大的屏幕下的交互变化" class="headerlink" title="更长更大的屏幕下的交互变化"></a>更长更大的屏幕下的交互变化</h2><p>随着 iPhone 的屏幕尺寸变得越来越多，屏幕变得更长更大，iOS 系统的许多交互也在不断发生进化，在此举两个例子。</p>
<h3 id="新的大标题导航栏"><a href="#新的大标题导航栏" class="headerlink" title="新的大标题导航栏"></a>新的大标题导航栏</h3><p>从 iOS 11 开始，为了让用户更加明确自己处于 app 的哪个位置，让 app 突出自己的核心模块，系统引入了一种新的导航栏样式：大标题导航栏，它比以前的导航栏样式更加醒目，在纵向上占据了更多的屏幕空间，这增强了刚进入这个页面的用户的空间感，而当用户滚动 app 的内容时，用户已经知道所处的位置，大标题导航栏又可以自动地缩小，以让此时的用户把注意力放在内容本身上。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4c97a0e7c2309f44ce084b667ff3bc73.png"></p>
<h3 id="新的菜单样式"><a href="#新的菜单样式" class="headerlink" title="新的菜单样式"></a>新的菜单样式</h3><p>在 iOS 14/iPadOS 14 中新增了一种菜单样式，当用户点击按钮时，新的菜单会直接显示在菜单旁边，而不再是使用以前的 Action Sheet（从屏幕底部弹出的菜单选项）样式，例如下图中的「提醒事项」app 。新的菜单样式可以让用户在较大的屏幕上更好地理解菜单选项和按钮之间的关系，同时可以不需要大幅度移动手指就可以完成操作。</p>
<p>值得注意的是，以前的 Action Sheet 样式也并不是不再使用，当执行破坏性操作（比如删除操作）时，仍然建议使用 Action Sheet 来让用户完成操作的二次确认，因为 Action Sheet 会吸引用户的注意力，只有将手指移动到屏幕才能做出选择，避免了误触的情况发生。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f4013a303e2eb7211013eee7bac00b54.png"></p>
<p>iPadOS 14 中也同样增加了这种菜单样式，这也与 macOS 中的弹出菜单交互逻辑保持一致，更有利于 iPad app 通过 Mac Catalyst 技术向 Mac 平台转移。</p>
<h2 id="全面屏的放大显示"><a href="#全面屏的放大显示" class="headerlink" title="全面屏的放大显示"></a>全面屏的放大显示</h2><p>前文提到，从 iPhone 6 开始，iOS 在部分机型中新增了「放大显示」功能，放大显示的实质是将高一级的逻辑分辨率降级到同一比例的低一级的逻辑分辨率。在全面屏 iPhone 中，6.1 寸、6.5 寸的 iPhone 具备放大显示的这个条件，所以这两种尺寸的 iPhone 在系统中同样可以开启放大显示模式；但 5.8 寸的 iPhone 不存在比它还要低一级的同一比例的逻辑分辨率，所以 5.8 寸的 iPhone X、iPhone Xs、iPhone 11 Pro 一直没有放大显示功能。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5101ac2d3b597253900701eded987c2d.png"></p>
<h2 id="展望未来-iPhone"><a href="#展望未来-iPhone" class="headerlink" title="展望未来 iPhone"></a>展望未来 iPhone</h2><p>根据目前媒体获得的消息，2020 年秋季将会有四款 iPhone 发布，旗舰系列包括 5.4 寸的 iPhone 12（非最终命名，下同）和 6.1 寸的 iPhone 12 Plus，超旗舰系列包括 6.1 寸的 iPhone 12 Pro 和 6.7 寸的 iPhone 12 Pro Max。</p>
<h3 id="旗舰-iPhone-12-会是什么样？"><a href="#旗舰-iPhone-12-会是什么样？" class="headerlink" title="旗舰 iPhone 12 会是什么样？"></a>旗舰 iPhone 12 会是什么样？</h3><p>本文开头提到，在 iOS 14 Beta 3 版本中有用户发现 5.8 寸的 iPhone 也有了放大显示这个功能，根据前文所讲的放大显示的存在条件，我们可以推测存在一款 iPhone 与 5.8 寸 iPhone 的屏幕是同一比例，且逻辑分辨率比 5.8 寸 iPhone 低一级。</p>
<p>同时还发现 Xcode 中的模拟器可以正常运行在 960px × 2079px 分辨率下，假设比例因子为 @3x，其屏幕逻辑分辨率就为 320pt × 693pt。</p>
<p>综上两个发现，传闻中的 5.4 寸 iPhone 的屏幕参数似乎已浮出水面。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6ecaf96c8b884ae2cf8c436d12abf0e9.png"></p>
<h3 id="5-4-寸-iPhone-12-由-4-寸-iPhone-SE-第一代进化而来"><a href="#5-4-寸-iPhone-12-由-4-寸-iPhone-SE-第一代进化而来" class="headerlink" title="5.4 寸 iPhone 12 由 4 寸 iPhone SE 第一代进化而来"></a>5.4 寸 iPhone 12 由 4 寸 iPhone SE 第一代进化而来</h3><p>小屏旗舰 iPhone 12 配备 5.4 寸屏幕，屏幕渲染分辨率为 960px × 2079px，PPI 约为 424，逻辑分辨率为 320pt × 693pt @3x。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9277e37cfca133fd477142a1fd0df996.png"></p>
<p>在本文最初成文时，我没有太多考虑 6.1 寸 iPhone 12 Plus 会是什么样，本以为相比上一代不会发生什么变化，毕竟它和 iPhone Xʀ、iPhone 11 具有相同的屏幕尺寸，但与读者讨论后我发现我忽略了一个细节—— iPhone 12 Plus 会改用 OLED 屏幕，而同样分辨率的 LCD 屏和 OLED 屏的清晰度观感是不一样的。</p>
<p>如下图，左边 LCD 屏幕的像素排列方式是 RGB，三个子像素点不论是大小还是个数都是相同的；右边 OLED 屏幕的像素排列方式是 Pentile，绿色像素点是红蓝像素点的 2 倍，而且单个红蓝像素点面积要比绿色像素点大。正是因为 OLED 屏幕上像素排列方式的特殊，在相同尺寸相同分辨率的条件下，LCD 屏幕会比 OLED 屏幕更清晰，特别是在红色和蓝色较多的情况下。所以为了达到与 LCD 屏幕相同的屏幕清晰度观感，只能提高 OLED 屏幕的分辨率。若 OLED 屏的 iPhone 12 Plus 保持与上一代一样的屏幕分辨率这肯定就说不过去了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2020/09/41.jpg"></p>
<p>所以猜测大屏旗舰 6.1 寸屏幕的 iPhone 12 Plus 会改用 375pt × 812pt @3x 的逻辑分辨率。</p>
<p>回到小屏旗舰 iPhone 12 上，可以看出 5.4 寸 iPhone 12 的逻辑分辨率的宽度与 4 寸的 iPhone SE 第一代是相同的，都是 320pt。5.4 寸的 iPhone 12 的屏幕变化实质也是「横向不变，纵向变长」，相比 iPhone SE 第一代，纵向上多了 125pt，当 app 没有适配新尺寸的 iPhone 时，上下会出现黑边。这样来看，5.4 寸的 iPhone 12 就是之前大家翘首以待的全面屏 iPhone SE。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/88425b53a7d4245701a71b8053593a67.png"></p>
<h3 id="屏幕显示的内容数量较少"><a href="#屏幕显示的内容数量较少" class="headerlink" title="屏幕显示的内容数量较少"></a>屏幕显示的内容数量较少</h3><p>屏幕的逻辑分辨率影响着屏幕上内容的数量，下图列举对比了目前三种宽度逻辑分辨率的 iPhone 显示同一内容时的实际情况，可以很明显地看出：</p>
<p>宽度 414pt 的 6.1 寸、6.5 iPhone 显示的内容最多，375pt 的 5.8 寸 iPhone 次之，320pt 的 5.4 寸 iPhone 最少；</p>
<p>图片显示区域，414pt 宽度的 iPhone 上可以看到第三张图片的 1/4，375pt 宽度的 iPhone 上几乎看不到第三张图片。320pt 宽度的 iPhone 上第二张图片都不能显示完全；</p>
<p>文字显示区域，屏幕宽度和高度会共同影响屏幕上能显示文字的数量；</p>
<p>特别地，320pt 宽度的 5.4 寸 iPhone 上，导航栏的按钮已经显得有些拥挤了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3ada18632c459c9a8c97d86c896038d2.png"></p>
<p>非全面屏 4 寸的第一代 iPhone SE 仍然支持 iOS 14、全面屏 5.4 寸 iPhone 再次引入 320pt 宽度，在屏幕日趋变大的今天，设计师和开发者仍然需要为 320pt 这样较窄宽度的 iPhone 进行 app 设计、适配和开发。</p>
<h3 id="刘海变窄变小？"><a href="#刘海变窄变小？" class="headerlink" title="刘海变窄变小？"></a>刘海变窄变小？</h3><p>全面屏 iPhone 的刘海中包含的物理元器件并不随 iPhone 的屏幕尺寸所变化，根据网上找到的资料，刘海的宽度大概为 209pt。在目前放出的 iOS 14 Beta 版本中，刘海附近的状态栏显示区域（包含基本的时间、信号、网络和电量信息）并没有发生设计上的改变，而当把现有的状态栏放到 320pt 宽度的 iPhone 上时，我们会发现其无法承载现有的状态栏信息，那这是否可以推测 5.4 寸的 iPhone 12 抑或是整个 iPhone 12 系列的刘海会变得更窄更小呢？</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1d0ddfcc067ab8acafe985db743b71bb.png"></p>
<h3 id="超旗舰-iPhone-12-Pro-又会是什么样？"><a href="#超旗舰-iPhone-12-Pro-又会是什么样？" class="headerlink" title="超旗舰 iPhone 12 Pro 又会是什么样？"></a>超旗舰 iPhone 12 Pro 又会是什么样？</h3><p>超旗舰 6.1 寸的 iPhone 12 Pro 和 6.7 寸 的 iPhone 12 Pro Max，相比于上一代屏幕尺寸都有一定程度的小幅增大。根据之前 iPhone 屏幕逻辑分辨率的进化规律，我认为 Apple 对于逻辑分辨率的改变是比较谨慎的，因为新的逻辑分辨率对设计师和开发者就意味着新的设计、适配和开发工作，iPhone 的屏幕尺寸就会更加碎片化，所以如果 iPhone 12 Pro 的尺寸真的是 6.1 寸和 6.7 寸，猜测屏幕尺寸的整体变大可能是由于屏幕边框变窄导致，iPhone 12 Pro 系列的屏幕逻辑分辨率和渲染分辨率应该与上一代保持一致，PPI 稍有降低。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8b6b010b4b9ec261bdd40332b21032d9.png"></p>
<h3 id="iPhone-屏幕还会怎么变？"><a href="#iPhone-屏幕还会怎么变？" class="headerlink" title="iPhone 屏幕还会怎么变？"></a>iPhone 屏幕还会怎么变？</h3><p>目前 iPhone 的最大尺寸是 6.5 寸，这个尺寸的手机对于用户日常使用来说已经基本到达极限，如果按照之前的屏幕进化规律通过「横向不变，纵向变长」或者「等比放大」的方法继续变大已经没有必要，但不可否认的是，更大的显示屏幕更有利于内容的显示和多任务的操作，对于手机来说，体积尽量小，但屏幕尽量大的折叠屏手机可能会成为未来的发展方向。</p>
<p>隔壁 Android 阵营已经有多家厂商发布了折叠屏手机，比如三星 Galaxy Fold、华为 Mate X，折叠屏也很可能成为 iPhone 未来发展的一个方向，iPhone 的屏幕很有可能出现第三个进化方法——横向放大，纵向不变。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3316089d28031a788da537e0e6850fc9.png"></p>
<p>畅想一下，在折叠屏 iPhone 上，你可以让 app 按照以前接近两倍的显示面积来显示；也可以让一个 app 全屏显示，另一个 app 以小窗口的形式悬浮在另一个 app 之上，类似 iPadOS 上的 Slide Over；更可以让两个 app 并排显示，类似 iPadOS 上的 Split View。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3223ec8672b2d9b443fc4105faa42fa2.png"></p>
<p>一方面，app 在设计内容布局时使用了 Auto Layout、Size Class、Safe Area 这些武器，app 的布局适应性更高；另一方面更多的 iPad app 已经可以以任何尺寸自适应布局灵活显示，固定尺寸大小的 app 设计思想正在被弱化，同时 app 多任务、多窗口的功能已在 iPadOS 中进化得逐步完善。基于这两方面，到折叠屏 iPhone 推出时，iOS 和 iPadOS 上的 app 适配的阵痛期就会更短。</p>
<p>总的来看，iPhone 屏幕逐渐变大，甚至翻倍，尺寸接近 iPad，iPad 部分功能下放到 iPhone 上，iPhone 与 iPad 的边界会变得逐渐模糊；同时，iPad 的 app 通过 Mac Catalyst 技术向 Mac 平台转移，Mac 逐步放弃 Intel 芯片，逐渐采用 Apple Silicon，iPad 和 Mac 的边界也同样在变得模糊。或许在未来的某一天，iPhone、iPad、Mac 的 app 生态会逐渐融合，合为一体</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从第一代 iPhone 到 iPhone 12，每一次屏幕尺寸的变化不仅仅是硬件上物理参数的变化，背后还有着缜密的 app 设计逻辑牵制着硬件参数的变化：</p>
<p>横向不变，纵向变长：从 iPhone 4s 到 iPhone 5，从 iPhone 8 到 iPhone X，从 iPhone 8 Plus 到 iPhone Xʀ、iPhone Xs Max，从 iPhone SE 第一代到 iPhone 12 采用了这个变化规律，纵向上比以前可以看到更多内容；</p>
<p>等比放大：从 iPhone 5s 到 iPhone6、iPhone 6 Plus，从 iPhone X 到 iPhone Xs Max、iPhone Xʀ、iPhone 12 采用了这个变化规律，横纵向上都比以前可以看到更多内容；</p>
<p>屏幕尺寸不断增多，但屏幕逻辑分辨率宽度现在只有 320pt、375pt、414pt 三种。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8b7d79486d86992e8cf0eb800a2bf8e2.png"></p>
<p>为了让 app 能在各种屏幕尺寸的 iPhone 上都能完美显示，下面的武器必不可少，它们隐藏在 app 背后，默默发挥着作用：</p>
<p>Point 点：抛开像素密度的干扰，专注于内容数量的对比；</p>
<p>Auto Layout 自动布局：不对每一台设备进行绝对布局，通过确定 view 之间的约束关系针对所有设备进行相对布局；</p>
<p>Size Class 尺寸级别：竖屏、横屏，小屏、大屏，不同使用情景采取不同内容布局方案；</p>
<p>Safe Area 安全区域：非规则屏幕下的内容布局规范。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d060527a7eb3c16ce30410f6db61cba8.png"></p>
<p>屏幕尺寸的不断进化也带来了 iPhone 上功能和交互的变化：</p>
<p>放大显示功能：使用低一级的同比例的逻辑分辨率在更大屏幕上显示内容；</p>
<p>深色模式功能：让 OLED 屏幕更省电；</p>
<p>新的大标题导航栏：利用更长的屏幕展示更醒目的标题，增强用户在 app 内的空间感；</p>
<p>新的菜单样式：缩短用户操作路径，让按钮与操作之间关系更紧密，与 Mac 上的菜单样式保持一致。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2020/09/50.png"></p>
<p>对于即将到来的 5.4 寸 iPhone 12，基于 iOS 14 Beta 版本中发现的线索，可以猜想：</p>
<p>从逻辑分辨率上来看，5.4 寸 iPhone 12 基于第一代 iPhone SE 横向不变，纵向变长进化而来；</p>
<p>小屏便利的同时，内容显示数量作出了牺牲，320pt 的屏幕宽度相比于更大尺寸显示的内容数量偏少；</p>
<p>刘海可能会变窄变小以承载完整的状态栏信息。</p>
<p>在 iPhone 屏幕尺寸发展走到极限的今天，未来的 iPhone 可能会朝着折叠屏的方向发展，出现第三种变化方式——横向放大，纵向不变，而在这之前已有了许多铺垫：</p>
<p>iPad 上的 app 支持 Slide Over 侧拉、Split View 分屏浏览等多任务功能，支持一个 app 的多窗口功能；</p>
<p>App 的内容布局可以自适应多种不同尺寸、不同比例的屏幕，在 Auto Layout、Size Class、Safe</p>
<p>Area 的帮助下，固定尺寸的 app 设计思想被弱化，Apple 生态圈的 app 自由变换显示尺寸指日可待；</p>
<p>Apple 自身也在强力推进开发者的 app 适配所有的屏幕尺寸。</p>
<p>纵观 iPhone 的屏幕进化历程可以看出 iPhone 的屏幕进化不仅仅是硬件上物理参数的改变，还伴随着软件上设计和开发逻辑的不断完善，前期硬件和软件的进化或许早已为以后的软硬件埋下了种子，这种软硬一体，硬件和软件相互影响、相互牵制的设计思想可能正是解释很多人会问到的「为什么总感觉 iPhone 比 Android 好用一点，但又说不出具体哪里好？」这种问题的一个答案。</p>
<p>「罗马不是一日建成的」，智能手机的生态走到今天，各家手机厂商的产品已是大差不差，但可能就是在那些微不足道的地方的细细耕耘、日积月累默默地抓住了用户的心。</p>
<blockquote>
<p>作者：向远公园 | STEP PARK<br>链接：<a href="https://steppark.net/15978209110755.html">https://steppark.net/15978209110755.html</a><br>来源：向远公园 | STEP PARK<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Github Pages 和 Hexo 快速搭建博客系统</title>
    <url>/2020/11/09/%E4%BD%BF%E7%94%A8-Github-Pages-%E5%92%8C-Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="环境准备工作"><a href="#环境准备工作" class="headerlink" title="环境准备工作"></a>环境准备工作</h1><ul>
<li>安装 Node.js</li>
<li>安装 Git</li>
<li>Github 账户</li>
</ul>
<p>安装方法自己网上找，通过以下三条命令检测上述是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="安装-Hexo-及部署到-GitHub-Pages-上"><a href="#安装-Hexo-及部署到-GitHub-Pages-上" class="headerlink" title="安装 Hexo 及部署到 GitHub Pages 上"></a>安装 Hexo 及部署到 GitHub Pages 上</h1><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>选择一个磁盘，新建一个文件夹，自己重命名文件夹（如：我的文件夹为：Ｅ\My_Blog），博客相关文件将储存在此文件夹下，在该文件夹下右键鼠标，点击 Git Bash Here，输入以下 npm 命令即可安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装 hexo</span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">// 表示安装 hexo 部署到 git page 的 deployer</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-初始化配置"><a href="#Hexo-初始化配置" class="headerlink" title="Hexo 初始化配置"></a>Hexo 初始化配置</h2><p>在刚才新建的文件夹里面再次新建一个 Hexo 文件夹（如：我的文件夹为：E\My_Blog\Hexo）,进入该 Hexo 文件夹右键鼠标，点击 Git Bash Here，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此命令如果长时间卡主，很可能是因为默认主题下载不下来，直接ctrl+c 退出即可，继续下一步。因为我们后面会选择主题进行安装。</p>
</blockquote>
<h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><p>执行以下命令，执行完即可登录 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h2 id="将博客部署到-Github-Pages-上"><a href="#将博客部署到-Github-Pages-上" class="headerlink" title="将博客部署到 Github Pages 上"></a>将博客部署到 Github Pages 上</h2><ol>
<li><p>登录Github账户后，创建一个名称为：xxx.github.io 格式的代码库。</p>
</li>
<li><p>打开你创建的 Hexo 文件夹。用记事本打开该文件夹下的 _config.yml 文件，并进行如下修改：<br> <img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2020/10/103001.png"></p>
</li>
<li><p>在 Hexo 文件夹下执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>
<p>如果执行完成报以下错误，说明你的 deployer 没有安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>需要执行以下命令再安装一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>再执行<code>hexo g -d</code>，你的博客就会部署到 Github 上了</p>
</li>
<li><p>访问博客：https://你的用户名.github.io，通过此链接就可以访问你的博客了</p>
</li>
</ol>
<h1 id="选择博客主题"><a href="#选择博客主题" class="headerlink" title="选择博客主题"></a>选择博客主题</h1><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p><a href="https://hexo.io/themes/">点此此处</a>进入 Hexo 官网的主题专栏，我们可以看见有许多主题供我们选择。选中自己喜欢的主题去github上download下来（这种方式有时比git clone快很多）</p>
<h2 id="设置默认主题"><a href="#设置默认主题" class="headerlink" title="设置默认主题"></a>设置默认主题</h2><p>等待下载完成后将其放在 themes 目录下（如：\themes\hexo-theme-aero-dual），然后打开 Hexo 文件夹下的配置文件 _config.yml ，找到关键字 theme，修改参数为：theme：hexo-theme-aero-dual （其他主题修改成相应名称即可），再次注意冒号后面有一个空格！</p>
<h2 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h2><p>返回 Hexo 目录，右键 Git Bash Here ，输入以下命令开始部署主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>此时打开浏览器，访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 就可看见我们的主题已经更换了，如果感觉效果满意，我们就可以把它部署到Github上了。<br>打开 Hexo 文件夹，右键 Git Bash Here ，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean  </span><br><span class="line">//该命令的作用是清除缓存，若不输入此命令，服务器有可能更新不了主题</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>

<h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>新建一个空文章，输入以下命令，会在项目 \Hexo\source_posts 中生成 文章标题.md 文件，文章标题根据需要命名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo n &quot;文章标题&quot;</span><br></pre></td></tr></table></figure>
<p>也可以直接在 \Hexo\source_posts 目录下右键鼠标新建文本文档，改后缀为 .md 即可，这种方法比较方便</p>
<h2 id="推送到github服务器"><a href="#推送到github服务器" class="headerlink" title="推送到github服务器"></a>推送到github服务器</h2><p>当我们用编辑器写好文章后，可以使用以下命令将其推送到服务器上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>
<p>现在访问你的博客就可以看见写好的文章啦！</p>
<h1 id="博客美化和使用功能的添加"><a href="#博客美化和使用功能的添加" class="headerlink" title="博客美化和使用功能的添加"></a>博客美化和使用功能的添加</h1><p>有关博客后期的美化、实用功能的添加，可以参考网上的两篇文章（感谢原创作者）：</p>
<p><a href="https://blog.csdn.net/qq_36759224/article/details/85010191">Hexo 博客优化之实用功能添加系列</a></p>
<p><a href="https://blog.csdn.net/qq_36759224/article/details/85420403">Hexo 博客优化之博客美化系列</a></p>
<blockquote>
<p>感谢原创：<a href="https://blog.csdn.net/qq_36759224/article/details/82121420">https://blog.csdn.net/qq_36759224/article/details/82121420</a></p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用spacedesk实现两台笔记本的低延迟屏幕扩展</title>
    <url>/2020/11/09/%E4%BD%BF%E7%94%A8spacedesk%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%B1%8F%E5%B9%95%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p><strong>需求：</strong><br>有两台笔记本电脑，想要将其中一台作为扩展屏幕使用<br><strong>准备：</strong><br>两台有网线接口的笔记本电脑、一根双绞线、spacedesk软件<br><strong>软件下载地址：</strong><br>官网：<a href="https://www.spacedesk.net/#downloads">https://www.spacedesk.net/#downloads</a><br>网盘下载：链接：<a href="https://pan.baidu.com/s/1e2Y0BT1KKvMQF5RPIe2BQQ">https://pan.baidu.com/s/1e2Y0BT1KKvMQF5RPIe2BQQ</a><br>提取码：agdh </p>
<span id="more"></span>

<p><strong>详细操作步骤：</strong><br>1、安装完软件后 主机端 就有它的图标了，里面有个按钮选ON就能开启服务了。<br>（这个时候如果扩展屏机和主机在同在一局域网内的话，应该也可以进行连接了，但是这样并不能达到理想稳定传输效果，所以还得接下去继续设置）<br><img src="https://img-blog.csdnimg.cn/20190713122049957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxOTAyNzA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、分别把网线的两端接入笔记本的网卡接口，将两台设备连接起来。（一般接上后网线口处亮灯就可以了）<br><img src="https://img-blog.csdnimg.cn/20190713122745682.png" alt="在这里插入图片描述"><br>3、修改两台设备的网卡IP地址，如图所示。（这里设置成B类地址是为了避免与路由器冲突。）<br>主机为： 地址172.16.0.1 掩码255.255.255.0 网关172.16.0.1<br>扩展屏机：地址172.16.0.2 掩码255.255.255.0 网关172.16.0.1<br>修改ip地址方法：<a href="https://jingyan.baidu.com/article/046a7b3e95caf3f9c37fa971.html">https://jingyan.baidu.com/article/046a7b3e95caf3f9c37fa971.html</a><br><img src="https://img-blog.csdnimg.cn/20190713122956652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxOTAyNzA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、关闭 扩展屏机（接收端） 的防火墙，完成后可使用命令提示符（cmd） ping 172.16.0.2 验证两台设备间的连通性。两台设备间能 ping 通的话那就行了。<br>快速关闭防火墙的cmd命令：netsh advfirewall set publicprofile state off<br>检查设备连通性cmd命令：ping 172.16.0.2<br>关闭防火墙方法：<br><a href="https://jingyan.baidu.com/article/ff42efa9cc80efc19e2202b7.html">https://jingyan.baidu.com/article/ff42efa9cc80efc19e2202b7.html</a><br>5、进到接收端软件里面，点172.16.0.1的选项就可以通过网线连接扩展屏幕画面的。</p>
<ul>
<li>（如果要设置开机自动连接扩展的话，可以把快捷方式放到启动目录里面，让程序自启。再进接收端标题栏那里 settings –&gt;&gt; Automatic Connect 选项 将自动连接地址设为：172.16.0.1 再勾选 Auto reconnect ，就可以了）</li>
<li>在设置选项里还可以设置传输速度质量和 帧数。这个就不详细解释了</li>
<li>对于作为显示器的笔记本，我们先打开spacedesk VIEWER。然后在input的下拉菜单里，将”Mouse”, “Keyboard”, 和 “Touch Off”前打上勾。并将”Settings”-“Resolutions”里的第二个勾取消选择。最后点击File下的Connect，输入作为主机的笔记本的IPv4地址后，点击”OK Connect!”<br> <img src="https://img-blog.csdnimg.cn/20190713123131459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxOTAyNzA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  在从主机端设置一下屏幕扩展扩展选项，或者使用 Win + P 键也可以进行切换。<br>  <img src="https://img-blog.csdnimg.cn/20190713123208450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxOTAyNzA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  到此就全部完成了。（可能的一些问题：如果两屏分辨率不符的话，可以在连接后把修改分辨率，把高的那该改成和另一台一样的分辨率，两台设备分辨率一致。网络问题的话，我使用的是内置无线wifi来上网的，如果网络有冲突可以看情况禁用 wifi网卡，或者设置多重网络。材料的话我用的是买路由器时送的网线；某宝也有4块钱包邮网线卖。）</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Halo搭建个人博客</title>
    <url>/2020/11/09/%E4%BD%BF%E7%94%A8Halo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Halo-简介"><a href="#Halo-简介" class="headerlink" title="Halo 简介"></a>Halo 简介</h1><p>Halo是一款现代化的个人独立博客系统，是一个优秀的开源博客发布应用。简称 Halo [ˈheɪloʊ]，意为光环。<br>Halo运行包是一个JAVA程序，下载下来启动后便能直接使用。<br>整个Halo博客系统分为以下四个部分：</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>项目名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>halo</td>
<td>提供整个系统的服务，采用 Spring Boot 开发</td>
</tr>
<tr>
<td>halo-admin</td>
<td>负责后台管理的渲染，采用 Vue 开发，已集成在 Halo 运行包内，无需独立部署</td>
</tr>
<tr>
<td>halo-comment</td>
<td>评论插件，采用 Vue 开发，在主题中运行方式引入构建好的 Javascript 文件即可</td>
</tr>
<tr>
<td>halo-theme-*</td>
<td>主题项目集，采用 Freemarker 模板引擎编写，需要包含一些特殊的配置才能够被 halo 所使用</td>
</tr>
</tbody></table>
<h1 id="在Linux服务器上部署Halo"><a href="#在Linux服务器上部署Halo" class="headerlink" title="在Linux服务器上部署Halo"></a>在Linux服务器上部署Halo</h1><h2 id="安装-Java-运行环境"><a href="#安装-Java-运行环境" class="headerlink" title="安装 Java 运行环境"></a>安装 Java 运行环境</h2><blockquote>
<p> 若已经存在 Java 运行环境的可略过这一步。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 OpenJRE</span><br><span class="line">sudo yum install java-1.8.0-openjdk -y</span><br><span class="line"></span><br><span class="line"># 检测是否安装成功</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="安装-Halo"><a href="#安装-Halo" class="headerlink" title="安装 Halo"></a>安装 Halo</h2><h3 id="下载配置文件"><a href="#下载配置文件" class="headerlink" title="下载配置文件"></a>下载配置文件</h3><p>考虑到部分用户的需要，可能需要自定义比如端口等设置项，我们提供了公共的配置文件，并且该配置文件是完全独立于安装包的。当然，你也可以使用安装包内的默认配置文件，但是安装包内的配置文件是不可修改的。请注意：配置文件的路径为 ~/.halo/application.yaml。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载配置文件到 ~/.halo 目录</span><br><span class="line">curl -o ~/.halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>完成上一步操作，我们就可以自己配置 Halo 的运行端口，以及数据库相关的配置了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 Vim 工具修改配置文件</span><br><span class="line">vim ~/.halo/application.yaml</span><br></pre></td></tr></table></figure>
<p>打开之后我们可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  # 服务端口号</span><br><span class="line">  port: 8090</span><br><span class="line"></span><br><span class="line">  # Response data gzip.</span><br><span class="line">  compression:</span><br><span class="line">    enabled: false</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    # 默认使用的是 H2 Database 数据库，这是一种嵌入式的数据库</span><br><span class="line">    # H2 database configuration.</span><br><span class="line">    driver-class-name: org.h2.Driver</span><br><span class="line">    url: jdbc:h2:file:~/.halo/db/halo</span><br><span class="line">    username: admin</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line">    # MySQL database configuration.</span><br><span class="line">  #    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">  #    url: jdbc:mysql://127.0.0.1:3306/halodb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true</span><br><span class="line">  #    username: root</span><br><span class="line">  #    password: 123456</span><br><span class="line"></span><br><span class="line">  # H2 database console configuration.</span><br><span class="line">  h2:</span><br><span class="line">    console:</span><br><span class="line">      settings:</span><br><span class="line">        web-allow-others: false</span><br><span class="line">      path: /h2-console</span><br><span class="line">      enabled: false</span><br><span class="line"></span><br><span class="line">halo:</span><br><span class="line">  # Your admin client path is https://your-domain/&#123;admin-path&#125;</span><br><span class="line">  admin-path: admin</span><br><span class="line"></span><br><span class="line">  # memory or level</span><br><span class="line">  cache: memory</span><br></pre></td></tr></table></figure>

<h2 id="运行Halo"><a href="#运行Halo" class="headerlink" title="运行Halo"></a>运行Halo</h2><p>Halo 的整个应用程序只有一个 Jar 包，且不包含用户的任何配置，它放在任何目录都是可行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载最新的 Halo 安装包，&#123;&#123;version&#125;&#125; 为版本号，不带 v，更多下载地址请访问 https://halo.run/archives/download.html</span><br><span class="line">wget https://dl.halo.run/release/halo-&#123;&#123;version&#125;&#125;.jar -O halo-latest.jar</span><br><span class="line"></span><br><span class="line"># 启动测试</span><br><span class="line">java -jar halo-latest.jar</span><br></pre></td></tr></table></figure>
<p>如看到以下日志输出，则代表启动成功.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run.halo.app.listener.StartedListener    : Halo started at         http://127.0.0.1:8090</span><br><span class="line">run.halo.app.listener.StartedListener    : Halo admin started at   http://127.0.0.1:8090/admin</span><br><span class="line">run.halo.app.listener.StartedListener    : Halo has started successfully!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当jar包下载失败或下载的不能成功运行时，请前往：<a href="https://halo.run/archives/download.html">https://halo.run/archives/download.html</a> 进行下载</p>
</blockquote>
<h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><p>上面我们已经完成了 Halo 的整个配置和安装过程，接下来我们对其进行更完善的配置，比如：需要开机自启？，更简单的启动方式？</p>
<p>实现以上功能我们只需要新增一个配置文件即可，也就是使用 Systemd 来完成这些工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载 Halo 官方的 halo.service 模板</span><br><span class="line">sudo curl -o /etc/systemd/system/halo.service --create-dirs https://dl.halo.run/config/halo.service</span><br></pre></td></tr></table></figure>
<p>下载完成之后，我们还需要对其进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改 halo.service</span><br><span class="line">sudo vim /etc/systemd/system/halo.service</span><br></pre></td></tr></table></figure>
<p>打开之后我们可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Halo Service</span><br><span class="line">Documentation=https://halo.run</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=halo</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/java -server -Xms256m -Xmx256m -jar YOUR_JAR_PATH</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">Restart=always</span><br><span class="line">StandOutput=syslog</span><br><span class="line"></span><br><span class="line">StandError=inherit</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>-Xms256m：为 JVM 启动时分配的内存，请按照服务器的内存做适当调整，512 M 内存的服务器推荐设置为 128，1G 内存的服务器推荐设置为 256，默认为 256。</li>
<li>-Xmx256m：为 JVM 运行过程中分配的最大内存，配置同上。</li>
<li>YOUR_JAR_PATH：Halo 安装包的绝对路径，例如 /www/wwwroot/halo-latest.jar。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改 service 文件之后需要刷新 Systemd</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 使 Halo 开机自启</span><br><span class="line">sudo systemctl enable halo</span><br><span class="line"></span><br><span class="line"># 启动 Halo</span><br><span class="line">sudo service halo start</span><br><span class="line"></span><br><span class="line"># 重启 Halo</span><br><span class="line">sudo service halo restart</span><br><span class="line"></span><br><span class="line"># 停止 Halo</span><br><span class="line">sudo service halo stop</span><br><span class="line"></span><br><span class="line"># 查看 Halo 的运行状态</span><br><span class="line">sudo service halo status</span><br></pre></td></tr></table></figure>

<p>完成以上操作即可通过 IP:端口 访问了。不过在此之前，最好先完成后续操作，我们还需要让域名也可以访问到 Halo，请继续看 配置域名访问。</p>
<h2 id="更新-Halo"><a href="#更新-Halo" class="headerlink" title="更新 Halo"></a>更新 Halo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份数据</span><br><span class="line">cp -r ~/.halo ~/.halo.bak</span><br><span class="line"></span><br><span class="line"># 备份旧的安装包</span><br><span class="line">mv halo-latest.jar halo-latest.jar.bak</span><br><span class="line"></span><br><span class="line"># 下载最新的 Halo 安装包，&#123;&#123;version&#125;&#125; 为版本号，不带 v，更多下载地址请访问 https://halo.run/archives/download.html</span><br><span class="line">wget https://dl.halo.run/release/halo-&#123;&#123;version&#125;&#125;.jar -O halo-latest.jar</span><br><span class="line"></span><br><span class="line"># 测试是否能够正常启动</span><br><span class="line">java -jar halo-latest.jar</span><br><span class="line"></span><br><span class="line"># 重启应用</span><br><span class="line">service halo restart</span><br></pre></td></tr></table></figure>

<h1 id="配置域名访问"><a href="#配置域名访问" class="headerlink" title="配置域名访问"></a>配置域名访问</h1><h2 id="使用Nginx进行反向代理"><a href="#使用Nginx进行反向代理" class="headerlink" title="使用Nginx进行反向代理"></a>使用Nginx进行反向代理</h2><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加 Nginx 源</span><br><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line"># 安装 Nginx</span><br><span class="line">sudo yum install -y nginx</span><br><span class="line"></span><br><span class="line"># 启动 Nginx</span><br><span class="line">sudo systemctl start nginx.service</span><br><span class="line"></span><br><span class="line"># 设置开机自启 Nginx</span><br><span class="line">sudo systemctl enable nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载 Halo 官方的 Nginx 配置模板</span><br><span class="line">curl -o /etc/nginx/conf.d/halo.conf --create-dirs https://dl.halo.run/config/nginx.conf</span><br></pre></td></tr></table></figure>
<p>下载完成之后，我们还需要对其进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 vim 编辑 halo.conf</span><br><span class="line">vim /etc/nginx/conf.d/halo.conf</span><br></pre></td></tr></table></figure>
<p>打开之后我们可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header HOST $host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://127.0.0.1:8090/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：请把 example.com 改为自己的域名。</p>
</blockquote>
<p>修改完成之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 检查配置是否有误</span><br><span class="line">sudo nginx -t</span><br><span class="line"></span><br><span class="line"># 重载 Nginx 配置</span><br><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多配置详情见halo官网：<a href="https://halo.run/">https://halo.run/</a> <br/><br>halo社区：<a href="https://bbs.halo.run/">https://bbs.halo.run/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>关于AJAX</title>
    <url>/2020/11/09/%E5%85%B3%E4%BA%8EAJAX/</url>
    <content><![CDATA[<p>AJAX：Asynchronous JavaScript and XML，意思是用JavaScript执行异步网络请求。<br>现代浏览器上，ajax的实现主要依靠XMLHttpRequest 对象，该对象用于和服务器交换数据</p>
<h6 id="1、XMLHttpRequest对象有-open-“请求类型”-“请求文件在服务器上的位置”-是否异步-和-send-方法。"><a href="#1、XMLHttpRequest对象有-open-“请求类型”-“请求文件在服务器上的位置”-是否异步-和-send-方法。" class="headerlink" title="1、XMLHttpRequest对象有 open(“请求类型”, “请求文件在服务器上的位置”,是否异步) 和 send() 方法。"></a>1、XMLHttpRequest对象有 open(“请求类型”, “请求文件在服务器上的位置”,是否异步) 和 send() 方法。</h6><p>  （1）对于get请求可以通过向URL添加唯一的ID，来避免首先获取缓存结果。<br>  （2）对于post请求：使用setRequestHeader()添加HTTP头，然后在send()方法中规定发送数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);</span><br><span class="line">  xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">  xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h6 id="2、XMLHttpRequest对象的-responseText-和-responseXML-属性来处理响应数据。"><a href="#2、XMLHttpRequest对象的-responseText-和-responseXML-属性来处理响应数据。" class="headerlink" title="2、XMLHttpRequest对象的 responseText 和 responseXML 属性来处理响应数据。"></a>2、XMLHttpRequest对象的 responseText 和 responseXML 属性来处理响应数据。</h6><h6 id="3、XMLHttpRequest-提供-onreadystatechange-方法、readyState-属性、status-属性来监听响应状态"><a href="#3、XMLHttpRequest-提供-onreadystatechange-方法、readyState-属性、status-属性来监听响应状态" class="headerlink" title="3、XMLHttpRequest 提供 onreadystatechange() 方法、readyState 属性、status 属性来监听响应状态"></a>3、XMLHttpRequest 提供 onreadystatechange() 方法、readyState 属性、status 属性来监听响应状态</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;AJAX&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;使用AJAX修改文本内容&lt;/h2&gt;&lt;/div&gt;</span><br><span class="line">  &lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;修改内容&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function loadXMLDoc() &#123;</span><br><span class="line">    var xmlhttp;</span><br><span class="line">    if (window.XMLHttpRequest) &#123;</span><br><span class="line">      // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行</span><br><span class="line">      xmlhttp = new XMLHttpRequest();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // IE6, IE5 浏览器执行代码</span><br><span class="line">      xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xmlhttp.onreadystatechange = function() &#123;</span><br><span class="line">      if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123;</span><br><span class="line">        document.getElementById(&quot;myDiv&quot;).innerHTML = xmlhttp.responseText;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xmlhttp.open(&quot;GET&quot;,&quot;/try/demo_get.php?t=&quot; + Math.random(), true);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000">廖雪峰官网AJAX</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于前端请求的那些事</title>
    <url>/2022/11/09/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣，针对这一课题，作者查阅了相关资料加以自己的理解，如有错误，烦请指出。</p>
<h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h1><p>AJAX：Asynchronous JavaScript and XML，意思是用JavaScript执行异步网络请求。<br>现代浏览器上，ajax的实现主要依靠 XMLHttpRequest 对象，该对象用于和服务器交换数据。有了XMLHttpRequest，开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有浏览器均可以获取XMLHttpRequest对象：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); //获取xhr对象</span><br></pre></td></tr></table></figure>
<p>但是XMLHttpRequest是个比较粗燥的底层对象，各个浏览器对其的创建方法也不同，如果需要兼容老版本的 IE (IE5, IE6) 浏览器，则需要使用 ActiveX 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr;</span><br><span class="line">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class="line">  xhr = new XMLHttpRequest();</span><br><span class="line">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class="line">  try &#123;</span><br><span class="line">    xhr = new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      xhr = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);</span><br><span class="line">    &#125; catch (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用XMLHttpRequest发起一个get请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对于get请求可以通过向URL添加唯一的ID，来避免首先获取缓存结果</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>完整的post请求代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr;</span><br><span class="line">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class="line">  xhr = new XMLHttpRequest();</span><br><span class="line">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class="line">  try &#123;</span><br><span class="line">    xhr = new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      xhr = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);</span><br><span class="line">    &#125; catch (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (xhr) &#123;</span><br><span class="line">  xhr.onreadystatechange = onReadyStateChange;</span><br><span class="line">  // open(&quot;请求类型&quot;, &quot;请求文件在服务器上的位置&quot;, 是否异步)</span><br><span class="line">  xhr.open(&#x27;POST&#x27;, &#x27;/api&#x27;, true);</span><br><span class="line">  // 设置 Content-Type 为 application/x-www-form-urlencoded</span><br><span class="line">  // 以表单的形式传递数据</span><br><span class="line">  xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);</span><br><span class="line">  xhr.send(&#x27;username=admin&amp;password=root&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** XMLHttpRequest 提供 onreadystatechange() 方法、readyState 属性、status 属性来监听响应状态。</span><br><span class="line">readyState的取值如下：</span><br><span class="line">  0 (未初始化)</span><br><span class="line">  1 (正在装载)</span><br><span class="line">  2 (装载完毕)</span><br><span class="line">  3 (交互中)</span><br><span class="line">  4 (完成)</span><br><span class="line">*/</span><br><span class="line">function onReadyStateChange() &#123;</span><br><span class="line">  if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123;</span><br><span class="line">    // XMLHttpRequest对象的 responseText 和 responseXML 属性来处理响应数据。</span><br><span class="line">    console.log(&#x27;执行成功&#x27;，xhr.responseText);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#x27;执行出错&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Jquery-Ajax"><a href="#Jquery-Ajax" class="headerlink" title="Jquery Ajax"></a>Jquery Ajax</h1><p>说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;   //标准写法</span><br><span class="line">   type: &#x27;POST&#x27;,</span><br><span class="line">   url: url,</span><br><span class="line">   data: data,</span><br><span class="line">   dataType: dataType,</span><br><span class="line">   success: function () &#123;&#125;,</span><br><span class="line">   error: function () &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">$.get(url,function()&#123;&#125;); //get请求</span><br><span class="line">$.post(url,body,function()&#123;&#125;); //post请求</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>： - 对原生XHR的封装 - 针对MVC的编程 - 完美的兼容性 - 支持jsonp<br><strong>缺点</strong>： - 不符合MVVM - 异步模型不够现代，不支持链式，代码可读性差 - 整个Jquery太大，引入成本过高</p>
<h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>fetch其实是一个新世界，脱离的XHR，完全是基于Promise的异步处理机制，使用起来会比起ajax更加简单。<br>使用fetch的代码会相比xhr来说更具有条理性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(url).then(function(response) &#123;</span><br><span class="line">  return response.json();</span><br><span class="line">&#125;).then(function(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  console.log(&quot;Oops, error&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在使用ES6的箭头函数后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(url).then(response =&gt; response.json())</span><br><span class="line">  .then(data =&gt; console.log(data))</span><br><span class="line">  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>： - 更加底层，提供的API丰富（request, response） - 语法简单，脱离了XHR，基于ES新的Promise设计<br>看到以上，或许你会觉得fetch真的很美好，但是请了解，fetch本身是一个 low-level 的 API，它注定不会像你习惯的 $.ajax 或是 axios 等库帮你封装各种各样的功能或实现。</p>
<p>所以它是存在一定的缺点： - 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：es6-promise,babel-polyfill,fetch-ie8等</p>
<ul>
<li><p>不支持jsonp，可以引入fetch-jsonp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//安装</span><br><span class="line">npm install fetch-jsonp --save-dev</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">fetchJsonp(url, &#123;</span><br><span class="line">  timeout: 3000,</span><br><span class="line">  jsonpCallback: &#x27;callback&#x27;</span><br><span class="line">&#125;).then(function(response) &#123;</span><br><span class="line">  console.log(response.json());</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>没有拦截器，需要额外再封装一层或者fetch-interceptor</p>
</li>
<li><p>默认不带cookie，需要添加配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(url,&#123;</span><br><span class="line">  credentials: &#x27;include&#x27; //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>没有abort，不支持timeout超时处理</p>
</li>
</ul>
<p>可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。 - 无法获取progress状态</p>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。 - 支持node，创建http请求 - 支持Promise API - 客户端防止CSRF：每个请求带一个cookie拿到的key - 拦截请求和响应 - 可取消请求<br>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。<br>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//npm</span><br><span class="line">npm install axios</span><br><span class="line"></span><br><span class="line">//cdn</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;\/script&gt;</span><br></pre></td></tr></table></figure>
<p>基本使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: &#x27;GET&#x27;,</span><br><span class="line">    url: url,</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class="line">.catch(err =&gt; &#123;console.log(err)&#125;)</span><br><span class="line"></span><br><span class="line">// get请求</span><br><span class="line">axios.get(url)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// post请求</span><br><span class="line">axios.post（‘/user’, &#123;</span><br><span class="line">    name: &#x27;Jerry&#x27;,</span><br><span class="line">    lastName: &#x27;Liang&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="特殊场景的处理"><a href="#特殊场景的处理" class="headerlink" title="特殊场景的处理"></a>特殊场景的处理</h1><p>在开发过程中，经常会遇到比较尴尬的场景就是多请求的串行与并发，并发比较容易解决，不存在回调地狱，但是代码可读性就会容易变得很渣，而串行问题对于前端是绝望的，最好的办法是后端来做合并，如果后端不做这块的处理，前端就必须来面对回调地狱。</p>
<h2 id="多请求串行"><a href="#多请求串行" class="headerlink" title="多请求串行"></a>多请求串行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ajax</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;&#x27;,</span><br><span class="line">    data: &#x27;&#x27;,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">       $.ajax(&#123;</span><br><span class="line">            url: &#x27;&#x27;,</span><br><span class="line">            data: &#x27;&#x27;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    // 如此一层嵌套一层</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//axios</span><br><span class="line">axios.get(url)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">    return axios.get(url,&#123;</span><br><span class="line">         &#123;name:result.name&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    //如此一层层嵌套</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="多请求并行"><a href="#多请求并行" class="headerlink" title="多请求并行"></a>多请求并行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ajax 通过计数器实现（虽然Jquery支持$.when的方式，但此处不做案例）</span><br><span class="line">var num = 0;</span><br><span class="line">function all()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    if(n&gt;=3)console.log(&#x27;三个请求全部完成&#x27;)；</span><br><span class="line">&#125;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;&#x27;,</span><br><span class="line">    data: &#x27;&#x27;,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">       console.log(&quot;ajax请求1 完成&quot;);</span><br><span class="line">       all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;&#x27;,</span><br><span class="line">    data: &#x27;&#x27;,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">       console.log(&quot;ajax请求2 完成&quot;);</span><br><span class="line">       all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;&#x27;,</span><br><span class="line">    data: &#x27;&#x27;,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">       console.log(&quot;ajax请求3 完成&quot;);</span><br><span class="line">       all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//axios</span><br><span class="line">function getInfo() &#123;</span><br><span class="line">  return axios.get(url);</span><br><span class="line">&#125;</span><br><span class="line">function getUser() &#123;</span><br><span class="line">  return axios.get(url);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getInfo(), getUser()])</span><br><span class="line">  .then(axios.spread(function (info, user) &#123;</span><br><span class="line">    // 两个请求现在都执行完成</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>
<h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><ol>
<li>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。</li>
<li>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。</li>
<li>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化 - 图片的懒加载和预加载</title>
    <url>/2023/03/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20-%20%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>1、什么是懒加载<br>懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。用户滚动到它们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。</p>
<p>2、为什么要用懒加载<br>（1）能提升用户的体验，不妨设想下，用户打开像手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。<br>（2）减少无效资源的加载，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。<br>（3）防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。</p>
<p>3、懒加载的原理<br>首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。</p>
<p>4、懒加载实现步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Lazyload&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .image-item &#123;</span><br><span class="line">      display: block;</span><br><span class="line">      margin-bottom: 50px;</span><br><span class="line">      height: 200px; //一定记得设置图片高度</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/1.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/2.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/3.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/4.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/5.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/6.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/7.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/8.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/9.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/10.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/11.png&quot; /&gt;</span><br><span class="line">  &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-original=&quot;images/12.png&quot; /&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var viewHeight = document.documentElement.clientHeight//获取可视区高度</span><br><span class="line">    function lazyload() &#123;</span><br><span class="line">      var eles = document.querySelectorAll（&#x27;img[data-original][lazyload]&#x27;）</span><br><span class="line">      Array.prototype.forEach.call(eles, function (item, index) &#123;</span><br><span class="line">        var rect</span><br><span class="line">        if (item.dataset.original === &quot;&quot;)</span><br><span class="line">          return</span><br><span class="line">        rect = item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span><br><span class="line">        if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) &#123;</span><br><span class="line">          !function () &#123;</span><br><span class="line">            var img = new Image()</span><br><span class="line">            img.src = item.dataset.original</span><br><span class="line">            img.onload = function () &#123;</span><br><span class="line">              item.src = img.src</span><br><span class="line">            &#125;</span><br><span class="line">            item.removeAttribute（&quot;data-original&quot;）//移除属性，下次不再遍历</span><br><span class="line">            item.removeAttribute（&quot;lazyload&quot;）</span><br><span class="line">          &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片</span><br><span class="line">    document.addEventListener（&quot;scroll&quot;，lazyload)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h1><p>1、什么是预加载<br>资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</p>
<p>2、为什么要用预加载<br>在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。</p>
<p>3、实现预加载的几种办法<br>（1）使用HTML标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://pic26.nipic.com/20121213/6168183 0044449030002.jpg&quot; style=&quot;display:none&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>（2）使用Image对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;./myPreload.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">//myPreload.js文件</span><br><span class="line">var image= new Image()</span><br><span class="line">image.src=&quot;http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg&quot;</span><br></pre></td></tr></table></figure>

<p>（3）使用XMLHttpRequest对象,虽然存在跨域问题，但会精细控制预加载过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xmlhttprequest = new XMLHttpRequest();</span><br><span class="line">xmlhttprequest.onreadystatechange = callback;</span><br><span class="line">xmlhttprequest.onprogress = progressCallback;</span><br><span class="line">xmlhttprequest.open(&quot;GET&quot;, &quot;http://image.baidu.com/mouse,jpg&quot;, true);</span><br><span class="line">xmlhttprequest.send();</span><br><span class="line">function callback() &#123;</span><br><span class="line">  if (xmlhttprequest.readyState == 4 &amp;&amp; xmlhttprequest.status == 200) &#123;</span><br><span class="line">    var responseText = xmlhttprequest.responseText;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;Request was unsuccessful:&quot; + xmlhttprequest.status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function progressCallback(e) &#123;</span><br><span class="line">  e = e || event;</span><br><span class="line">  if (e.lengthComputable) &#123;</span><br><span class="line">    console.log(&quot;Received&quot; + e.loaded + &quot;of&quot; + e.total + &quot;bytes&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）使用PreloadJS库<br>PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用preload.js</span><br><span class="line">var queue = new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域</span><br><span class="line">queue.on(&quot;complete&quot;, handleComplete, this);</span><br><span class="line">queue.loadManifest([</span><br><span class="line">  &#123; id: &quot;myImage&quot;, src: &quot;http://pic26.nipic.com/20121213/6168183  0044449030002.jpg&quot; &#125;,</span><br><span class="line">  &#123; id：&quot;myImage2&quot;，src: &quot;http://pic9.nipic.com/20100814/2839526  1931471581702.jpg&quot; &#125;</span><br><span class="line">]);</span><br><span class="line">function handleComplete() &#123;</span><br><span class="line">  var image = queue.getResuLt(&quot;myImage&quot;);</span><br><span class="line">  document.body.appendChild(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="懒加载和预加载的对比"><a href="#懒加载和预加载的对比" class="headerlink" title="懒加载和预加载的对比"></a>懒加载和预加载的对比</h1><p>两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>利用jsDelivr白嫖全球超高速静态资源访问服务！</title>
    <url>/2023/06/09/%E5%88%A9%E7%94%A8jsDelivr%E7%99%BD%E5%AB%96%E5%85%A8%E7%90%83%E8%B6%85%E9%AB%98%E9%80%9F%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%EF%BC%81/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>不希望将大量的图片等静态资源放在自己部署了项目的云服务器上，放在其他服务器上又希望能做到CDN加速。于是找到了<strong>jsDelivr</strong>来解决这个需求。以下文章转载自<a href="https://www.bilibili.com/read/cv4297993">利用jsDelivr白嫖全球超高速静态资源访问服务！</a>自己有稍微的修改。<br>因为服务器在国外&amp;服务器带宽小，导致静态资源请求速度慢，最终导致全站访问速度被拖慢，是站长们要面对的问题。最常用的解决方案是使用国内IDC厂商提供的对象存储(镜像回源)+CDN来提升静态资源访问速度，但这难免会产生费用。</p>
<span id="more"></span>

<h1 id="jsDelivr是什么"><a href="#jsDelivr是什么" class="headerlink" title="jsDelivr是什么"></a>jsDelivr是什么</h1><p>jsDelivr由ProspectOne维护的公共库，使用的融合CDN技术，由Cloudflare、Fastly、StackPath、QUANTIL等CDN供应商提供了<strong>全球超过750个CDN节点</strong>。<br>最重要的是，jsDelivr在<strong>中国大陆</strong>也拥有超过数百个节点，因为jsDelivr拥有<strong>正规的ICP备案</strong>，解决了中国大陆的访问速度优化，实现真正的<strong>全球极速低延迟</strong>体验。<br>jsDelivr是<strong>免费</strong>的、<strong>不限制带宽</strong>的，可以加速<strong>NPM</strong>、<strong>Github</strong>内的文件。<br>本文采用的方法就是将静态文件资源放到Github的仓库内，再使用jsDelivr进行加速访问，达到完全零成本优化访问速度。相当于一个高速访问的图床！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAdjEuMy9pbWFnZXMvMjAyMC8wNC9qc2RlbGl2ci01LndlYnA?x-oss-process=image/format,png" alt="全球节点分布地图"></p>
<h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>在Github新建一个公开仓库，用于存放我们的静态文件资源。这里不再过多赘述，下面的链接是我的<a href="https://github.com/HelloAllenW/BlogAssets">静态文件资源仓库</a>。</p>
<h1 id="使用jsDelivr访问资源"><a href="#使用jsDelivr访问资源" class="headerlink" title="使用jsDelivr访问资源"></a>使用jsDelivr访问资源</h1><p>根据<a href="%5Bjsdelivr%5D(https://www.jsdelivr.com/)">jsdelivr官方文档</a>，有很多种访问资源的方式，这里主要介绍三种。</p>
<h2 id="通过releases访问"><a href="#通过releases访问" class="headerlink" title="通过releases访问"></a>通过releases访问</h2><p>在仓库首页找到releases<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAdjEuMy9pbWFnZXMvMjAyMC8wNC9qc2RlbGl2ci0xLnBuZw?x-oss-process=image/format,png" alt="新建releases"><br>创建new releases，如果之前创建过则选择Draft a new releases<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAdjEuMy9pbWFnZXMvMjAyMC8wNC9qc2RlbGl2ci0yLnBuZw?x-oss-process=image/format,png" alt="新建releases"><br>标题输入版本号，根据你的需求即可，比如我这里是v1.0<br>输入完毕后点击下方绿色按钮。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAdjEuMy9pbWFnZXMvMjAyMC8wNC9qc2RlbGl2ci0zLnBuZw?x-oss-process=image/format,png" alt="新建releases"><br>跳转到以下页面代表创建成功<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAdjEuMy9pbWFnZXMvMjAyMC8wNC9qc2RlbGl2ci00LnBuZw?x-oss-process=image/format,png" alt="新建releases"><br>根据jsDelivr的要求，文件路径为：<a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a><br>以我的为例，访问仓库目录下的jsdelivr-1.png文件，为以下链接：<br><a href="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@v1.3/images/2020/04/jsdelivr-1.png">https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@v1.3/images/2020/04/jsdelivr-1.png</a><br>可以正常访问，成功~<br>这种方案的优点是，可以区分版本，就算以后删掉了一些文件也可以通过旧的releases访问，而且可以及时更新缓存。<br>美中不足的是，每次仓库里更新资源后，需要发布个releases才能获取更新文件，并不是很方便，所以适合于存放基本不需要更新修改添加的静态文件。需要频繁修改或上传的文件不建议放到这里面来。</p>
<h2 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h2><p>根据jsDelivr的要求，文件路径为：<a href="https://cdn.jsdelivr.net/gh/user/repo/file">https://cdn.jsdelivr.net/gh/user/repo/file</a><br>以我的为例：<br><a href="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/2020/04/jsdelivr-1.png">https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/images/2020/04/jsdelivr-1.png</a><br>不推荐使用这种方法，暂未摸清如何更新缓存。</p>
<h2 id="访问最新文件"><a href="#访问最新文件" class="headerlink" title="访问最新文件"></a>访问最新文件</h2><p>根据jsDelivr的要求，文件路径为：<a href="https://cdn.jsdelivr.net/gh/user/repo@latest/file">https://cdn.jsdelivr.net/gh/user/repo@latest/file</a><br>以我的为例：<a href="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2020/04/jsdelivr-1.png">https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2020/04/jsdelivr-1.png</a><br>这种方案不需要发布releases，可以直接从repo读取文件，而且实时更新缓存。<br>但是官方并不推荐使用这种方法，因为修改repo的文件后，如果没有修改网站的旧链接，可能会出问题。根据你自己的情况决定吧。</p>
<h1 id="访问统计"><a href="#访问统计" class="headerlink" title="访问统计"></a>访问统计</h1><p>jsDelivr还提供了文件列表和文件访问统计页面：<br>文件列表：<a href="https://cdn.jsdelivr.net/gh/user/repo/">https://cdn.jsdelivr.net/gh/user/repo/</a><br>比如我的：<a href="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/">https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets/</a></p>
<p>访问统计：<a href="https://www.jsdelivr.com/package/gh/user/repo">https://www.jsdelivr.com/package/gh/user/repo</a><br>比如我的：<a href="https://www.jsdelivr.com/package/gh/HelloAllenW/BlogAssets">https://www.jsdelivr.com/package/gh/HelloAllenW/BlogAssets</a></p>
<h1 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h1><p>jsDelivr还提供了代码压缩服务，比如将JS/CSS的代码压缩，优化访问速度。<br>只是前几次访问会执行压缩操作，速度比较慢。后面就会将文件缓存，速度不会再慢了。<br>直接将访问链接的文件后缀改成.min.js即可，比如：<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA0L2pzZGVsaXZyLWRpdmlzaW9uLnBuZw?x-oss-process=image/format,png" alt="分割线"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经速度测试，访问速度非常快，有效提升整体速度，还能省下一大笔费用，实属优质白嫖~</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化详解</title>
    <url>/2023/08/01/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。<br>本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的CommonJS, AMD, ES6、CMD规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！<br><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2020/11/1101.png"></p>
<span id="more"></span>

<h1 id="一、模块化的理解"><a href="#一、模块化的理解" class="headerlink" title="一、模块化的理解"></a>一、模块化的理解</h1><ol>
<li>什么是模块?</li>
</ol>
<ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li>
</ul>
<ol start="2">
<li>模块化的发展过程</li>
</ol>
<ul>
<li><p>全局function模式 : 将不同的功能封装成不同的全局函数<br>① 编码: 将不同的功能封装成不同的全局函数<br>② 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">function m2()&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>namespace模式 : 简单对象封装<br>① 作用: 减少了全局变量，解决命名冲突<br>② 问题: 数据不安全(外部可以直接修改模块内部的数据)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myModule = &#123;</span><br><span class="line">  data: &#x27;www.baidu.com&#x27;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(`foo() $&#123;this.data&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  bar() &#123;</span><br><span class="line">    console.log(`bar() $&#123;this.data&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.data = &#x27;other data&#x27; //能直接修改模块内部的数据</span><br><span class="line">myModule.foo() // foo() other data</span><br></pre></td></tr></table></figure>
<p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p>
</li>
<li><p>IIFE模式：匿名函数自调用(闭包)<br>① 作用: 数据是私有的, 外部只能通过暴露的方法操作<br>② 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口<br>③ 问题: 如果当前这个模块依赖另一个模块怎么办?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">    myModule.bar()</span><br><span class="line">    console.log(myModule.data) //undefined 不能访问模块内部数据</span><br><span class="line">    myModule.data = &#x27;xxxx&#x27; //不是修改的模块内部的data</span><br><span class="line">    myModule.foo() //没有改变</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// module.js文件</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  let data = &#x27;www.baidu.com&#x27;</span><br><span class="line">  //操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`foo() $&#123;data&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`bar() $&#123;data&#125;`)</span><br><span class="line">    otherFun() //内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    //内部私有的函数</span><br><span class="line">    console.log(&#x27;otherFun()&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  //暴露行为</span><br><span class="line">  window.myModule = &#123; foo, bar &#125; //ES6写法</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>IIFE模式增强 : 引入依赖<br>这就是现代模块实现的基石<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// module.js文件</span><br><span class="line">(function(window, $) &#123;</span><br><span class="line">  let data = &#x27;www.baidu.com&#x27;</span><br><span class="line">  //操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`foo() $&#123;data&#125;`)</span><br><span class="line">    $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`bar() $&#123;data&#125;`)</span><br><span class="line">    otherFun() //内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    //内部私有的函数</span><br><span class="line">    console.log(&#x27;otherFun()&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  //暴露行为</span><br><span class="line">  window.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(window, jQuery)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line">  &lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</li>
</ul>
<ol start="3">
<li>模块化的优点</li>
</ol>
<ul>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
<ol start="4">
<li>引入多个<code>&lt;script&gt;</code>后出现出现问题</li>
</ol>
<ul>
<li>请求过多<br>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</li>
<li>依赖模糊<br>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</li>
<li>难以维护<br>以上原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。<br>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。</li>
</ul>
<h1 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>(1) 概述<br>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p>
<p>(2) 特点</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<p>(3) 基本语法</p>
<ul>
<li>暴露模块：module.exports = value或exports.xxx = value</li>
<li>引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li>
</ul>
<p>此处我们有个疑问：CommonJS暴露的模块到底是什么? CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = function (value) &#123;</span><br><span class="line">  return value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure>
<p>上面代码通过module.exports输出变量x和函数addX。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var example = require(&#x27;./example.js&#x27;);//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br></pre></td></tr></table></figure>
<p>require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p>
<p>(4) 模块的加载机制<br>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">var counter = 3;</span><br><span class="line">function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js</span><br><span class="line">var counter = require(&#x27;./lib&#x27;).counter;</span><br><span class="line">var incCounter = require(&#x27;./lib&#x27;).incCounter;</span><br><span class="line"></span><br><span class="line">console.log(counter);  // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 3</span><br></pre></td></tr></table></figure>
<p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<p>(5) 服务器端实现<br>① 下载安装node.js<br>② 创建项目结构<br>注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-modules</span><br><span class="line">  |-module1.js</span><br><span class="line">  |-module2.js</span><br><span class="line">  |-module3.js</span><br><span class="line">|-app.js</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;commonJS-node&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>③ 下载第三方模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install uniq --save // 用于数组去重</span><br></pre></td></tr></table></figure>
<p>④ 定义模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//module1.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  msg: &#x27;module1&#x27;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(this.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//module2.js</span><br><span class="line">module.exports = function() &#123;</span><br><span class="line">  console.log(&#x27;module2&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//module3.js</span><br><span class="line">exports.foo = function() &#123;</span><br><span class="line">  console.log(&#x27;foo() module3&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">exports.arr = [1, 2, 3, 3, 2]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// app.js文件</span><br><span class="line">// 引入第三方库，应该放置在最前面</span><br><span class="line">let uniq = require(&#x27;uniq&#x27;)</span><br><span class="line">let module1 = require(&#x27;./modules/module1&#x27;)</span><br><span class="line">let module2 = require(&#x27;./modules/module2&#x27;)</span><br><span class="line">let module3 = require(&#x27;./modules/module3&#x27;)</span><br><span class="line"></span><br><span class="line">module1.foo() //module1</span><br><span class="line">module2() //module2</span><br><span class="line">module3.foo() //foo() module3</span><br><span class="line">console.log(uniq(module3.arr)) //[ 1, 2, 3 ]</span><br></pre></td></tr></table></figure>
<p>⑤ 通过node运行app.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令行输入node app.js，运行JS文件</span><br></pre></td></tr></table></figure>

<p>(6) 浏览器端实现(借助Browserify)<br>① 创建项目结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-dist //打包生成文件的目录</span><br><span class="line">  |-src //源码所在的目录</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-app.js //应用主源文件</span><br><span class="line">|-index.html //运行于浏览器上</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;browserify-test&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>② 下载browserify</p>
<ul>
<li>全局: npm install browserify -g</li>
<li>局部: npm install browserify –save-dev</li>
</ul>
<p>③ 定义模块代码(同服务器端)<br>注意：index.html文件要运行在浏览器上，需要借助browserify将app.js文件打包编译，如果直接在index.html引入app.js就会报错！</p>
<p>④ 打包处理js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根目录下运行browserify js/src/app.js -o js/dist/bundle.js</span><br></pre></td></tr></table></figure>

<p>⑤ 页面使用引入<br>在index.html文件中引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p>
<p>(1) AMD规范基本语法</p>
<p>定义暴露模块:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义没有依赖的模块</span><br><span class="line">define(function()&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义有依赖的模块</span><br><span class="line">define([&#x27;module1&#x27;, &#x27;module2&#x27;], function(m1, m2)&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>引入使用模块:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require([&#x27;module1&#x27;, &#x27;module2&#x27;], function(m1, m2)&#123;</span><br><span class="line">   使用m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>(2) 未使用AMD规范与使用require.js</p>
<p>通过比较两者的实现方法，来说明使用AMD规范的好处。</p>
<ul>
<li><p>未使用AMD规范</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// dataService.js文件</span><br><span class="line">(function (window) &#123;</span><br><span class="line">  let msg = &#x27;www.baidu.com&#x27;</span><br><span class="line">  function getMsg() &#123;</span><br><span class="line">    return msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  window.dataService = &#123;getMsg&#125;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// alerter.js文件</span><br><span class="line">(function (window, dataService) &#123;</span><br><span class="line">  let name = &#x27;Tom&#x27;</span><br><span class="line">  function showMsg() &#123;</span><br><span class="line">    alert(dataService.getMsg() + &#x27;, &#x27; + name)</span><br><span class="line">  &#125;</span><br><span class="line">  window.alerter = &#123;showMsg&#125;</span><br><span class="line">&#125;)(window, dataService)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js文件</span><br><span class="line">(function (alerter) &#123;</span><br><span class="line">  alerter.showMsg()</span><br><span class="line">&#125;)(alerter)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line">&lt;div&gt;&lt;h1&gt;Modular Demo 1: 未使用AMD(require.js)&lt;/h1&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/modules/dataService.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/modules/alerter.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式缺点很明显：首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！</p>
</li>
<li><p>使用require.js</p>
</li>
</ul>
<p>RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。<br>接下来介绍AMD规范在浏览器实现的步骤：</p>
<p>① 下载require.js, 并引入</p>
<ul>
<li>官网: <a href="http://www.requirejs.cn/">http://www.requirejs.cn/</a></li>
<li>github : <a href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li>
</ul>
<p>然后将require.js导入项目: js/libs/require.js</p>
<p>② 创建项目结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-require.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-alerter.js</span><br><span class="line">    |-dataService.js</span><br><span class="line">  |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>
<p>③ 定义require.js的模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// dataService.js文件</span><br><span class="line">// 定义没有依赖的模块</span><br><span class="line">define(function() &#123;</span><br><span class="line">  let msg = &#x27;www.baidu.com&#x27;</span><br><span class="line">  function getMsg() &#123;</span><br><span class="line">    return msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123; getMsg &#125; // 暴露模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//alerter.js文件</span><br><span class="line">// 定义有依赖的模块</span><br><span class="line">define([&#x27;dataService&#x27;], function(dataService) &#123;</span><br><span class="line">  let name = &#x27;Tom&#x27;</span><br><span class="line">  function showMsg() &#123;</span><br><span class="line">    alert(dataService.getMsg() + &#x27;, &#x27; + name)</span><br><span class="line">  &#125;</span><br><span class="line">  // 暴露模块</span><br><span class="line">  return &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js文件</span><br><span class="line">(function() &#123;</span><br><span class="line">  require.config(&#123;</span><br><span class="line">    baseUrl: &#x27;js/&#x27;, //基本路径 出发点在根目录下</span><br><span class="line">    paths: &#123;</span><br><span class="line">      //映射: 模块标识名: 路径</span><br><span class="line">      alerter: &#x27;./modules/alerter&#x27;, //此处不能写成alerter.js,会报错</span><br><span class="line">      dataService: &#x27;./modules/dataService&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  require([&#x27;alerter&#x27;], function(alerter) &#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Modular Demo&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span><br><span class="line">    &lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>④ 页面引入require.js模块:</p>
<p>在index.html引入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>此外在项目中如何引入第三方库？</strong>只需在上面代码的基础稍作修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// alerter.js文件</span><br><span class="line">define([&#x27;dataService&#x27;, &#x27;jquery&#x27;], function(dataService, $) &#123;</span><br><span class="line">  let name = &#x27;Tom&#x27;</span><br><span class="line">  function showMsg() &#123;</span><br><span class="line">    alert(dataService.getMsg() + &#x27;, &#x27; + name)</span><br><span class="line">  &#125;</span><br><span class="line">  $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;green&#x27;)</span><br><span class="line">  // 暴露模块</span><br><span class="line">  return &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js文件</span><br><span class="line">(function() &#123;</span><br><span class="line">  require.config(&#123;</span><br><span class="line">    baseUrl: &#x27;js/&#x27;, //基本路径 出发点在根目录下</span><br><span class="line">    paths: &#123;</span><br><span class="line">      //自定义模块</span><br><span class="line">      alerter: &#x27;./modules/alerter&#x27;, //此处不能写成alerter.js,会报错</span><br><span class="line">      dataService: &#x27;./modules/dataService&#x27;,</span><br><span class="line">      // 第三方库模块</span><br><span class="line">      jquery: &#x27;./libs/jquery-1.10.1&#x27; //注意：写成jQuery会报错</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  require([&#x27;alerter&#x27;], function(alerter) &#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。<br>小结：通过两者的比较，可以得出AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p>
<p>(1) CMD规范基本语法<br>定义暴露模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义没有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  module.exports = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  //引入依赖模块(同步)</span><br><span class="line">  var module2 = require(&#x27;./module2&#x27;)</span><br><span class="line">  //引入依赖模块(异步)</span><br><span class="line">    require.async(&#x27;./module3&#x27;, function (m3) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  //暴露模块</span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>引入使用模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define(function (require) &#123;</span><br><span class="line">  var m1 = require(&#x27;./module1&#x27;)</span><br><span class="line">  var m4 = require(&#x27;./module4&#x27;)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>(2) sea.js简单使用教程</p>
<p>① 下载sea.js, 并引入</p>
<ul>
<li>官网: <a href="http://seajs.org/">http://seajs.org/</a></li>
<li>github : <a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li>
</ul>
<p>然后将sea.js导入项目: js/libs/sea.js</p>
<p>② 创建项目结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-sea.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-module4.js</span><br><span class="line">    |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>
<p>③ 定义sea.js的模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// module1.js文件</span><br><span class="line">define(function (require, exports, module) &#123;</span><br><span class="line">  //内部变量数据</span><br><span class="line">  var data = &#x27;atguigu.com&#x27;</span><br><span class="line">  //内部函数</span><br><span class="line">  function show() &#123;</span><br><span class="line">    console.log(&#x27;module1 show() &#x27; + data)</span><br><span class="line">  &#125;</span><br><span class="line">  //向外暴露</span><br><span class="line">  exports.show = show</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// module2.js文件</span><br><span class="line">define(function (require, exports, module) &#123;</span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    msg: &#x27;I Will Back&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// module3.js文件</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  const API_KEY = &#x27;abc123&#x27;</span><br><span class="line">  exports.API_KEY = API_KEY</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// module4.js文件</span><br><span class="line">define(function (require, exports, module) &#123;</span><br><span class="line">  //引入依赖模块(同步)</span><br><span class="line">  var module2 = require(&#x27;./module2&#x27;)</span><br><span class="line">  function show() &#123;</span><br><span class="line">    console.log(&#x27;module4 show() &#x27; + module2.msg)</span><br><span class="line">  &#125;</span><br><span class="line">  exports.show = show</span><br><span class="line">  //引入依赖模块(异步)</span><br><span class="line">  require.async(&#x27;./module3&#x27;, function (m3) &#123;</span><br><span class="line">    console.log(&#x27;异步引入依赖模块3  &#x27; + m3.API_KEY)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js文件</span><br><span class="line">define(function (require) &#123;</span><br><span class="line">  var m1 = require(&#x27;./module1&#x27;)</span><br><span class="line">  var m4 = require(&#x27;./module4&#x27;)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>④ 在index.html中引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/libs/sea.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  seajs.use(&#x27;./js/modules/main&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h2><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<p>(1) ES6模块化语法</p>
<p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;</span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from &#x27;./math&#x27;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&#x27;foo&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// import-default.js</span><br><span class="line">import customName from &#x27;./export-default&#x27;;</span><br><span class="line">customName(); // &#x27;foo&#x27;</span><br></pre></td></tr></table></figure>
<p>模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<p>(2) ES6 模块与 CommonJS 模块的差异</p>
<p>它们有两个重大差异：</p>
<p>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。<br>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">export let counter = 3;</span><br><span class="line">export function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">// main.js</span><br><span class="line">import &#123; counter, incCounter &#125; from &#x27;./lib&#x27;;</span><br><span class="line">console.log(counter); // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 4</span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<p>(3) ES6-Babel-Browserify使用教程</p>
<p>简单来说就一句话：使用Babel将ES6编译为ES5代码，使用Browserify编译打包js。</p>
<p>① 定义package.json文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;es6-babel-browserify&quot;,</span><br><span class="line">  &quot;version&quot; : &quot;1.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 安装babel-cli, babel-preset-es2015和browserify</p>
<ul>
<li>npm install babel-cli browserify -g</li>
<li>npm install babel-preset-es2015 –save-dev</li>
<li>preset 预设(将es6转换成es5的所有插件打包)</li>
</ul>
<p>③ 定义.babelrc文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;presets&quot;: [&quot;es2015&quot;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>④ 定义模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//module1.js文件</span><br><span class="line">// 分别暴露</span><br><span class="line">export function foo() &#123;</span><br><span class="line">  console.log(&#x27;foo() module1&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">export function bar() &#123;</span><br><span class="line">  console.log(&#x27;bar() module1&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//module2.js文件</span><br><span class="line">// 统一暴露</span><br><span class="line">function fun1() &#123;</span><br><span class="line">  console.log(&#x27;fun1() module2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function fun2() &#123;</span><br><span class="line">  console.log(&#x27;fun2() module2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">export &#123; fun1, fun2 &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//module3.js文件</span><br><span class="line">// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据</span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;默认暴露&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// app.js文件</span><br><span class="line">import &#123; foo, bar &#125; from &#x27;./module1&#x27;</span><br><span class="line">import &#123; fun1, fun2 &#125; from &#x27;./module2&#x27;</span><br><span class="line">import module3 from &#x27;./module3&#x27;</span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br><span class="line">module3()</span><br></pre></td></tr></table></figure>
<p>⑤ 编译并在index.html中引入</p>
<ul>
<li>使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib</li>
<li>使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js</li>
</ul>
<p>然后在index.html文件中引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/lib/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外第三方库(以jQuery为例)如何引入呢？</p>
<p>首先安装依赖npm install jquery@1<br>然后在app.js文件中引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//app.js文件</span><br><span class="line">import &#123; foo, bar &#125; from &#x27;./module1&#x27;</span><br><span class="line">import &#123; fun1, fun2 &#125; from &#x27;./module2&#x27;</span><br><span class="line">import module3 from &#x27;./module3&#x27;</span><br><span class="line">import $ from &#x27;jquery&#x27;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br><span class="line">module3()</span><br><span class="line">$(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;green&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li>
<li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li>
<li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li>
<li>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
</ul>
<blockquote>
<p>原文链接：<a href="https://github.com/ljianshu/Blog/issues/48">https://github.com/ljianshu/Blog/issues/48</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端神器：BrowserSync &amp; live-server</title>
    <url>/2020/11/09/%E5%89%8D%E7%AB%AF%E7%A5%9E%E5%99%A8%EF%BC%9ABrowserSync-live-server/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍博主使用过的两种web小型开发服务器，可以用来热加载HTML / JavaScript / CSS文件。</p>
</blockquote>
<h1 id="browserSync"><a href="#browserSync" class="headerlink" title="browserSync"></a>browserSync</h1><p><a href="http://www.browsersync.cn/">browsersync</a>：浏览器同步测试工具，简单来说就是当你保存文件的同时浏览器会自动刷新网页。省去了手动刷新网页的环节，大大的节省了开发时间，这个工具是基于nodejs的，可以通过npm安装。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在开始菜单找到<strong>node.js command prompt</strong>打开，输入安装命令：<br><code>npm install -g browser-sync</code></p>
<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通过命令行工具，进入到项目根目录下，输入如下命令：<br>1、如果是纯静态站点（也就是仅仅一些.html文件的情况）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表示监听整个项目</span><br><span class="line">browser-sync strat --server --files &quot;***.html, ***&quot; </span><br></pre></td></tr></table></figure>
<p>BrowserSync会自动提供一个新地址（如未被占用的话，默认<a href="http://localhost:3000）用于访问。">http://localhost:3000）用于访问。</a></p>
<p>2、如果是动态站点（使用代理模式）：<br>例如PHP站点，已经建立了一个本地服务器如<a href="http://localhost:8080，此时输入如下命令：">http://localhost:8080，此时输入如下命令：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">browser-sync start --proxy &quot;localhost:8080&quot; --files &quot;css/*.css&quot;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1、注意事项<br>项目根目录下必须要有一个index.html文件，不然会报错：Cannot GET /<br>另外也可以通过gulp使用这个工具，Gulp是现在流行的自动化工具。参考<a href="https://www.cnblogs.com/Tom-yi/p/8036730.html">gulp新手入门教程</a></p>
<p>2、修改配置文件<br>在命令行工具中输入：<strong>browser-sync</strong>，你会看到起完整的控制台命令指南。其中有一个：<strong>browser-sync init</strong>。 运行它，将在当前目录生成一个配置文件<strong>bs-config.js</strong>。参考官方文档修改这个文件，然后运行：</p>
<figure class="highlight plaintext"><figcaption><span>start --config bs-config.js```就将以其完整配置信息运行BrowserSync。使用**ctrl+c**可以终止当前目录，清空用**cls**命令</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># live-server</span><br><span class="line">live-server是一个具有实时重载功能的小型开发服务器。用它来热加载HTML / JavaScript / CSS文件，但不能用于部署最终的网站系统。</span><br><span class="line">## 安装</span><br><span class="line">1、前提条件需要node.js和npm的依赖（可以自己先搞定，不难）；</span><br><span class="line"></span><br><span class="line">2、使用npm全局安装：```npm install -g live-server```</span><br><span class="line"></span><br><span class="line">## 使用</span><br><span class="line">在所在项目目录下，打开命令行工具，输入 **live-server**，回车就可以了（注意这里默认打开的是**index.html**）。接着就会看到打开了一个**127.0.0.1:8080**的网页。退出该服务器，在命令行使用：**ctrl+c**</span><br><span class="line"></span><br><span class="line">## 配置</span><br><span class="line">1、默认端口号为8080，如果想修改，最简单的方式是启动的时候添加启动参数：```live-server --port=8081```即可</span><br><span class="line"></span><br><span class="line">2、在**package.json**中进行配置</span><br><span class="line"></span><br><span class="line">（1）初始化项目**npm init**，之后会自动生成一个管理第三方依赖包的package.json</span><br><span class="line"></span><br><span class="line">（2）修改package.json中scripts部分</span><br></pre></td></tr></table></figure>
<p>“scripts”: {<br>    “server”: “live-server ./ –port=8081”<br> }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">或者</span><br></pre></td></tr></table></figure>
<p>“scripts”: {<br>    “server”: “live-server 某个目录”<br>}</p>
<p>```</p>
<p>（3）通过<code>npm run server</code>启动</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>国际化插件i18n和vuex的混合使用</title>
    <url>/2020/11/09/%E5%9B%BD%E9%99%85%E5%8C%96%E6%8F%92%E4%BB%B6i18n%E5%92%8Cvuex%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>前段时间测试对于项目切换中英文后页面会闪一下标为bug，想了想肯定是前任开发者在切换中英文后对页面进行了强制刷新。查看源码发现果不其然，并且前任仅将中英文状态存储在cookie中，然后在需要的组件中通过cookie获取中英文状态。发现接口都是同时有返回中英文，这样完全可以通过vuex全局状态管理中英文状态，达到在一处修改了中英文后全局自动修改。</p>
<blockquote>
<p>本文以 vue+ElementUI 并且以和vue组合的 vue-i18n 为例</p>
</blockquote>
<span id="more"></span>

<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p><strong>1、安装相关插件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装 vue-i18n</span><br><span class="line">npm install --save vue-i18n</span><br><span class="line">// 安装 js-cookie</span><br><span class="line">npm install --save js-cookie</span><br><span class="line">// 安装 vuex</span><br><span class="line">npm install --save vuex</span><br></pre></td></tr></table></figure>
<p><strong>2、目录结构</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0hlbGxvQWxsZW5XL0Jsb2dBc3NldHNAbGF0ZXN0L2ltYWdlcy8yMDIwLzA2L2JnNi01LTYucG5n?x-oss-process=image/format,png" alt="目录结构"></p>
<h1 id="国际化部分"><a href="#国际化部分" class="headerlink" title="国际化部分"></a>国际化部分</h1><h2 id="i18n-封装"><a href="#i18n-封装" class="headerlink" title="i18n 封装"></a>i18n 封装</h2><blockquote>
<p>将i18n的引入与注册实例封装在了./langs/index.js中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueI18n from &#x27;vue-i18n&#x27;</span><br><span class="line">import Cookies from &#x27;js-cookie&#x27;</span><br><span class="line">import elementEnLocale from &#x27;element-ui/lib/locale/lang/en&#x27;</span><br><span class="line">import elementZhLocale from &#x27;element-ui/lib/locale/lang/zh-CN&#x27;</span><br><span class="line">import enLocale from &#x27;./en&#x27;</span><br><span class="line">import zhLocale from &#x27;./zh&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(VueI18n)</span><br><span class="line"></span><br><span class="line">const messages = &#123;</span><br><span class="line">  en: &#123;</span><br><span class="line">    ...enLocale,</span><br><span class="line">    ...elementEnLocale</span><br><span class="line">  &#125;,</span><br><span class="line">  zh: &#123;</span><br><span class="line">    ...zhLocale,</span><br><span class="line">    ...elementZhLocale</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export function getLanguage() &#123;</span><br><span class="line">  const chooseLanguage = Cookies.get(&#x27;language&#x27;)</span><br><span class="line">  if (chooseLanguage) return chooseLanguage</span><br><span class="line"></span><br><span class="line">  // if has not choose language</span><br><span class="line">  const language = (navigator.language || navigator.browserLanguage).toLowerCase()</span><br><span class="line">  const locales = Object.keys(messages)</span><br><span class="line">  for (const locale of locales) &#123;</span><br><span class="line">    if (language.indexOf(locale) &gt; -1) &#123;</span><br><span class="line">      return locale</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#x27;en&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const i18n = new VueI18n(&#123;</span><br><span class="line">  locale: getLanguage(),</span><br><span class="line">  // set locale messages</span><br><span class="line">  messages</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default i18n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="语言配置样例"><a href="#语言配置样例" class="headerlink" title="语言配置样例"></a>语言配置样例</h2><blockquote>
<p>en.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  settings: &#123;</span><br><span class="line">    title: &#x27;Page style setting&#x27;,</span><br><span class="line">    theme: &#x27;Theme Color&#x27;,</span><br><span class="line">    tagsView: &#x27;Open Tags-View&#x27;,</span><br><span class="line">    fixedHeader: &#x27;Fixed Header&#x27;,</span><br><span class="line">    sidebarLogo: &#x27;Sidebar Logo&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>zh.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  settings: &#123;</span><br><span class="line">    title: &#x27;系统布局配置&#x27;,</span><br><span class="line">    theme: &#x27;主题色&#x27;,</span><br><span class="line">    tagsView: &#x27;开启 Tags-View&#x27;,</span><br><span class="line">    fixedHeader: &#x27;固定 Header&#x27;,</span><br><span class="line">    sidebarLogo: &#x27;侧边栏 Logo&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><blockquote>
<p>通过vuex实现国际化状态切换状态管理功能</p>
</blockquote>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><blockquote>
<p>./store/index.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">import getters from &#x27;./getters&#x27;</span><br><span class="line">// 使用vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">// 这种方式很好的将modules中的所有文件全部导出，这样以后修改modules不用再在此处进行添加导出</span><br><span class="line">const modulesFiles = require.context(&#x27;./modules&#x27;, true, /\.js$/)</span><br><span class="line">const modules = modulesFiles.keys().reduce((modules, modulePath) =&gt; &#123;</span><br><span class="line">  const moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, &#x27;$1&#x27;)</span><br><span class="line">  const value = modulesFiles(modulePath)</span><br><span class="line">  modules[moduleName] = value.default</span><br><span class="line">  return modules</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// 创建vuex实例</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default store</span><br></pre></td></tr></table></figure>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><blockquote>
<p>./store/getters.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 监听 vuex 中state下language的改变</span><br><span class="line">// 外部通过 this.$store.getters.language 调用</span><br><span class="line">const getters = &#123;</span><br><span class="line">  language: state =&gt; state.app.language,</span><br><span class="line">&#125;</span><br><span class="line">export default getters</span><br></pre></td></tr></table></figure>
<h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2><blockquote>
<p>./store/modules/app.js<br>单独建立一个app.js的目的是以后如果需要扩展其他的全局状态，可以封装在其他独立的js中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取当前国际化状态封装在了上面的./langs/index.js中，相当于是初始化国际化</span><br><span class="line">import &#123; getLanguage &#125; from &#x27;@/i18n/langs/index&#x27;</span><br><span class="line">import Cookies from &#x27;js-cookie&#x27;</span><br><span class="line">// 数据，外部可以通过 this.$store.state.language 调用</span><br><span class="line">const state = &#123;</span><br><span class="line">  language: getLanguage()</span><br><span class="line">&#125;</span><br><span class="line">// 外部可以通过提交mutation来修改state中的值</span><br><span class="line">// this.$store.commit(&quot;SET_LANGUAGE&quot;)</span><br><span class="line">const mutations = &#123;</span><br><span class="line">  SET_LANGUAGE: (state, language) =&gt; &#123;</span><br><span class="line">    // 修改state并将其保存在Cookies中，这样用户下次打开仍然是上次选择的国际化状态</span><br><span class="line">    state.language = language</span><br><span class="line">    Cookies.set(&#x27;language&#x27;, language)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">// 官方推荐我们去提交一个actions，在actions中提交mutation再去修改state</span><br><span class="line">// this.$store.dispatch(&quot;setLanguage&quot;)</span><br><span class="line">const actions = &#123;</span><br><span class="line">  setLanguage(&#123; commit &#125;, language) &#123;</span><br><span class="line">    commit(&#x27;SET_LANGUAGE&#x27;, language)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><blockquote>
<p>main.js配置导入</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="line">// 导入封装的i18n配置</span><br><span class="line">import i18n from &#x27;./i18n/langs&#x27;;</span><br><span class="line">import Cookies from &#x27;js-cookie&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line"></span><br><span class="line">// 应用</span><br><span class="line">Vue.use(ElementUI, &#123;</span><br><span class="line">  i18n: (key, value) =&gt; i18n.t(key, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 将i18n、store注入到vue实例中</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  router,</span><br><span class="line">  i18n,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>1、切换语言，向vuex的actions提交改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dropdown trigger=&quot;click&quot; class=&quot;international&quot; @command=&quot;handleSetLanguage&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;svg-icon class-name=&quot;international-icon&quot; icon-class=&quot;language&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;</span><br><span class="line">      &lt;el-dropdown-item :disabled=&quot;language===&#x27;zh&#x27;&quot; command=&quot;zh&quot;&gt;</span><br><span class="line">        中文</span><br><span class="line">      &lt;/el-dropdown-item&gt;</span><br><span class="line">      &lt;el-dropdown-item :disabled=&quot;language===&#x27;en&#x27;&quot; command=&quot;en&quot;&gt;</span><br><span class="line">        English</span><br><span class="line">      &lt;/el-dropdown-item&gt;</span><br><span class="line">    &lt;/el-dropdown-menu&gt;</span><br><span class="line">  &lt;/el-dropdown&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    language() &#123;</span><br><span class="line">      return this.$store.getters.language</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSetLanguage(lang) &#123;</span><br><span class="line">      // 设置i18n，以便后面通过$t(&#x27;settings.title&#x27;)使用</span><br><span class="line">      this.$i18n.locale = lang</span><br><span class="line">      // 向vuex提交修改后的国际化，以便后面获取</span><br><span class="line">      this.$store.dispatch(&#x27;app/setLanguage&#x27;, lang)</span><br><span class="line">      this.$message(&#123;</span><br><span class="line">        message: &#x27;Switch Language Success&#x27;,</span><br><span class="line">        type: &#x27;success&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、在需要的组件中使用与获取国际化状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// html中使用</span><br><span class="line">&#123;&#123; $t(&#x27;settings.title&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">// js中使用</span><br><span class="line">$t(&#x27;settings.title&#x27;)</span><br><span class="line"></span><br><span class="line">// 通过computed获取vuex中的language状态，这样其他地方修改后这边可以监测到，并同步修改DOM中的值</span><br><span class="line">computed: &#123;</span><br><span class="line">    language() &#123;</span><br><span class="line">      return this.$store.getters.language</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>学习正则表达式，看我就够了</title>
    <url>/2020/11/09/%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<p>本文旨在用最通俗的语言讲述最枯燥的基本知识。</p>
<blockquote>
<p>文章提纲：<br>1、元字符<br>2、重复限定符<br>3、分组<br>4、转义<br>5、条件或<br>6、区间<br>7、零宽断言<br>8、捕获和非捕获<br>9、反向引用<br>10、贪婪和非贪婪<br>11、反义</p>
</blockquote>
<p>正则表达式在几乎所有语言中都可以使用，无论是前端的 JavaScript、还是后端的 Java、c#。他们都提供相应的接口 / 函数支持正则表达式。<br>但很神奇的是：无论你大学选择哪一门计算机语言，都没有关于正则表达式的课程给你修，在你学会正则之前，你只能看着那些正则大师们，写了一串外星文似的字符串，替代了你用一大篇幅的 if else 代码来做一些数据校验。<br>既然喜欢，那就动手学呗，可当你百度出一一堆相关资料时，你发现无一不例外的枯燥至极，难以学习（实话说，当年不理君也是这样的心态）。<br>下面，不理君尝试用一种比较通俗点的方式讲一下正则，让你能在读完之后，能自己写出一些简单的正则，再不济，能看懂别人写的正则，那也不错了。</p>
<span id="more"></span>

<h1 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1. 元字符"></a>1. 元字符</h1><p>万物皆有缘，正则也是如此，元字符是构造正则表达式的一种基本元素。<br>我们先来记几个常用的元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结束</td>
</tr>
</tbody></table>
<p>有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，比如：<br>匹配有abc开头的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\babc或者^abc</span><br></pre></td></tr></table></figure>
<p>匹配8位数字的QQ号码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d\d\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure>
<p>匹配1开头11位数字的手机号码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^1\d\d\d\d\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure>

<h1 id="2-重复限定符"><a href="#2-重复限定符" class="headerlink" title="2. 重复限定符"></a>2. 重复限定符</h1><p>有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？<br>答案是有的！<br>为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：</p>
<p>匹配8位数字的QQ号码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<p>匹配1开头11位数字的手机号码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^1\d&#123;10&#125;$</span><br></pre></td></tr></table></figure>

<p>匹配银行卡号是14~18位的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\d&#123;14,18&#125;$</span><br></pre></td></tr></table></figure>

<p>匹配以a开头的，0个或多个b结尾的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></table></figure>

<h1 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h1><p>从上面的例子（4）中看到，限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要 ab 同时被限定那怎么办呢？<br>正则表达式中用小括号 () 来做分组，也就是括号中的内容作为一个整体。<br>因此当我们要匹配多个 ab 时，我们可以这样。<br>如：匹配字符串中包含 0 到多个 ab 开头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(ab)*</span><br></pre></td></tr></table></figure>

<h1 id="4-转义"><a href="#4-转义" class="headerlink" title="4. 转义"></a>4. 转义</h1><p>我们看到正则表达式用小括号来做分组，那么问题来了：<br>如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？<br>针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。如：要匹配以 (ab) 开头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(\(ab\))*</span><br></pre></td></tr></table></figure>

<h1 id="5-条件或"><a href="#5-条件或" class="headerlink" title="5. 条件或"></a>5. 条件或</h1><p>回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有 130/131/132/155/156/185/186/145/176 等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？<br>正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。<br>那么我们就可以用或条件来处理这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(130|131|132|155|156|185|186|145|176)\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<h1 id="6-区间"><a href="#6-区间" class="headerlink" title="6. 区间"></a>6. 区间</h1><p>看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？</p>
<p>实际是有的。</p>
<p>正则提供了一个元字符中括号[]来表示区间条件。</p>
<p>限定0到9可以写成 [0-9]</p>
<p>限定A-Z写成[A-Z]</p>
<p>限定某些数字[165]</p>
<p>那上面的正则我们还改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^((13[0-2])|(15[56])|(18[5-6])|145|176)\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<h1 id="7-零宽断言"><a href="#7-零宽断言" class="headerlink" title="7. 零宽断言"></a>7. 零宽断言</h1><p>无论是零宽还是断言，听起来都古古怪怪的，那先解释一下这两个词。</p>
<p><em>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”, 正则可以用断言找出 aa2 前面有 bb3，也可以找出 aa2 后面有 ss1.</em></p>
<p><em>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</em></p>
<p>意思是讲明白了，那他有什么用呢？</p>
<p>我们来举个栗子：</p>
<p>假设我们要用爬虫抓取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其中只有‘641’这个是一个变量，也就是不同文章有不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果使用正则应该怎么匹配呢？</p>
<p>下面先讲一下几种类型的断言：</p>
<ul>
<li>正向先行断言（正前瞻）<br>语法：<code>（?=pattern）</code></li>
</ul>
<p>作用：匹配 pattern 表达式的前面内容，不返回本身。</p>
<p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘</span>’前面的数字内容按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=</span>) 就可以匹配到前面的内容了。匹配什么内容呢？如果要所有内容那就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String reg=&quot;.+(?=&lt;/span&gt;)&quot;;</span><br><span class="line"></span><br><span class="line">String test = &quot;&lt;span class=\&quot;read-count\&quot;&gt;阅读数：641&lt;/span&gt;&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=    pattern.matcher(test);</span><br><span class="line">while(mc.find())&#123;</span><br><span class="line">  System.out.println(&quot;匹配结果：&quot;)</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//匹配结果：</span><br><span class="line">//&lt;span class=&quot;read-count&quot;&gt;阅读数：641</span><br></pre></td></tr></table></figure>
<p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d, 那可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String reg=&quot;\\d+(?=&lt;/span&gt;)&quot;;</span><br><span class="line">String test = &quot;&lt;span class=\&quot;read-count\&quot;&gt;阅读数：641&lt;/span&gt;&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=    pattern.matcher(test);</span><br><span class="line">while(mc.find())&#123;</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line">//匹配结果：</span><br><span class="line">//641</span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<ul>
<li>正向后行断言（正后顾）<br>语法：<code>（?&lt;=pattern）</code></li>
</ul>
<p>作用：匹配 pattern 表达式的后面的内容，不返回本身。</p>
<p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。<br>上面的栗子，我们也可以用后行断言来处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//(?&lt;=&lt;span class=&quot;read-count&quot;&gt;阅读数：)\d+</span><br><span class="line">String reg=&quot;(?&lt;=&lt;span class=\&quot;read-count\&quot;&gt;阅读数：)\\d+&quot;;</span><br><span class="line"></span><br><span class="line">String test = &quot;&lt;span class=\&quot;read-count\&quot;&gt;阅读数：641&lt;/span&gt;&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher mc=    pattern.matcher(test);</span><br><span class="line">        while(mc.find())&#123;</span><br><span class="line">            System.out.println(mc.group());</span><br><span class="line">        &#125;</span><br><span class="line">//匹配结果：</span><br><span class="line">//641</span><br></pre></td></tr></table></figure>
<p>就这么简单。</p>
<ul>
<li>负向先行断言（负前瞻）<br>语法：<code>(?!pattern)</code></li>
</ul>
<p>作用：匹配非 pattern 表达式的前面内容，不返回本身。</p>
<p>有正向也有负向，负向在这里其实就是非的意思。</p>
<p>举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”</p>
<p>现在要找到不是’的花朵’前面的祖国</p>
<p>用正则就可以这样写：</p>
<p><code>祖国(?!的花朵)</code></p>
<ul>
<li>负向后行断言（负后顾）<br>语法：<code>(?&lt;!pattern)</code></li>
</ul>
<p>作用：匹配非 pattern 表达式的后面内容，不返回本身。</p>
<h1 id="8-捕获和非捕获"><a href="#8-捕获和非捕获" class="headerlink" title="8. 捕获和非捕获"></a>8. 捕获和非捕获</h1><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”。</p>
<p><em>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</em></p>
<p>而根据命名方式的不同，又可以分为两种组：</p>
<ul>
<li>数字编号捕获组：<br>语法：<code>(exp)</code></li>
</ul>
<p>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第 0 组为整个表达式，第一组开始为分组。</p>
<p>比如固定电话的：020-85653333</p>
<p>他的正则表达式为：<code>(0\d&#123;2&#125;)-(\d&#123;8&#125;)</code></p>
<p>按照左括号的顺序，这个表达式有如下分组：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
<tr>
<td>我们用Java来验证一下：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String test = &quot;020-85653333&quot;;</span><br><span class="line">        String reg=&quot;(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)&quot;;</span><br><span class="line">        Pattern pattern = Pattern.compile(reg);</span><br><span class="line">        Matcher mc= pattern.matcher(test);</span><br><span class="line">        if(mc.find())&#123;</span><br><span class="line">            System.out.println(&quot;分组的个数有：&quot;+mc.groupCount());</span><br><span class="line">            for(int i=0;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot;+i+&quot;个分组为：&quot;+mc.group(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：020</span><br><span class="line">第2个分组为：85653333</span><br></pre></td></tr></table></figure>
<p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p>
<ul>
<li>命名编号捕获组<br>语法：<code>(?&lt;name&gt;exp)</code></li>
</ul>
<p>解释：分组的命名由表达式中的 name 指定</p>
<p>比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})，按照左括号的顺序，这个表达式有如下分组：</p>
<p>序号|名称|分组|内容<br>|——-|——-|——-|——-|<br>|0|0|(0\d{2})-(\d{8})|020-85653333<br>|1|quhao|(0\d{2})|020<br>|2|haoma|(\d{8})|85653333<br>用代码来验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String test = &quot;020-85653333&quot;;</span><br><span class="line">        String reg=&quot;(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)&quot;;</span><br><span class="line">        Pattern pattern = Pattern.compile(reg);</span><br><span class="line">        Matcher mc= pattern.matcher(test);</span><br><span class="line">        if(mc.find())&#123;</span><br><span class="line">            System.out.println(&quot;分组的个数有：&quot;+mc.groupCount());</span><br><span class="line">            System.out.println(mc.group(&quot;quhao&quot;));</span><br><span class="line">            System.out.println(mc.group(&quot;haoma&quot;));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">分组名称为:quhao,匹配内容为：020</span><br><span class="line"></span><br><span class="line">分组名称为:haoma,匹配内容为：85653333</span><br></pre></td></tr></table></figure>
<ul>
<li>非捕获组<br>语法：<code>(?:exp)</code></li>
</ul>
<p>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</p>
<p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?:\0\d&#123;2&#125;)-(\d&#123;8&#125;)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
<tr>
<td>验证一下：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String test = &quot;020-85653333&quot;;</span><br><span class="line">        String reg=&quot;(?:0\\d&#123;2&#125;)-(\\d&#123;8&#125;)&quot;;</span><br><span class="line">        Pattern pattern = Pattern.compile(reg);</span><br><span class="line">        Matcher mc= pattern.matcher(test);</span><br><span class="line">        if(mc.find())&#123;</span><br><span class="line">                System.out.println(&quot;分组的个数有：&quot;+mc.groupCount());</span><br><span class="line">                for(int i=0;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line">                    System.out.println(&quot;第&quot;+i+&quot;个分组为：&quot;+mc.group(i));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分组的个数有：1</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：85653333</span><br></pre></td></tr></table></figure>

<h1 id="9-反向引用"><a href="#9-反向引用" class="headerlink" title="9. 反向引用"></a>9. 反向引用</h1><p>上面讲到捕获，我们知道：捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<p>数字编号组反向引用：\k 或\number</p>
<p>命名编号组反向引用：\k 或者&#39;name’</p>
<p>好了 讲完了，懂吗？不懂！！！</p>
<p>可能连前面讲的捕获有什么用都还不懂吧？</p>
<p>其实只是看完捕获不懂不会用是很正常的！</p>
<p>因为捕获组通常是和反向引用一起使用的</p>
<p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。</p>
<p>注意两个字眼：“内容” 和 “使用”。</p>
<p>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住。</p>
<p>那这里所说的“使用”是怎样使用呢？</p>
<p>因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。</p>
<p>还是举栗子吧：</p>
<p>比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母。</p>
<p>如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，现在我们先用程序思维理一下思路：</p>
<p>1）匹配到一个字母</p>
<p>2）匹配第下一个字母，检查是否和上一个字母是否一样</p>
<p>3）如果一样，则匹配成功，否则失败</p>
<p>这里的思路 2 中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？</p>
<p>这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件。</p>
<p>好了，有思路就要实践</p>
<p>首先匹配一个字母：\w，我们需要做成分组才能捕获，因此写成这样：(\w)</p>
<p>那这个表达式就有一个捕获组：（\w）</p>
<p>然后我们要用这个捕获组作为条件，那就可以：(\w)\1这样就大功告成了</p>
<p>可能有人不明白了，\1 是什么意思呢？</p>
<p>还记得捕获组有两种命名方式吗，<em>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名在默认情况下都是以数字来命名，而且数字命名的顺序是从 1 开始的。</em></p>
<p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k&lt;1&gt;或者\1，当然，通常都是是后者。</p>
<p>我们来测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String test = &quot;aabbbbgbddesddfiid&quot;;</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;(\\w)\\1&quot;);</span><br><span class="line">        Matcher mc= pattern.matcher(test);</span><br><span class="line">        while(mc.find())&#123;</span><br><span class="line">            System.out.println(mc.group());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br></pre></td></tr></table></figure>
<p>嗯，这就是我们想要的了。<br>在举个替换的例子，假如想要把字符串中abc换成a。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String test = &quot;abcbbabcbcgbddesddfiid&quot;;</span><br><span class="line">String reg=&quot;(a)(b)c&quot;;</span><br><span class="line">System.out.println(test.replaceAll(reg, &quot;$1&quot;));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1abbabcgbddesddfiid</span><br></pre></td></tr></table></figure>

<h1 id="10-贪婪和非贪婪"><a href="#10-贪婪和非贪婪" class="headerlink" title="10. 贪婪和非贪婪"></a>10. 贪婪和非贪婪</h1><ul>
<li>贪婪<br>我们都知道，贪婪就是不满足，尽可能多的要。在正则中，贪婪也是差不多的意思:</li>
</ul>
<p><em>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。</em></p>
<p><em>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配 - 舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</em></p>
<p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d&#123;3,6&#125;</span><br></pre></td></tr></table></figure>
<p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p>
<p>如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String reg=&quot;\\d&#123;3,6&#125;&quot;;        </span><br><span class="line">String test=&quot;61762828 176 2991 871&quot;;</span><br><span class="line">System.out.println(&quot;文本：&quot;+test);</span><br><span class="line">System.out.println(&quot;贪婪模式：&quot;+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line">   while(m1.find())&#123;</span><br><span class="line">      System.out.println(&quot;匹配结果：&quot;+m1.group(0));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文本：61762828 176 2991 44 871</span><br><span class="line">贪婪模式：\d&#123;3,6&#125;</span><br><span class="line">匹配结果：617628</span><br><span class="line">匹配结果：176</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：871</span><br></pre></td></tr></table></figure>
<p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。</p>
<p>一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p>
<p><em>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String reg=&quot;(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)&quot;;        </span><br><span class="line">String test=&quot;61762828 176 2991 87321&quot;;</span><br><span class="line">System.out.println(&quot;文本：&quot;+test);</span><br><span class="line">System.out.println(&quot;贪婪模式：&quot;+reg);</span><br><span class="line">Pattern p1 =Pattern.compile(reg);</span><br><span class="line">Matcher m1 = p1.matcher(test);</span><br><span class="line">  while(m1.find())&#123;</span><br><span class="line">      System.out.println(&quot;匹配结果：&quot;+m1.group(0));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文本：61762828 176 2991 87321</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;)(\d&#123;3,4&#125;)</span><br><span class="line">匹配结果：617628</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：87321</span><br></pre></td></tr></table></figure>
<p>“617628” 是前面的\d{1,2}匹配出了 61，后面的匹配出了 7628</p>
<p>“2991” 是前面的\d{1,2}匹配出了 29 ，后面的匹配出了 91</p>
<p>“87321”是前面的\d{1,2}匹配出了 87，后面的匹配出了 321</p>
<ul>
<li>懒惰（非贪婪）<br><em>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。</em></li>
</ul>
<p><em>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</em></p>
<p>懒惰量词是在贪婪量词后面加个“？”</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String reg=&quot;(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;)&quot;;        </span><br><span class="line">        String test=&quot;61762828 176 2991 87321&quot;;</span><br><span class="line">        System.out.println(&quot;文本：&quot;+test);</span><br><span class="line">        System.out.println(&quot;贪婪模式：&quot;+reg);</span><br><span class="line">        Pattern p1 =Pattern.compile(reg);</span><br><span class="line">        Matcher m1 = p1.matcher(test);</span><br><span class="line">        while(m1.find())&#123;</span><br><span class="line">            System.out.println(&quot;匹配结果：&quot;+m1.group(0));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文本：61762828 176 2991 87321</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;)</span><br><span class="line">匹配结果：61762</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：87321</span><br></pre></td></tr></table></figure>
<p>解答：</p>
<p>“61762” 是左边的懒惰匹配出 6，右边的贪婪匹配出 1762</p>
<p>“2991” 是左边的懒惰匹配出 2，右边的贪婪匹配出 991</p>
<p>“87321” 左边的懒惰匹配出 8，右边的贪婪匹配出 7321</p>
<h1 id="11-反义"><a href="#11-反义" class="headerlink" title="11. 反义"></a>11. 反义</h1><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<p>正则知识就讲到这里，正则是一门博大精深的语言，其实学会它的一些语法和知识点还算不太难，但想要做到真正学以致用能写出非常 6 的正则，还有很远的距离，只有真正对它感兴趣的，并且经常研究和使用它，才会渐渐的理解它的博大精深之处，我就带你们走到这，剩下的，靠自己啦。</p>
<blockquote>
<p>作者：公众号（编程无界）<br>链接：<a href="https://mp.weixin.qq.com/s/CBexZfG1DHYji_Pk6Zo38w">https://mp.weixin.qq.com/s/CBexZfG1DHYji_Pk6Zo38w</a><br>来源：微信公众号<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>实现在vue中element-ui的el-dialog弹框拖拽</title>
    <url>/2020/11/09/%E5%AE%9E%E7%8E%B0%E5%9C%A8vue%E4%B8%ADelement-ui%E7%9A%84el-dialog%E5%BC%B9%E6%A1%86%E6%8B%96%E6%8B%BD/</url>
    <content><![CDATA[<p>1、在 utils 中新建 directives.js 文件</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// v-dialogDrag: 弹窗拖拽</span><br><span class="line">Vue.directive(&#x27;dialogDrag&#x27;, &#123;</span><br><span class="line">  bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    const dialogHeaderEl = el.querySelector(&#x27;.el-dialog__header&#x27;)</span><br><span class="line">    const dragDom = el.querySelector(&#x27;.el-dialog&#x27;)</span><br><span class="line">    dialogHeaderEl.style.cursor = &#x27;move&#x27;</span><br><span class="line"></span><br><span class="line">    // 获取原有属性 ie dom元素.currentStyle 火狐谷歌 window.getComputedStyle(dom元素, null);</span><br><span class="line">    const sty = dragDom.currentStyle || window.getComputedStyle(dragDom, null)</span><br><span class="line"></span><br><span class="line">    dialogHeaderEl.onmousedown = (e) =&gt; &#123;</span><br><span class="line">      // 鼠标按下，计算当前元素距离可视区的距离</span><br><span class="line">      const disX = e.clientX - dialogHeaderEl.offsetLeft</span><br><span class="line">      const disY = e.clientY - dialogHeaderEl.offsetTop</span><br><span class="line"></span><br><span class="line">      // 获取到的值带px 正则匹配替换</span><br><span class="line">      let styL, styT</span><br><span class="line"></span><br><span class="line">      // 注意在ie中 第一次获取到的值为组件自带50% 移动之后赋值为px</span><br><span class="line">      if (sty.left.includes(&#x27;%&#x27;)) &#123;</span><br><span class="line">        styL = +document.body.clientWidth * (+sty.left.replace(/\%/g, &#x27;&#x27;) / 100)</span><br><span class="line">        styT = +document.body.clientHeight * (+sty.top.replace(/\%/g, &#x27;&#x27;) / 100)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        styL = +sty.left.replace(/\px/g, &#x27;&#x27;)</span><br><span class="line">        styT = +sty.top.replace(/\px/g, &#x27;&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      document.onmousemove = function(e) &#123;</span><br><span class="line">        // 通过事件委托，计算移动的距离</span><br><span class="line">        const l = e.clientX - disX</span><br><span class="line">        const t = e.clientY - disY</span><br><span class="line"></span><br><span class="line">        // 移动当前元素</span><br><span class="line">        dragDom.style.left = `$&#123;l + styL&#125;px`</span><br><span class="line">        dragDom.style.top = `$&#123;t + styT&#125;px`</span><br><span class="line"></span><br><span class="line">        // 将此时的位置传出去</span><br><span class="line">        // binding.value(&#123;x:e.pageX,y:e.pageY&#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      document.onmouseup = function(e) &#123;</span><br><span class="line">        document.onmousemove = null</span><br><span class="line">        document.onmouseup = null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// v-dialogDragWidth: 弹窗宽度拖大 拖小</span><br><span class="line">Vue.directive(&#x27;dialogDragWidth&#x27;, &#123;</span><br><span class="line">  bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    const dragDom = binding.value.$el.querySelector(&#x27;.el-dialog&#x27;)</span><br><span class="line"></span><br><span class="line">    el.onmousedown = (e) =&gt; &#123;</span><br><span class="line">      // 鼠标按下，计算当前元素距离可视区的距离</span><br><span class="line">      const disX = e.clientX - el.offsetLeft</span><br><span class="line"></span><br><span class="line">      document.onmousemove = function(e) &#123;</span><br><span class="line">        e.preventDefault() // 移动时禁用默认事件</span><br><span class="line"></span><br><span class="line">        // 通过事件委托，计算移动的距离</span><br><span class="line">        const l = e.clientX - disX</span><br><span class="line">        dragDom.style.width = `$&#123;l&#125;px`</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      document.onmouseup = function(e) &#123;</span><br><span class="line">        document.onmousemove = null</span><br><span class="line">        document.onmouseup = null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、main.js中导入：import ‘./utils/directives.js’<br>3、使用 <code>el-dialog</code> 的地方加入 <code>v-dialogDrag</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog</span><br><span class="line">     :visible.sync=&quot;dialogVisible&quot;</span><br><span class="line">     v-dialogDrag&gt;</span><br><span class="line">     // ...</span><br><span class="line">   &lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端框架qiankun接入Vite构建的子应用</title>
    <url>/2023/11/25/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6qiankun%E6%8E%A5%E5%85%A5Vite%E6%9E%84%E5%BB%BA%E7%9A%84%E5%AD%90%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p><code>qiankun</code>官方暂未有文档表明已经支持<code>Vite</code>，所以直接用普通方式接入<code>vite</code>构建的子应用时会出现如下问题：<br><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2023/image1.png"></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><ol>
<li>开发模式：在开发环境下，如果我们使用 <code>vite</code> 来构建 <code>vue3</code> 子应用，基于<code>vite</code>的构建机制，会在子应用的 <code>html</code> 的入口文件的 <code>script</code> 标签上携带 <code>type=module</code>。而我们知道<code>qiankun</code>父应用引入子应用，本质上是将<code>html</code>做为入口文件，并通过<code>import-html-entry</code>这个库去加载子应用所需要的资源列表<code>Js、css</code>，然后通过<code>eval</code>直接执行，而基于<code>vite</code>构建的<code>js</code>中<code>import、export</code>并没有被转码（<code>vite</code>是基于浏览器支持的 <code>ESM import</code>特性实现的 <code>bundless</code>，通过利用浏览器进行模块间依赖加载，而不需要在编译时进行。），会导致直接报错（不允许在非 <code>type=module</code> 的 <code>script</code> 里面使用 <code>import</code>）</li>
<li>生产模式：生产模式下，因为没有诸如<code>webpack</code>中支持运行时<code>publicPath</code>,也就是<code>__webpack_public_path__</code>，换句话说就是<code>vite</code>不支持运行时<code>publicPath</code>，其主要作用是用来解决微应用动态载入的脚本、样式、图片等地址不正确的问题。  </li>
</ol>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>有一款开源插件：<code>vite-plugin-qiankun</code>，通过这个插件可以在<code>qiankun</code>下解决上述两种模式的问题，同时保留了vite构建模块的优势。  </p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://github.com/HelloAllenW/qiankun-vite">Demo</a></h1><h2 id="1-创建主应用"><a href="#1-创建主应用" class="headerlink" title="1. 创建主应用"></a>1. 创建主应用</h2><p>（1）安装<code>qiankun</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install qiankun</span><br></pre></td></tr></table></figure>

<p>（2）新建<code>src/qiankun/index.js</code>文件，进行单独的抽离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; registerMicroApps, start &#125; from &#x27;qiankun&#x27;</span><br><span class="line">registerMicroApps([</span><br><span class="line">    &#123;</span><br><span class="line">        // 必须与子应用注册名字相同</span><br><span class="line">        name: &#x27;vue-app&#x27;,</span><br><span class="line">        // 入口路径，开发时为子应用所启本地服务，上线时为子应用线上路径</span><br><span class="line">        entry: &#x27;http://127.0.0.1:5174&#x27;, </span><br><span class="line">        // 子应用挂载的节点</span><br><span class="line">        container: &#x27;#vue-app-container&#x27;,</span><br><span class="line">        // 当访问路由为 /micro-vue 时加载子应用</span><br><span class="line">        activeRule: &#x27;/micro-vue&#x27;, </span><br><span class="line">        // 主应用向子应用传递参数</span><br><span class="line">        props: &#123;</span><br><span class="line">            msg: &quot;我是来自主应用的值-vue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;react-app&#x27;,</span><br><span class="line">        entry: &#x27;http://127.0.0.1:5175&#x27;,</span><br><span class="line">        container: &#x27;#react-app-container&#x27;,</span><br><span class="line">        activeRule: &#x27;/micro-react&#x27;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            msg: &quot;我是来自主应用的值-react&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line">start()</span><br></pre></td></tr></table></figure>

<p>（3）在<code>main.js</code>中导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;./qiankun&quot;</span><br></pre></td></tr></table></figure>

<p>（4）在<code>App.vue</code>挂载子应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;vue-app-container&quot; /&gt;</span><br><span class="line">&lt;div id=&quot;react-app-container&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-创建子应用-micro-vue-app-（vue3-vite）"><a href="#2-创建子应用-micro-vue-app-（vue3-vite）" class="headerlink" title="2. 创建子应用 micro-vue-app （vue3 + vite）"></a>2. 创建子应用 <code>micro-vue-app （vue3 + vite）</code></h2><p><code>qiankun</code>目前是不支持<code>vite</code>的，需要借助插件完成  </p>
<p><strong>（1） 安装<code>vite-plugin-qiankun</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vite-plugin-qiankun</span><br></pre></td></tr></table></figure>

<p><strong>（2）修改<code>vite.config.js</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import vue from &#x27;@vitejs/plugin-vue&#x27;</span><br><span class="line">import qiankun from &#x27;vite-plugin-qiankun&#x27;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    vue(),</span><br><span class="line">    qiankun(&#x27;vue-app&#x27;, &#123; // 子应用名字，与主应用注册的子应用名字保持一致</span><br><span class="line">      useDevMode: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  server: &#123;</span><br><span class="line">    origin: &#x27;http://localhost:5174&#x27;, // 解决静态资源加载404问题</span><br><span class="line">    host: &#x27;localhost&#x27;,</span><br><span class="line">    port: 5174</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>（3）修改<code>main.js</code></strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import &#123; store &#125; from &#x27;./store&#x27;</span><br><span class="line"></span><br><span class="line">import &#123; renderWithQiankun, qiankunWindow &#125; from &#x27;vite-plugin-qiankun/dist/helper&#x27;</span><br><span class="line"></span><br><span class="line">let instance = null;</span><br><span class="line">const initQianKun = () =&gt; &#123;</span><br><span class="line">    renderWithQiankun(&#123;</span><br><span class="line">        mount(props) &#123;</span><br><span class="line">            render(props.container)</span><br><span class="line">            //  可以通过props读取主应用的参数：msg</span><br><span class="line">            // 监听主应用传值</span><br><span class="line">            props.onGlobalStateChange((res) =&gt; &#123;</span><br><span class="line">                store.count = res.count</span><br><span class="line">                console.log(res.count)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        bootstrap() &#123; &#125;,</span><br><span class="line">        unmount() &#123;</span><br><span class="line">            instance.unmount()</span><br><span class="line">            instance._instance = null</span><br><span class="line">            instance = null</span><br><span class="line">        &#125;,</span><br><span class="line">        update() &#123; &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const render = (container) =&gt; &#123;</span><br><span class="line">    if (instance) return;</span><br><span class="line">    // 如果是在主应用的环境下就挂载主应用的节点，否则挂载到本地</span><br><span class="line">    // 注意：这边需要避免 id（app） 重复导致子应用挂载失败</span><br><span class="line">    const appDom = container ? container : &quot;#app&quot;</span><br><span class="line">    instance = createApp(App)</span><br><span class="line">    instance.mount(appDom)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断当前应用是否在主应用中</span><br><span class="line">qiankunWindow.__POWERED_BY_QIANKUN__ ? initQianKun() : render()</span><br></pre></td></tr></table></figure>

<p><strong>（4）修改<code>route</code>文件，采用<code>hash</code>模式</strong><br><code>qiankun</code>官方是以<code>window.__POWERED_BY_QIANKUN__</code>来判断当前是否为<code>qiankun</code>环境下，而该插件引用之后是通过<code>qiankunWindow.__POWERED_BY_QIANKUN__</code>来判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createWebHashHistory &#125; from &#x27;vue-router&#x27;</span><br><span class="line">import &#123; qiankunWindow &#125; from &#x27;vite-plugin-qiankun/dist/helper&#x27;</span><br><span class="line">const router = createRouter(&#123;    </span><br><span class="line">    history: createWebHashHistory(qiankunWindow.__POWERED_BY_QIANKUN__ ? &#x27;/vueApp&#x27; : &#x27;/&#x27;),     </span><br><span class="line">    routes: routes </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3-创建子应用micor-react-app-（react18-vite）"><a href="#3-创建子应用micor-react-app-（react18-vite）" class="headerlink" title="3.创建子应用micor-react-app （react18 + vite）"></a>3.创建子应用<code>micor-react-app （react18 + vite）</code></h2><p>和vue配置一样，但是会报错：<br><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2023/image2.png"><br>解决方法：在 <code>vite.config.js</code> 中删除<code>react()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import react from &#x27;@vitejs/plugin-react&#x27;</span><br><span class="line">import qiankun from &#x27;vite-plugin-qiankun&#x27;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // 在开发模式下需要把react()关掉</span><br><span class="line">    // https://github.com/umijs/qiankun/issues/1257</span><br><span class="line">    // react(),</span><br><span class="line">    qiankun(&#x27;react-app&#x27;, &#123;// 子应用名字，与主应用注册的子应用名字保持一致</span><br><span class="line">      useDevMode: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  server: &#123;</span><br><span class="line">    port: &#x27;5175&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="可能存在的其他问题"><a href="#可能存在的其他问题" class="headerlink" title="可能存在的其他问题"></a>可能存在的其他问题</h1><ol>
<li>插件 <code>vite-plugin-qiankun</code>在生产模式下依旧不支持<code>publicPath</code>, 需要将<code>vite.config.js</code>中<code>base</code>配置写死。导致多环境部署不便捷。无法像在<code>webpack</code>结合<code>window.INJECTED_PUBLIC_PATH_BY_QIANKUN + publicpath</code>来解决。（未验证）<br><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2023/image3.png"></li>
<li>关于<code>vue3 + vite + typescript</code>项目中出现 <code>“Error: The package &quot;@esbuild/win32-x64&quot; could not be found, and is needed by esbuild.”</code> 的错误。<br><img src="https://cdn.jsdelivr.net/gh/HelloAllenW/BlogAssets@latest/images/2023/image4.png"><br>在运行<code>dev</code>之前先运行<code>node node_modules/esbuild/install.js</code>命令来解决<code>esbuild</code>安装问题。然后再启动项目，发现已经能正常运行。</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>我的Git学习教程</title>
    <url>/2020/11/09/%E6%88%91%E7%9A%84Git%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、Git常用命令汇总"><a href="#一、Git常用命令汇总" class="headerlink" title="一、Git常用命令汇总"></a>一、Git常用命令汇总</h1><p>1、提交<br>git add .<br>git commit -m “”<br>git push [origin远程主机名][本地分支名] [远程分支名]</p>
<p>2、删除<br>（1）删除本地分支：<br>切换到其他分支后，执行git branch -D [分支名]<br>（2）删除远程分支：<br>git push origin –delete [需要删除的分支名称]</p>
<p>3、拉取<br>（1）本地clone远程项目<br>不指定分支：git clone [项目地址]<br>指定分支：git clone -b [线上分支][项目地址]<br>（2）将本地更新为远程分支<br>git pull [远程主机名][远程分支]:[本地分支]</p>
<span id="more"></span>

<p>4、操作分支：<br>（1）切换分支：git checkout [分支名]<br>（2）创建并切换分支：git checkout -b [分支名]</p>
<p>5、tag：默认操作当前分支<br>（1）添加tag：git tag [tag名称]<br>（2）将添加好的tag推到线上：git push [远程主机名origin] [tag名称]<br>（3）删除本地tag：git tag -d [tag名称]<br>（4）删除线上tag例如V1.2：git push [远程主机名origin] :refs/tags/V1.2<br>（5）获取远程版本：git fetch origin tag V1.2</p>
<p>6、版本回退：<br>（1）git reflog 查看版本号commit id<br>（2）git reset –hard 版本号(head^为上一个版本)<br>（3）git push -f origin [当前分支]</p>
<p>7、其他：<br>放弃本地修改：git checkout .<br>查看文件改动明细：git diff [路径/文件名]<br>合并分支：将dev合并到master上<br>（1）先切换回master分支：git checkout master<br>（2）将dev分支的工作成功合并到master分支上：git merge dev<br>（3）提交合并：git push origin [当前分支]<br>更新远程分支列表：git remote update [主机名origin ] –prune</p>
<p>8、Git 切换远程仓库地址<br>[git remote set-url origin URL] 更换远程仓库地址，URL为新地址</p>
<h1 id="二、Git-学习资料与-GitHub-的使用"><a href="#二、Git-学习资料与-GitHub-的使用" class="headerlink" title="二、Git 学习资料与 GitHub 的使用"></a>二、Git 学习资料与 GitHub 的使用</h1><ul>
<li>1、<a href="https://www.runoob.com/w3cnote/git-guide.html">5分钟学会使用 Git</a></li>
<li>2、<a href="https://blog.csdn.net/iabbg/article/details/80002260">手把手教你用Git</a></li>
<li>3、<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">我的Git系统学习教程</a></li>
<li>4、<a href="https://www.yiibai.com/git/git_pull.html">Git命令查询</a></li>
<li>5、<a href="http://www.mamicode.com/info-detail-2331816.html">GitLab使用简明教程</a></li>
<li>6、<a href="https://blog.csdn.net/xc_zhou/article/details/80637759">GitHub使用指南</a></li>
<li>7、<a href="https://blog.csdn.net/heimu24/article/details/81171422">上传本地文件到GitHub</a></li>
</ul>
<h1 id="三、使用-Git-中的问题及解决方案汇总"><a href="#三、使用-Git-中的问题及解决方案汇总" class="headerlink" title="三、使用 Git 中的问题及解决方案汇总"></a>三、使用 Git 中的问题及解决方案汇总</h1><h2 id="1、解决本地项目绑定远程库时报错"><a href="#1、解决本地项目绑定远程库时报错" class="headerlink" title="1、解决本地项目绑定远程库时报错"></a>1、解决本地项目绑定远程库时报错</h2><p>fatal: repository ‘<a href="https://github.com/XXX/&#39;">https://github.com/XXX/&#39;</a> not found<br>问题分析：远程库绑定错误<br>1、查看远程库：git remote -v<br>2、删除远程库：git remote remove origin<br>3、添加远程库：git remote add origin [远程地址]<br>其他：<br>1、查看当前用户：git config user.name<br>2、查看当前邮箱：git config user.email<br>3、修改用户：git config –global user.name [用户名]、<br>4、修改邮箱：git config –global user.email [邮箱]</p>
<h2 id="2、如何将本地项目上传到-GitLab"><a href="#2、如何将本地项目上传到-GitLab" class="headerlink" title="2、如何将本地项目上传到 GitLab"></a>2、如何将本地项目上传到 GitLab</h2><p>在 GitLab 中 New project 后，填写项目名称、权限等，生成空项目。根据提示完成文件上传，参考如下：<br>注意：在上传之前应检查Git库的当前用户和邮箱，是否与自己要上传库相对应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. git init  #把这个目录变成Git可以管理的仓库</span><br><span class="line">2. git add README.md  #本地README.md文件添加到远程仓库</span><br><span class="line">3. git add .  #不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了，注意空格</span><br><span class="line">4. git commit -m &quot;注释&quot;  #把文件提交到仓库</span><br><span class="line">5. git remote add origin git@github.com:heimu24/blog-backup.git  #本地关联远程仓库</span><br><span class="line">6. git push -u origin master  #把本地仓库的所有内容推送到远程库上（第一次需要加-u，后面就不用加了）</span><br></pre></td></tr></table></figure>

<h2 id="3、git-push-u-origin-master-命令报错"><a href="#3、git-push-u-origin-master-命令报错" class="headerlink" title="3、git push -u origin master 命令报错"></a>3、git push -u origin master 命令报错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists.（）</span><br></pre></td></tr></table></figure>
<p>问题原因是在git上没有创建SSH Key<br>解决方法：创建SSH<br>在终端中输入<br>ssh-keygen -t rsa -C “username” (注：username为你git上的用户名)<br>None<br>三次回车，如有看到The key’s randomart image is，代表你的SSH Key生成成功了。<br>cat ~/.ssh/id_rsa.pub</p>
<p><strong><em>或者</em></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181231165219613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxOTAyNzA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4、删除远程仓库项目"><a href="#4、删除远程仓库项目" class="headerlink" title="4、删除远程仓库项目"></a>4、删除远程仓库项目</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 拉取远程的Repo到本地（如果已经在本地，可以略过）</span><br><span class="line">git clone xxx</span><br><span class="line"></span><br><span class="line"># 在本地仓库删除文件</span><br><span class="line">git rm 我的文件</span><br><span class="line"></span><br><span class="line"># 在本地仓库删除文件夹</span><br><span class="line">git rm -r 我的文件夹/</span><br><span class="line">此处-r表示递归所有子目录，如果你要删除的是空的文件夹，此处可以不用带-r</span><br><span class="line"></span><br><span class="line"># 提交代码</span><br><span class="line">git commit -m &quot;我的修改&quot;</span><br><span class="line"></span><br><span class="line"># 推送到远程仓库</span><br><span class="line">git push origin xxx</span><br></pre></td></tr></table></figure>

<h2 id="5、删除Git仓库"><a href="#5、删除Git仓库" class="headerlink" title="5、删除Git仓库"></a>5、删除Git仓库</h2><p>在本地仓库的目录下调用命令行删除根目录下的.git文件夹，输入<br>find . -name “.git” | xargs rm -Rf<br>这样本地仓库就清除了，像下面这样，master不见了。<br><img src="https://img-blog.csdnimg.cn/2019041813505843.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你用 VuePress + GitHub Pages 搭建个人博客！</title>
    <url>/2023/08/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8%20VuePress%20+%20GitHub%20Pages%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在阅读<a href="https://juejin.cn/user/712139234359182">冴羽</a>老师的文章时，对VuePress搭建个人博客很感兴趣，于是试着自己搭建了一遍，写了这篇文章记录一下搭建的基本流程，希望对大家有所帮助。</p>
<h2 id="1-本地搭建"><a href="#1-本地搭建" class="headerlink" title="1. 本地搭建"></a>1. 本地搭建</h2><ol>
<li>创建并进入一个新目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> vuepress-starter</span><br><span class="line"><span class="built_in">cd</span> vuepress-starter</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用你喜欢的包管理器进行初始化</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">init</span> -y</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将 VuePress 安装为本地依赖</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -D vuepress</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建你的第一篇文档</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> docs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;# Hello VuePress&#x27;</span> &gt; docs/README.md</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>package.json</code> 中添加一些 <code>scripts</code></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;docs:dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vuepress dev docs&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;docs:build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vuepress build docs&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在本地启动服务器</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm run docs:dev</span><br></pre></td></tr></table></figure>

<p>VuePress 会在 <a href="http://localhost:8080/">http://localhost:8080</a> 启动一个热重载的开发服务器</p>
<p>这时可能会出现文字乱码情况，需要把 <code>README.md</code> 的编码格式改为 <code>UTF-8</code></p>
<h2 id="2-基础配置"><a href="#2-基础配置" class="headerlink" title="2. 基础配置"></a>2. 基础配置</h2><p>在 <code>docs</code> 文件夹下添加 <code>.vuepress</code> 目录，所有 VuePress 相关的文件都会被放在这里。在 <code>.vuepress</code> 文件夹下添加 <code>config.js</code>，配置网站的标题和描述，方便 SEO，此时你的目录结构可能是这样：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">|<span class="comment">-- docs&#x27;,</span></span><br><span class="line">    |<span class="comment">-- README.md&#x27;,</span></span><br><span class="line">    |<span class="comment">-- .vuepress&#x27;,</span></span><br><span class="line">        |<span class="comment">-- config.js&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>config.js</code> 文件的内容如下(标题和描述自定义)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的博客&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-添加导航栏"><a href="#3-添加导航栏" class="headerlink" title="3. 添加导航栏"></a>3. 添加导航栏</h2><p>我们现在在首页的右上角添加导航栏，修改 <code>config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的博客&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;XXX&#x27;</span>,</span><br><span class="line">  <span class="attr">themeConfig</span>: &#123;</span><br><span class="line">    <span class="attr">nav</span>: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&quot;首页&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/&quot;</span> &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;codinglin 的博客&quot;</span>,</span><br><span class="line">        <span class="attr">items</span>: [</span><br><span class="line">          &#123; <span class="attr">text</span>: <span class="string">&quot;掘金&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;https://juejin.cn/user/726107228492253&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">text</span>: <span class="string">&quot;Github&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;https://github.com/coding-lin&quot;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时界面如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9093f90054b543818a79ebf79007a7b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_15-48-31.png"></p>
<h2 id="4-添加侧边栏"><a href="#4-添加侧边栏" class="headerlink" title="4. 添加侧边栏"></a>4. 添加侧边栏</h2><p>现在我们添加一些 <code>md</code> 文档，内容自行添加，文档的目录结构如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">|<span class="comment">-- docs&#x27;,</span></span><br><span class="line">    |<span class="comment">-- README.md&#x27;,</span></span><br><span class="line">    |<span class="comment">-- .vuepress&#x27;,</span></span><br><span class="line">        |<span class="comment">-- config.js&#x27;</span></span><br><span class="line">    |<span class="comment">-- handbook</span></span><br><span class="line">        |<span class="comment">-- 1.md </span></span><br><span class="line">        |<span class="comment">-- 2.md</span></span><br></pre></td></tr></table></figure>

<p>我们在 <code>config.js</code> 添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的博客&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;XXX&#x27;</span>,</span><br><span class="line">  <span class="attr">themeConfig</span>: &#123;</span><br><span class="line">    <span class="attr">nav</span>: [...],</span><br><span class="line">    <span class="attr">sidebar</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;欢迎学习&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">collapsable</span>: <span class="literal">false</span>,  <span class="comment">// 是否折叠</span></span><br><span class="line">        <span class="attr">children</span>: [&#123; <span class="attr">title</span>: <span class="string">&quot;博客简介&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/&quot;</span> &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;基础篇&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/handbook/1&quot;</span>,</span><br><span class="line">        <span class="attr">collapsable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">title</span>: <span class="string">&quot;第一篇&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/handbook/1&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">title</span>: <span class="string">&quot;第二篇&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/handbook/2&quot;</span> &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125; </span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时页面如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6f064f8564d4668acca028cc96882e5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_16-12-41.png"></p>
<h2 id="5-更换主题"><a href="#5-更换主题" class="headerlink" title="5. 更换主题"></a>5. 更换主题</h2><p>现在基本的目录和导航功能已经实现，如果还想要 <code>loading</code>效果、切换动画、模式切换（暗黑模式）、返回顶部、评论等功能呢，为了简化开发成本，我们可以直接使用主题，我使用的主题是 <a href="https://link.juejin.cn/?target=https://vuepress-theme-reco.recoluan.com/">vuepress-theme-reco</a>：</p>
<p>现在我们安装 vuepress-theme-reco：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">npm install vuepress-theme-reco <span class="attr">--save-dev</span></span><br></pre></td></tr></table></figure>

<p>然后在 <code>config.js</code> 中引用该主题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">theme</span>: <span class="string">&#x27;reco&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>配置好之后，可以看到自己的博客网站新增了一些功能，例如模式切换：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1e1b44540b64bbe83ad69962e0c7756~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_16-24-40.png"></p>
<h2 id="6-添加文章信息"><a href="#6-添加文章信息" class="headerlink" title="6. 添加文章信息"></a>6. 添加文章信息</h2><p>我们会发现，一篇文章竟然出现了两遍标题，这是因为这个主题自动提取了第一个大标题作为本文的标题，我们可以在每篇文章的 <code>md</code> 文件中添加一些信息修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">VuePress</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">codinglin</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">&#x27;2022-8-28&#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8383425aefc24e4bb9f8aef159229858~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_16-43-22.png"></p>
<h2 id="7-设置语言"><a href="#7-设置语言" class="headerlink" title="7. 设置语言"></a>7. 设置语言</h2><p>文章时间，我们写入的格式为 <code>2022-8-28</code> ，但是显示的是 <code>8/28/2022</code>，这是因为 VuePress 默认的 lang 为 <code>en-US</code>，我们修改一下 <code>config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">locales</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">lang</span>: <span class="string">&#x27;zh-CN&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以发现时间格式发生了变化：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a82d5143082473a9c2a74825eaa6467~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_16-46-43.png"></p>
<h2 id="8-开启目录结构"><a href="#8-开启目录结构" class="headerlink" title="8. 开启目录结构"></a>8. 开启目录结构</h2><p>在原本的主题里，我们发现每篇文章的目录结构在左侧，而 vuepress-theme-reco 将原有的侧边栏的中的多级标题移出，生成子侧边栏，放在了页面的右侧，如果你要全局开启，可在 <code>config.js</code> 中设置开启：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">themeConfig</span>: &#123;</span><br><span class="line">    <span class="attr">subSidebar</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-修改主题颜色"><a href="#9-修改主题颜色" class="headerlink" title="9. 修改主题颜色"></a>9. 修改主题颜色</h2><p>VuePress 基于 Vue，所以主题色用的是 Vue 的绿色，你也可以将主题颜色修改为你自己喜欢的颜色，你可以创建一个 <code>.vuepress/styles/palette.styl</code> 文件，文件代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$accentColor</span> = <span class="comment">#3178c6</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0265b5ec3342c0af574571817d59a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_16-59-47.png"></p>
<p>更多颜色的修改请参考 <a href="https://link.juejin.cn/?target=https://vuepress.vuejs.org/zh/config/%23palette-styl">palette.styl</a></p>
<h2 id="10-自定义修改样式"><a href="#10-自定义修改样式" class="headerlink" title="10. 自定义修改样式"></a>10. 自定义修改样式</h2><p>我们发现用作强调的文字颜色比较暗淡，在暗黑模式下看不清楚，如何修改这个文字的颜色和背景色呢？</p>
<p>你可以创建一个 <code>.vuepress/styles/index.styl</code> 文件，文件代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.dark</span> <span class="selector-class">.content__default</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">58</span>,<span class="number">58</span>,<span class="number">92</span>,<span class="number">0.7</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要隐藏每篇文章的标题、作者、时间呢，其实也是类似的方式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.page-title</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ddb5ee1a9804012ba138b9d10c09306~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_18-22-15.png"></p>
<h2 id="11-部署"><a href="#11-部署" class="headerlink" title="11. 部署"></a>11. 部署</h2><p>到这里，我们的博客网站基本搭建好了，接下来我们将它部署到 Github Pages 上。我们首先在 Github 上新建一个仓库，这里我取名为：<code>interview</code>。</p>
<p>相应地，我们需要在 <code>config.js</code> 添加一个 <code>base</code> 路径配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 和仓库名相同</span></span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;/interview/&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的 <code>config.js</code> 的内容为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的博客&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;XXX&#x27;</span>,</span><br><span class="line">  <span class="attr">theme</span>: <span class="string">&#x27;reco&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;/interview/&#x27;</span>,</span><br><span class="line">  <span class="attr">locales</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">lang</span>: <span class="string">&#x27;zh-CN&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">themeConfig</span>: &#123;</span><br><span class="line">    <span class="attr">subSidebar</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">    <span class="attr">nav</span>: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&quot;首页&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/&quot;</span> &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;codinglin 的博客&quot;</span>,</span><br><span class="line">        <span class="attr">items</span>: [</span><br><span class="line">          &#123; <span class="attr">text</span>: <span class="string">&quot;掘金&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;https://juejin.cn/user/726107228492253&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">text</span>: <span class="string">&quot;Github&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;https://github.com/coding-lin&quot;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">sidebar</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;欢迎学习&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">collapsable</span>: <span class="literal">false</span>,  <span class="comment">// 是否折叠</span></span><br><span class="line">        <span class="attr">children</span>: [&#123; <span class="attr">title</span>: <span class="string">&quot;博客简介&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/&quot;</span> &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;基础篇&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/handbook/1&quot;</span>,</span><br><span class="line">        <span class="attr">collapsable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">title</span>: <span class="string">&quot;第一篇&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/handbook/1&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">title</span>: <span class="string">&quot;第二篇&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/handbook/2&quot;</span> &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125; </span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在项目 <code>vuepress-starter</code> 目录下创建一个脚本文件 <code>deploy.sh</code>，注意修改一下对应的<strong>用户名</strong>和<strong>仓库名</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保脚本抛出遇到的错误</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">npm run docs:build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入生成的文件夹</span></span><br><span class="line"><span class="built_in">cd</span> docs/.vuepress/dist</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&#x27;deploy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;</span></span><br><span class="line">git push -f git@github.com:XXX/XXX.git master:gh-pages</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>

<p>新建一个终端，选择 <code>Git Bash</code>，进入主目录，并执行 <code>sh deploy.sh</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bfd8ba7bc4c456dba5711a05ff5eb01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_18-47-59.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> vuepress-starter</span><br><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure>

<p>项目就会开始构建，然后上传到远程仓库上。</p>
<p>我们可以在仓库的 <code>Settings -&gt; Pages</code> 中看到最后的地址：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e60bed72bed94a67b15fc9216b67ef1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-08-28_18-43-12.png"></p>
<p>最后生成的地址：<a href="https://link.juejin.cn/?target=https://coding-lin.github.io/interview/">coding-lin.github.io/interview/</a></p>
<p>至此，我们完成了 VuePress 和 Github Pages 的部署。</p>
<p>如果大家想要丰富自己的个人博客的话，可以去安装一些插件，地址如下：<a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/261">搭建 VuePress 博客，你可能会用到的一些插件</a></p>
<p>更新之后的博客：<a href="https://link.juejin.cn/?target=https://coding-lin.github.io/blog/">coding-lin.github.io/blog/</a> ，博客代码已上传到 <a href="https://link.juejin.cn/?target=https://github.com/coding-lin/blog/tree/main">github</a>，欢迎大家 star！</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是使用 VuePress + GitHub Pages 搭建个人博客的大致流程，如果觉得这篇文章对你有帮助的话，不要忘了点赞哟~</p>
<p>原文链接：<a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/235">一篇带你用 VuePress + Github Pages 搭建博客</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>拦截Element-UI中el-tabs组件的切换</title>
    <url>/2020/11/09/%E6%8B%A6%E6%88%AAElement-UI%E4%B8%ADel-tabs%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>在切换tabs时，如果当前页面内容没有保存，则拦截切换并提示：“离开将不保存本页修改”的弹框</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>1、tabs组件代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-tabs v-model=&quot;activeTab&quot; type=&quot;card&quot; :before-leave=&quot;beforeLeave&quot;&gt;</span><br><span class="line"> 	&lt;el-tab-pane label=&quot;用户信息&quot; name=&quot;basicInfo&quot;&gt;</span><br><span class="line">  		用户信息表单</span><br><span class="line"> 	&lt;/el-tab-pane&gt;</span><br><span class="line"> 	&lt;el-tab-pane v-if=&quot;code&quot; label=&quot;用户角色&quot; name=&quot;userRole&quot;&gt;</span><br><span class="line">  		用户角色列表</span><br><span class="line"> 	&lt;/el-tab-pane&gt;</span><br><span class="line">&lt;/el-tabs&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>2、beforeLeave()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeLeave(item) &#123;</span><br><span class="line">    var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    this.$confirm(&#x27;离开将不保存本页修改&#x27;, &#x27;提示&#x27;, &#123;</span><br><span class="line">        confirmButtonText: &#x27;确定&#x27;,</span><br><span class="line">        cancelButtonText: &#x27;取消&#x27;,</span><br><span class="line">        type: &#x27;warning&#x27;</span><br><span class="line">    &#125;).then(() =&gt; &#123;</span><br><span class="line">        // 你可以在这儿做些操作</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).catch(err =&gt; &#123;</span><br><span class="line">        // 你可以在这儿做些操作</span><br><span class="line">        reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构绪论</title>
    <url>/2020/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。<br>数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。<br>比如，在人类中，人就是数据元素。</p>
<span id="more"></span>

<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>数据项一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。<br>比如人这样的数据元素，可以有眼、耳、鼻这些数据项，也可以有姓名、年龄、性别等数据项。</p>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>数据对象是性质相同的数据元素的集合，是数据的子集。<br>比如人都有姓名、生日、性别等相同的数据项。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</strong></p>
<h1 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是指数据对象中数据元素之间的相互关系。逻辑结构分为如下四种：</p>
<ol>
<li>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。<br><img src="https://img-blog.csdnimg.cn/img_convert/18e846265132ee22d385154d8d4ca826.png"> </li>
<li>线性结构：线性结构中的数据元素之间是一对一的关系。<br><img src="https://img-blog.csdnimg.cn/img_convert/0f9c740476509dbd4a59a616caab0bb6.png"> </li>
<li>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。<br><img src="https://img-blog.csdnimg.cn/img_convert/34f96ca81cc9dd45529812912f58a913.png"> </li>
<li>图形结构：图形结构的数据元素是多对多的关系。<br><img src="https://img-blog.csdnimg.cn/img_convert/f3beb2ab173f89a61b54031579932948.png"> </li>
</ol>
<h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>物理结构或叫存储结构：是指数据的逻辑结构在计算机中的存储形式。<br>数据的存储结构应正确反映数据元素之间的逻辑关系，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。<br>数据元素的存储结构形式有两种：顺序存储和链式存储</p>
<ol>
<li><p>顺序存储结构<br>把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p>
</li>
<li><p>链式存储结构<br>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。<br>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。</p>
</li>
</ol>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。<br>抽象数据类型（Abstract Data Type, ADT）: 是指一个数学模型及定义在该模型上的一组操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">    数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">    操作1</span><br><span class="line">	初始条件</span><br><span class="line">	操作结构描述</span><br><span class="line">    操作2</span><br><span class="line">	...</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>理解和使用ES6中的Symbol</title>
    <url>/2022/11/09/%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8ES6%E4%B8%AD%E7%9A%84Symbol/</url>
    <content><![CDATA[<blockquote>
<p>ES6中引入了一种新的基础数据类型：Symbol，不过很多开发者可能都不怎么了解它，或者觉得在实际的开发工作中并没有什么场景应用到它，那么今天我们来讲讲这个数据类型，并看看我们怎么来利用它来改进一下我们的代码。</p>
</blockquote>
<h1 id="这是一种新的基础数据类型（primitive-type）"><a href="#这是一种新的基础数据类型（primitive-type）" class="headerlink" title="这是一种新的基础数据类型（primitive type）"></a>这是一种新的基础数据类型（primitive type）</h1><p>Symbol是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用Symbol()函数来创建一个Symbol实例：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s1 = Symbol()</span><br></pre></td></tr></table></figure>
<p>或者，你也可以在调用Symbol()函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s2 = Symbol(&#x27;another symbol&#x27;)</span><br></pre></td></tr></table></figure>
<p>如果用当下比较流行的TypeScript的方式来描述这个Symbol()函数的话，可以表示成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param  &#123;any&#125; description 描述信息。可以是任何可以被转型成字符串的值，如：字符串、数字、对象、数组等</span><br><span class="line"> */</span><br><span class="line">function Symbol(description?: any): symbol</span><br></pre></td></tr></table></figure>
<p>由于Symbol是一种基础数据类型，所以当我们使用typeof去检查它的类型的时候，它会返回一个属于自己的类型symbol，而不是什么string、object之类的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof s1  // &#x27;symbol&#x27;</span><br></pre></td></tr></table></figure>
<p>另外，我们需要重点记住的一点是：每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回false：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s1 = Symbol()</span><br><span class="line">let s2 = Symbol(&#x27;another symbol&#x27;)</span><br><span class="line">let s3 = Symbol(&#x27;another symbol&#x27;)</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br><span class="line">s2 === s3 // false</span><br></pre></td></tr></table></figure>
<h1 id="应用场景1：使用Symbol来作为对象属性名-key"><a href="#应用场景1：使用Symbol来作为对象属性名-key" class="headerlink" title="应用场景1：使用Symbol来作为对象属性名(key)"></a>应用场景1：使用Symbol来作为对象属性名(key)</h1><p>在这之前，我们通常定义或访问对象的属性时都是使用字符串，比如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  abc: 123,</span><br><span class="line">  &quot;hello&quot;: &quot;world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj[&quot;abc&quot;] // 123</span><br><span class="line">obj[&quot;hello&quot;] // &#x27;world&#x27;</span><br></pre></td></tr></table></figure>
<p>而现在，Symbol可同样用于对象属性的定义和访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PROP_NAME = Symbol()</span><br><span class="line">const PROP_AGE = Symbol()</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [PROP_NAME]: &quot;一斤代码&quot;</span><br><span class="line">&#125;</span><br><span class="line">obj[PROP_AGE] = 18</span><br><span class="line"></span><br><span class="line">obj[PROP_NAME] // &#x27;一斤代码&#x27;</span><br><span class="line">obj[PROP_AGE] // 18</span><br></pre></td></tr></table></figure>
<p>随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用Object.keys()或者for…in来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   [Symbol(&#x27;name&#x27;)]: &#x27;一斤代码&#x27;,</span><br><span class="line">   age: 18,</span><br><span class="line">   title: &#x27;Engineer&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.keys(obj)   // [&#x27;age&#x27;, &#x27;title&#x27;]</span><br><span class="line"></span><br><span class="line">for (let p in obj) &#123;</span><br><span class="line">   console.log(p)   // 分别会输出：&#x27;age&#x27; 和 &#x27;title&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj)   // [&#x27;age&#x27;, &#x27;title&#x27;]</span><br></pre></td></tr></table></figure>
<p>由上代码可知，Symbol类型的key是不能通过Object.keys()或者for…in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。</p>
<p>也正因为这样一个特性，当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON.stringify(obj)  // &#123;&quot;age&quot;:18,&quot;title&quot;:&quot;Engineer&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。</p>
<p>然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用Object的API</span><br><span class="line">Object.getOwnPropertySymbols(obj) // [Symbol(name)]</span><br><span class="line"></span><br><span class="line">// 使用新增的反射API</span><br><span class="line">Reflect.ownKeys(obj) // [Symbol(name), &#x27;age&#x27;, &#x27;title&#x27;]</span><br></pre></td></tr></table></figure>
<h1 id="应用场景2：使用Symbol来替代常量"><a href="#应用场景2：使用Symbol来替代常量" class="headerlink" title="应用场景2：使用Symbol来替代常量"></a>应用场景2：使用Symbol来替代常量</h1><p>先来看一下下面的代码，是不是在你的代码里经常会出现？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const TYPE_AUDIO = &#x27;AUDIO&#x27;</span><br><span class="line">const TYPE_VIDEO = &#x27;VIDEO&#x27;</span><br><span class="line">const TYPE_IMAGE = &#x27;IMAGE&#x27;</span><br><span class="line"></span><br><span class="line">function handleFileResource(resource) &#123;</span><br><span class="line">  switch(resource.type) &#123;</span><br><span class="line">    case TYPE_AUDIO:</span><br><span class="line">      playAudio(resource)</span><br><span class="line">      break</span><br><span class="line">    case TYPE_VIDEO:</span><br><span class="line">      playVideo(resource)</span><br><span class="line">      break</span><br><span class="line">    case TYPE_IMAGE:</span><br><span class="line">      previewImage(resource)</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(&#x27;Unknown type of resource&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值（比如这里的’AUDIO’、’VIDEO’、 ‘IMAGE’），常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。</p>
<p>现在有了Symbol，我们大可不必这么麻烦了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const TYPE_AUDIO = Symbol()</span><br><span class="line">const TYPE_VIDEO = Symbol()</span><br><span class="line">const TYPE_IMAGE = Symbol()</span><br></pre></td></tr></table></figure>
<p>这样定义，直接就保证了三个常量的值是唯一的了！是不是挺方便的呢。</p>
<h1 id="应用场景3：使用Symbol定义类的私有属性-方法"><a href="#应用场景3：使用Symbol定义类的私有属性-方法" class="headerlink" title="应用场景3：使用Symbol定义类的私有属性/方法"></a>应用场景3：使用Symbol定义类的私有属性/方法</h1><p>我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。</p>
<p>而有了Symbol以及模块化机制，类的私有属性和方法才变成可能。例如：</p>
<ul>
<li>在文件 a.js中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PASSWORD = Symbol()</span><br><span class="line"></span><br><span class="line">class Login &#123;</span><br><span class="line">  constructor(username, password) &#123;</span><br><span class="line">    this.username = username</span><br><span class="line">    this[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPassword(pwd) &#123;</span><br><span class="line">      return this[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Login</span><br></pre></td></tr></table></figure></li>
<li>在文件 b.js 中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Login from &#x27;./a&#x27;</span><br><span class="line"></span><br><span class="line">const login = new Login(&#x27;admin&#x27;, &#x27;123456&#x27;)</span><br><span class="line"></span><br><span class="line">login.checkPassword(&#x27;123456&#x27;)  // true</span><br><span class="line"></span><br><span class="line">login.PASSWORD  // oh!no!</span><br><span class="line">login[PASSWORD] // oh!no!</span><br><span class="line">login[&quot;PASSWORD&quot;] // oh!no!</span><br></pre></td></tr></table></figure>
由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个PASSWORD的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。<h1 id="注册和获取全局Symbol"><a href="#注册和获取全局Symbol" class="headerlink" title="注册和获取全局Symbol"></a>注册和获取全局Symbol</h1></li>
</ul>
<p>通常情况下，我们在一个浏览器窗口中（window），使用Symbol()函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了<code>&lt;iframe&gt;</code>），并需要这些window中使用的某些Symbol是同一个，那就不能使用Symbol()函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是Symbol.for()，它可以注册或获取一个window间全局的Symbol实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let gs1 = Symbol.for(&#x27;global_symbol_1&#x27;)  //注册一个全局Symbol</span><br><span class="line">let gs2 = Symbol.for(&#x27;global_symbol_1&#x27;)  //获取全局Symbol</span><br><span class="line"></span><br><span class="line">gs1 === gs2  // true</span><br></pre></td></tr></table></figure>
<p>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p>
<p>好了，通过以上这些例子，你现在是不是开始对ES6的这个Symbol功能有点了解了呢？Symbol在JS内部也有很多应用，比如迭代器(Iterator)等，大家可以以此为出发点，发掘出更多相关知识点，深入的理解Symbol的用法和使用场景。</p>
<blockquote>
<p>作者：一斤代码<br>链接：<a href="https://www.jianshu.com/p/f40a77bbd74e">https://www.jianshu.com/p/f40a77bbd74e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>算法中的时间复杂度和空间复杂度</title>
    <url>/2020/11/09/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="算法基本概念"><a href="#算法基本概念" class="headerlink" title="算法基本概念"></a>算法基本概念</h1><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有效序列，并且每条指令表示一个或多个操作。</p>
<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。</p>
<p>算法设计的要求：<br>正确性、可读性、健壮性、时间效率高和存储量低。</p>
<p>算法效率的度量方法：</p>
<ol>
<li>事后统计方法：<br>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。<br>但是这种方法显然有很大缺陷，例如比较依赖计算机硬件和软件等环境因素。</li>
<li>事前分析估算方法</li>
</ol>
<span id="more"></span>

<h1 id="算法事前分析估算方法"><a href="#算法事前分析估算方法" class="headerlink" title="算法事前分析估算方法"></a>算法事前分析估算方法</h1><h2 id="函数的渐进增长"><a href="#函数的渐进增长" class="headerlink" title="函数的渐进增长"></a>函数的渐进增长</h2><p>假设两个算法的输入规模都是n，算法A要做2n+3次操作，算法B要做3n+1次操作。你觉得谁更快呢？<br>准确来说，答案是不一定的。<br>当n=1时，算法A效率不如B；当n=2时，两者效率相同；当n&gt;2时，算法A开始优于B，随着n的增加，算法A比B越来越好。于是我们得出结论，算法A总体上要好过算法B。<br>此时我们给出这样定义，输入规模n在没有限制的情况下，只要超出一个数值N，这个函数总是大于另一个函数，我们称函数是渐进增长的。</p>
<p>再举一些有指数的例子，我们观察发现，最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快。于是我们得到这样一个结论，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p>
<h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。<br>算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p>
<h3 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h3><ol>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。<br>得到的结果就是大O阶。</li>
</ol>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/5c2dda54325252290426ba0ac05b550d.png"><br>常用的时间复杂度所耗费的时间从小到大依次是：<br><img src="https://img-blog.csdnimg.cn/img_convert/33239657a65c54ea0ded891c63de812e.png"></p>
<h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><p>一般没有特殊说明的情况下，都是指最坏时间复杂度。</p>
<h2 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h2><p>算法的空间复杂度通过算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Webpack</title>
    <url>/2021/11/09/%E8%B0%88%E8%B0%88Webpack/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一个常见的`webpack`配置文件</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;);</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">        entry: __dirname + &quot;/app/main.js&quot;, //已多次提及的唯一入口文件</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: __dirname + &quot;/build&quot;,</span><br><span class="line">            filename: &quot;bundle-[hash].js&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool: &#x27;none&#x27;,</span><br><span class="line">        devServer: &#123;</span><br><span class="line">            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录</span><br><span class="line">            historyApiFallback: true, //不跳转</span><br><span class="line">            inline: true,</span><br><span class="line">            hot: true</span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;</span><br><span class="line">            rules: [&#123;</span><br><span class="line">                    test: /(\.jsx|\.js)$/,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: &quot;babel-loader&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    exclude: /node_modules/</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    test: /\.css$/,</span><br><span class="line">                    use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                        fallback: &quot;style-loader&quot;,</span><br><span class="line">                        use: [&#123;</span><br><span class="line">                            loader: &quot;css-loader&quot;,</span><br><span class="line">                            options: &#123;</span><br><span class="line">                                modules: true,</span><br><span class="line">                                localIdentName: &#x27;[name]__[local]--[hash:base64:5]&#x27;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, &#123;</span><br><span class="line">                            loader: &quot;postcss-loader&quot;</span><br><span class="line">                        &#125;],</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#x27;版权所有，翻版必究&#x27;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h3><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：</p>
<ul>
<li><p>模块化，让我们可以把复杂的程序细化为小的文件;</p>
</li>
<li><p>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；</p>
</li>
<li><p>Scss，less等CSS预处理器<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>
<h3 id="webpack和Grunt、Gulp的比较"><a href="#webpack和Grunt、Gulp的比较" class="headerlink" title="webpack和Grunt、Gulp的比较"></a>webpack和Grunt、Gulp的比较</h3></li>
<li><p>webpack是基于Node.js开发出的一个前端项目构建工具。.vue是在webpack中定义组件的方式，main.js是项目的JS入口文件。</p>
</li>
<li><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>
</li>
<li><p>Gulp/Grunt是一种能够优化前端的开发流程的工具。它们的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p>
</li>
<li><p>Gulp是基于task任务的构建工具，小巧灵活；webpack是基于整个项目的模块化的解决方案。借助于webpack，可以完美实现资源的合并、打包、压缩、混淆、处理依赖关系等诸多功能，在很多场景下可以替代Gulp/Grunt类的工具。</p>
<h3 id="使用Webpack"><a href="#使用Webpack" class="headerlink" title="使用Webpack"></a>使用Webpack</h3></li>
<li><p>项目初始化，会自动生成package.json文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure></li>
<li><p>在项目安装webpack作为依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install -g webpack</span><br><span class="line">//安装到你的项目目录</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure></li>
<li><p>在终端中使用webpack</p>
<p>对入口文件(main.js)做处理，生成一个打包文件(bundle.js)。指定入口文件后，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果你的webpack不是全局安装的，那么当你在终端中使用此命令时，需要额外指定其在node_modules中的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//webpack全局安装的情况</span><br><span class="line">webpack .\src\main.js .\dist\bundle.js</span><br><span class="line">//webpack非全局安装的情况</span><br><span class="line">node_modules/.bin/webpack .\src/main.js .\dist/bundle.js</span><br></pre></td></tr></table></figure></li>
<li><p>通过配置文件来使用webpack</p>
<p>为了不用每次修改代码后都要通过终端命令对bundle.js进行更新，通过定义一个配置文件webpack.config.js来实现上步功能，然后只需在终端执行webpack(非全局安装需使用node_modules/.bin/webpack)命令可自动生成bundle.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)    //定义根目录</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname,&#x27;./src/main.js&#x27;)    //入口，表示要使用webpack打包哪个文件</span><br><span class="line">    output:&#123;    //输出文件相关的配置</span><br><span class="line">        path: path.join(__dirname,&#x27;./dist&#x27;)    //打包后文件存放的地方</span><br><span class="line">        filename: &#x27;bundle.js&#x27;        //打包后输出文件的文件名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更快捷的执行打包任务</p>
</li>
</ul>
<p>在命令行中输入命令需要代码类似于node_modules/.bin/webpack这样的路径其实是比较烦人的，不过值得庆幸的是npm可以引导任务执行，对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面略微繁琐的命令。在package.json中对scripts对象进行相关设置即可，设置方法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-sample-project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Sample webpack project&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot; // 修改的是这里，JSON文件不支持注释，引用时请清除</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;zhang&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;3.10.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：</span><br><span class="line"> - package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。</span><br><span class="line"> - npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run &#123;script name&#125;如npm run build</span><br><span class="line"> - webpack帮我们打包生成的bundle.js文件，并没有存放到实际的物理磁盘上，由于每次保存代码后都要更改bundle.js所以为了访问速度快些而是直接托管到了电脑的内存中，所以，我们在项目根目录中，根本找不到这个打包好的bundle.js</span><br></pre></td></tr></table></figure>
<h3 id="Webpack的强大功能"><a href="#Webpack的强大功能" class="headerlink" title="Webpack的强大功能"></a>Webpack的强大功能</h3><ul>
<li><p>Source Maps：让调试更容易                                               </p>
<p>webpack在打包时生成了source maps，这位我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更好，更容易调试。在webpack配置文件中配置source maps，需要配置devtool。<br><img src="https://img-blog.csdnimg.cn/20181126005814979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxOTAyNzA5,size_16,color_FFFFFF,t_70" alt="devtool有四种不同的配置选项，各具优缺点"><br>对小到中型的项目中，eval-source-map是一个很好的选项，再次强调只应该开发阶段使用它，我们对webpack.config.js，进行如下配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &#x27;eval-source-map&#x27;,</span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用webpack构建本地服务器：监听代码的修改，并自动刷新显示修改后的结果</p>
<p>（1）webpack提供了一个基于node.js构建的本地开发服务器devserver，可以实现上述需求。不过它是一个单独的组件，在webpack配置前需要对其安装作为项目依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>（2）修改webpack.config.js配置文件<br>devserver作为webpack配置选项中的一项，配置参数如下：</p>
</li>
<li><p>-open    //自动打开浏览器</p>
</li>
<li><p>-port 3000    //问3000端口</p>
</li>
<li><p>-contentBase src    //src做为根路径</p>
</li>
<li><p>-hot    //热更新：局部更新，同时起到浏览器的无刷新浏览（仅对于样式，异步刷新页面有效）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &#x27;eval-source-map&#x27;,</span><br><span class="line"></span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Loaders</p>
</li>
</ul>
<p>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件<br>Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：<br>（1）test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）<br>（2）loader：loader的名称（必须）<br>（3）include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；<br>（4）query：为loaders提供额外的设置选项（可选）</p>
<ul>
<li>Babel</li>
</ul>
<p>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：<br>（1）让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>（2）让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p>
<ul>
<li><p>CSS<br>（1）工具样式表css-loader、style-loader<br>（2）CSS module<br>（3）CSS预处理器<br>Sass 和 Less 之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句</p>
</li>
<li><p>插件(Plugins)</p>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000006178770">参考</a></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>讲讲JS中的类、继承和单例</title>
    <url>/2022/11/06/%E8%AE%B2%E8%AE%B2JS%E4%B8%AD%E7%9A%84%E7%B1%BB%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>本篇分别通过 ES5 和 ES6 讲述JS中的类、静态方法、继承和单例</p>
</blockquote>
<h1 id="ES5-类和静态方法"><a href="#ES5-类和静态方法" class="headerlink" title="ES5 类和静态方法"></a>ES5 类和静态方法</h1><p>1、构造函数里面的方法和属性与原型链上的方法和属性都叫做：实例方法。要调用必须通过实例化构造函数（Person类），静态方法直接通过构造函数（类名）进行调用</p>
<p>2、原型链上的属性和方法可以被多个实例共享，而构造函数里面的方法和属性不会被多个实例共享</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过构造函数来定义类</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    // 构造函数里面的方法和属性</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.run = function() &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; - $&#123;this.age&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造函数原型链上的属性和方法</span><br><span class="line">Person.prototype.sex = &#x27;男&#x27;;</span><br><span class="line">Person.prototype.work = function() &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; - $&#123;this.age&#125; - $&#123;this.sex&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态方法</span><br><span class="line">Person.setName = function() &#123;</span><br><span class="line">   console.log(&#x27;静态方法&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例方法是通过实例化来调用的</span><br><span class="line">var p = new Person(&#x27;zhangsan&#x27;, &#x27;20&#x27;);</span><br><span class="line">p.run()</span><br><span class="line">p.work()</span><br><span class="line"></span><br><span class="line">// 静态方法是通过类名直接调用</span><br><span class="line">Person.setName()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h1><p>原型链继承和对象冒充继承：</p>
<ul>
<li>对象冒充继承：可以实现将参数传递到父类，但是没法继承原型链上的属性和方法</li>
<li>原型链继承：可以继承构造函数里面以及原型链上面的属性和方法，但是实例化子类的时候没法给父类传参</li>
</ul>
<p>所以平时都是两者结合起来实现继承</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.run = function() &#123;</span><br><span class="line">        console.log(this.name + &#x27;-&#x27; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.work = function() &#123;</span><br><span class="line">    console.log(&#x27;work&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Web(name, age) &#123;</span><br><span class="line">    // 通过 call()，能够使用属于另一个对象的方法。</span><br><span class="line">    // 此处相当于 Web 函数去调用Person类，并传值name,age</span><br><span class="line">    Person.call(this, name, age) // 对象冒充实现继承，可以实现将参数传递到父类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Web.prototype = new Person() // 原型链继承，但是原型链继承在实例化时没法将参数传递到父类里面</span><br><span class="line">var w = new Web(&#x27;李四&#x27;, 20)</span><br><span class="line">w.run() // 测试调用构造函数里面的方法</span><br><span class="line">w.work() // 测试调用原型链上的方法</span><br></pre></td></tr></table></figure>

<h1 id="ES6-类"><a href="#ES6-类" class="headerlink" title="ES6 类"></a>ES6 类</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(name, age) &#123; // 类的构造方法，实例化的时候执行，new的时候执行</span><br><span class="line">        this._name = name;</span><br><span class="line">        this._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义方法，注意：es6里面方法之间没有逗号(,)</span><br><span class="line">    getName() &#123;</span><br><span class="line">        console.log(this._name)</span><br><span class="line">    &#125;</span><br><span class="line">    setName() &#123;</span><br><span class="line">        this._name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&#x27;张三&#x27;, &#x27;20&#x27;)</span><br><span class="line">p.setName(&#x27;李四&#x27;)</span><br><span class="line">p.getName()</span><br></pre></td></tr></table></figure>

<h1 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    getInfo() &#123;</span><br><span class="line">        console.log(`姓名：$&#123;this.name&#125; - 年龄：$&#123;this.age&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        console.log(&#x27;run&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Web extends Person &#123;</span><br><span class="line">    constructor(name, age ,sex) &#123;</span><br><span class="line">        super(name, age) // 实例化子类的时候把子类的数据传给父类</span><br><span class="line">        this.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(this.sex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var w = new Web(&#x27;张三&#x27;, &#x27;30&#x27;, &#x27;男&#x27;)</span><br><span class="line">w.print() // 调用自己的方法</span><br><span class="line">w.getInfo() // 调用父类方法</span><br></pre></td></tr></table></figure>

<h1 id="ES6-静态方法"><a href="#ES6-静态方法" class="headerlink" title="ES6 静态方法"></a>ES6 静态方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(name) &#123; // 属性</span><br><span class="line">        this._name = name</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123; // 实例方法</span><br><span class="line">        console.log(this._name)</span><br><span class="line">    &#125;</span><br><span class="line">    static work() &#123; // 静态方法</span><br><span class="line">        console.log(&#x27;这是es6中的静态方法&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者通过这种方式定义类的静态方法</span><br><span class="line">Person.instance = &#x27;这是一个静态方法的属性&#x27;</span><br><span class="line"></span><br><span class="line">var p = new Person(&#x27;张三&#x27;)</span><br><span class="line">p.run()</span><br><span class="line">Person.work() // 通过类名来调用静态方法</span><br><span class="line">console.log(Person.instance)</span><br></pre></td></tr></table></figure>

<h1 id="ES6-单例"><a href="#ES6-单例" class="headerlink" title="ES6 单例"></a>ES6 单例</h1><blockquote>
<p>使用场景：nodejs连接mongodb数据库，只连接成功一次，然后之后每次操作数据库都使用本次连接后的实例，不用每次都重新连接</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DB &#123;</span><br><span class="line">    static getInstance() &#123; // 单例</span><br><span class="line">        if (!DB.instance) &#123;</span><br><span class="line">            DB.instance = new DB()</span><br><span class="line">        &#125;</span><br><span class="line">        return DB.instance</span><br><span class="line">    &#125;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(&#x27;实例化会触发构造函数&#x27;)</span><br><span class="line">        this.connect()</span><br><span class="line">    &#125;</span><br><span class="line">    connect() &#123;</span><br><span class="line">        console.log(&#x27;连接数据库&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    find() &#123;</span><br><span class="line">        console.log(&#x27;查询数据库&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myDb1 = new DB()</span><br><span class="line">var myDb2 = new DB() // 验证发现：每次实例化都会执行构造函数重新进行连接数据库。 所以对性能产生影响，采用单例模式进行处理</span><br><span class="line"></span><br><span class="line">var myDb3 = DB.getInstance() // 单例实例化：实例化多次但只会调用一次构造函数，然后各自调用实例方法互不影响</span><br><span class="line">myDb3.find()</span><br><span class="line">var myDb4 = DB.getInstance()</span><br><span class="line">myDb4.find()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>通过JS将图片File转为base64并压缩</title>
    <url>/2020/11/09/%E9%80%9A%E8%BF%87JS%E5%B0%86%E5%9B%BE%E7%89%87File%E8%BD%AC%E4%B8%BAbase64%E5%B9%B6%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<blockquote>
<p>后端为了方便需要直接将图片存储为base64，但图片过大时转出的base64过长，因此前端需要对转后的base64进行压缩</p>
</blockquote>
<p>话不多说，直接上代码</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;需要转换的图片file&#125; file </span><br><span class="line"> * @param &#123;是否返回压缩后的base64&#125; isCompression </span><br><span class="line"> * @param &#123;转换成功后通过回调函数将结果返回&#125; callback </span><br><span class="line"> */</span><br><span class="line">export function imageToBase64(file, isCompression, callback) &#123;</span><br><span class="line">	// 判断图片类型</span><br><span class="line">	if (file.type == &#x27;image/jpeg&#x27; || file.type == &#x27;image/png&#x27; || file.type == &#x27;image/jpg&#x27;) &#123;</span><br><span class="line">		var isJpg = true</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		jsJpg = false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 判断图片大小</span><br><span class="line">	const isLt2M = file.size / 1024 / 1024 &lt; 2</span><br><span class="line">	if (!isJpg) &#123;</span><br><span class="line">		this.$message.error(&#x27;上传图片只能是jpg/png/jepg格式&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">	if (!isLt2M) &#123;</span><br><span class="line">		this.$message.error(&#x27;上传图片大小不能超过2M&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 创建一个HTML5的FileReader对象</span><br><span class="line">	var reader = new FileReader()</span><br><span class="line">	// 创建一个img对象</span><br><span class="line">	var img = new Image()</span><br><span class="line">	// let filename = file.filename</span><br><span class="line">	if (file) &#123;</span><br><span class="line">		reader.readAsDataURL(file)</span><br><span class="line">	&#125;</span><br><span class="line">	if (isJpg &amp;&amp; isLt2M) &#123;</span><br><span class="line">		reader.onload=(e)=&gt;&#123;</span><br><span class="line">			// let base64Str = reader.result.split[&#x27;,&#x27;][1]</span><br><span class="line">			img.src = e.target.result</span><br><span class="line">			// base64地址图片加载完毕后执行</span><br><span class="line">			img.onload = function() &#123;</span><br><span class="line">				// 缩放图片需要canvas（也可以在DOM中直接定义canvas标签，这样就能把压缩完的图片不转base64也能直接显示出来）</span><br><span class="line">				var canvas = document.createElement(&#x27;canvas&#x27;)</span><br><span class="line">				var context = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">				// 图片原始尺寸</span><br><span class="line">				var originWidth = this.width</span><br><span class="line">				var originHeight = this.height</span><br><span class="line">				// 最大尺寸限制，可通过设置宽高来实现图片压缩程度</span><br><span class="line">				var maxWidth = 300,</span><br><span class="line">					maxHeight = 300</span><br><span class="line">				// 目标尺寸</span><br><span class="line">				var targetWidth = originWidth</span><br><span class="line">					targetHeight = originHeight</span><br><span class="line">				// 图片尺寸超过最大尺寸限制</span><br><span class="line">				if(originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123;</span><br><span class="line">					if (originWidth / originHeight &gt; maxWidth / maxHeight) &#123;</span><br><span class="line">						// 更改宽度，按照宽度限定尺寸</span><br><span class="line">						targetWidth = maxWidth</span><br><span class="line">						targetHeight = Math.round(maxWidth*(originHeight/originWidth))</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						targetHeight = maxHeight</span><br><span class="line">						targetWidth = Math.round(maxHeight*(originWidth/originHeight))</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				// 对图片进行缩放</span><br><span class="line">				canvas.width = targetWidth</span><br><span class="line">				canvas.height = targetHeight</span><br><span class="line">				// 清除画布</span><br><span class="line">				context.clearRect(0, 0, targetWidth, targetHeight)</span><br><span class="line">				/** 图片压缩</span><br><span class="line">				 * 第一个参数是创建的img对象</span><br><span class="line">				 * 第二三个参数是左上角坐标</span><br><span class="line">				 * 后两个参数是画布区域宽高</span><br><span class="line">				 */</span><br><span class="line">				context.drawImage(img, 0, 0, targetWidth, targetHeight)</span><br><span class="line">				/** 压缩后的base64文件</span><br><span class="line">				 * 第一个参数可以为image/jpeg或image/webp类型的图片</span><br><span class="line">				 * 第二个参数设置图片质量取值0-1，超出则以默认值0.92替代</span><br><span class="line">				 */</span><br><span class="line">				var newUrl = canvas.toDataURL(&#x27;image/jpeg&#x27;, 0.02)</span><br><span class="line">				if (isCompression) &#123; // 返回压缩后的base64</span><br><span class="line">					callback(newUrl)</span><br><span class="line">				&#125; else &#123; // 返回不压缩的base64</span><br><span class="line">					callback(e.target.result)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
