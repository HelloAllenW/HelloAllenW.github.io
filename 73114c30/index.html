<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="Allen">


    <meta name="subtitle" content="绿衣捧砚催题卷，红袖添香伴读书">




<title>对比Vue2总结Vue3新特性(2022年最全，2.5w字！) | 阿伦的个人博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



<!-- 百度统计，在head.ejs中引入 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4089b5476d9d7b1fbf81de2841dc180c";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    


<!-- 搜索 -->
<div id="algolia-search">
  <div class="search-dialog">  
    <nav class="search-nav">
      <span class="search-dialog-title">Search</span>
      <button class="search-close-button">
        <span class="iconfont icon-guanbi"></span>
      </button>
    </nav>
  
    <div class="search-wrap">
      <div id="algolia-search-input"></div>
      <hr />  
      <div id="algolia-search-results">
        <div id="algolia-hits"></div>
        <div id="algolia-pagination"></div>
        <div id="algolia-info">
          <div class="algolia-stats"></div>
          <div class="algolia-poweredBy"></div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="search-mask"></div>
  
  <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.66.1/dist/instantsearch.production.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/algoliasearch/4.23.2/algoliasearch-lite.umd.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/js/algolia.js"></script>
</div>



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="阿伦的个人博客" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
            } else {
                pagebody.classList.remove('dark-theme');
            }
            // mobile
            if (document.getElementById("mobile-toggle-theme")) {
                document.getElementById("mobile-toggle-theme").innerText = isDark ? "· Dark" : "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Allen&#39;s Blog</a></div>
            <div class="menu navbar-right">
                <!-- 其他的导航 -->
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                

                <!-- Search -->
                <span id="search-button" style="padding: 0 8px;cursor: pointer;">
                    <span class="search">Search</span>
                </span>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Allen&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">对比Vue2总结Vue3新特性(2022年最全，2.5w字！)</h1>
            
                <div class="post-meta">
                    
                    <!-- 
                        Author: <a itemprop="author" rel="author" href="/">Allen</a>
                     -->

                    
                        <span class="post-time">
                        
                        <!-- Date: <a href="#">五月 7, 2022&nbsp;&nbsp;11:22:03</a> -->
                        <span class="iconfont icon-date1"></span>
                        五月 7, 2022
                        </span>
                    
                    &nbsp;  &nbsp;
                    
                        <span class="post-category">
                            <span class="iconfont icon-icon-goodscategory"></span>
                            
                                <a href="/categories/Web%E5%89%8D%E7%AB%AF/">Web前端</a>
                            
                        </span>
                    
                    <!-- 展示当前文章所属tags -->
                    
                    &nbsp;  &nbsp;
                    <span class="iconfont icon-tags"></span>
                        <span>
                            
                                <a href="/tags/Vue/">Vue </a>&nbsp;
                            
                        </span>
                    
                    
                    
                        <!-- 文章字数和阅读时间 -->
<div style="display: inline;">
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-post"></span>
      <!-- <span class="post-meta-item-text">  Count: </span> -->
      <span class="post-count">24.4k Words</span>
    </span>
  </span>
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-time"></span>
      <!-- <span class="post-meta-item-text">  Time: </span> -->
      <span class="post-count">110 min</span>
    </span>
  </span>
</div>

                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有没有小伙伴跟笔者一样<code>vue3</code>项目做了好几个了，但是一直没有去总结<code>vue3</code>的新特性呢？</p>
<p>今天笔者通过对比<code>vue2</code>来总结<code>vue3</code>新特性，希望可以让你们在回顾<code>vue2</code>知识点的时候还能学习<code>vue3</code>新的知识。相信你认真看完一定会有收获。</p>
<h3 id="Volar"><a href="#Volar" class="headerlink" title="Volar"></a>Volar</h3><p>使用<code>vscode</code>开发<code>vue2</code>项目的小伙伴肯定都认识<code>Vetur</code>这个神级插件。但是在<code>vue3</code>中这个插件就显得捉襟见肘了，比如<code>vue3</code>的多片段这个插件就会报错。</p>
<p>这个时候就需要使用<code>Volar</code>，<code>Volar</code>可以理解为<code>Vue3</code>版本的<code>Vetur</code>，代码高亮，语法提示，基本上<code>Vetur</code>有的它都有。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4e8bb1107ef9dff3ca8ba967382b7843_720w.webp" alt="img"></p>
<h3 id="Vue-3-Snippets"><a href="#Vue-3-Snippets" class="headerlink" title="Vue 3 Snippets"></a>Vue 3 Snippets</h3><p>在<code>vue2</code>中我们一直使用<code>Vue 2 Snippets</code>，在<code>vue3</code>我们推荐使用<code>Vue 3 Snippets</code>，因为它支持<code>vue3</code>的同时完全向前兼容<code>vue2</code>，所以小伙伴们赶快去升级吧。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0cc5b7f5caacdcbf31188c74de27a1be_720w.webp" alt="img"></p>
<h3 id="Vue-js-devtools-beta"><a href="#Vue-js-devtools-beta" class="headerlink" title="Vue.js devtools beta"></a>Vue.js devtools beta</h3><p><code>vue2</code>版本的<code>chrome devtools</code>不再支持<code>vue3</code>，<code>vue3</code>我们需要单独下载<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https%253A%252F%252Fchrome.google.com%252Fwebstore%252Fdetail%252Fvuejs-devtools%252Fljjemllljcmogpfapbkkighbhhppjdbg%253Fhl%253Dzh-CN">Vue.js devtools beta</a>。(下载<code>devtools</code>是需要梯子的哦，如果没有可以联系笔者)。<br>在下载<code>Vue.js devtools beta</code>之前，我们需要先卸载<code>vue2</code>版本的<code>Vue.js devtools</code>，不然会有警告。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a06e0390564793b6b74cb098358cad1b_720w.webp" alt="img"></p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><code>vue3</code>固然好用但是我们还是不能盲目追求新东西，在使用<code>vue3</code>开发之前我们需清楚的知道它的兼容性。</p>
<p><code>vue2</code> <strong>不支持</strong> IE8 及以下版本，因为 <code>Vue</code> 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https%253A%252F%252Fcaniuse.com%252F%2523feat%253Des5">兼容 ECMAScript 5 的浏览器</a>。</p>
<p><code>vue3</code> <strong>不支持</strong> IE11 及以下版本。</p>
<h2 id="响应性-API"><a href="#响应性-API" class="headerlink" title="响应性 API"></a>响应性 API</h2><p>在<code>vue2</code>中，我们只要定义在<code>data()</code>方法中的数据就是响应式数据。或者使用<code>Vue.observable()</code>方法来定义响应式数据。</p>
<p>还可以使用<code>this.$set( target, propertyName/index, value )</code>或<code>Vue.set( target, propertyName/index, value )</code>来给对象或数组添加响应式属性。使用<code>this.$delete( target, propertyName/index)</code>或<code>Vue.delete( target, propertyName/index)</code>来给对象或数组删除响应式属性。</p>
<p>在<code>vue2</code>中使用<code>Vue.observable()</code>方法。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = Vue.observable(&#123; count: 0 &#125;)</span><br></pre></td></tr></table></figure>

<p>但在<code>vue3</code>中主要是使用<code>ref</code>和<code>reactive</code>来定义响应式数据。由于<code>vue3</code>使用的是<code>proxy</code>进行响应式监听，所以新增、删除属性也都是响应式的，也就不需要使用上面的<code>set delete</code>了。</p>
<h3 id="ref和isRef"><a href="#ref和isRef" class="headerlink" title="ref和isRef"></a>ref和isRef</h3><p>接受一个内部值并返回一个响应式且可变的 <code>ref</code> 对象。<code>ref</code> 对象仅有一个 <code>.value</code> <code>property</code>，指向该内部值。</p>
<blockquote>
<p>一般用来定义基本类型的响应式数据。注意这里说的是一般，并不是说ref就不能定义引用类型的响应式数据。</p>
</blockquote>
<p>使用<code>ref</code>定义的响应式数据在<code>setup</code>函数中使用需要加上<code>.value</code>，但在模板中可以直接使用。</p>
<p><code>isRef</code>检查值是否为一个 <code>ref</code> 对象。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h3&gt;count1&lt;/h3&gt;</span><br><span class="line">  &lt;div&gt;count1: &#123;&#123; count1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;button @click=&quot;plus&quot;&gt;plus&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;decrease&quot;&gt;decrease&lt;/button&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;div&gt;user1: &#123;&#123; user1.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;button @click=&quot;updateUser1Name&quot;&gt;update user1 name&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, ref, isRef &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const count1 = ref(0);</span><br><span class="line"></span><br><span class="line">    const plus = () =&gt; &#123;</span><br><span class="line">      count1.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    const decrease = () =&gt; &#123;</span><br><span class="line">      count1.value--;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    const user1 = ref(&#123; name: &quot;randy1&quot; &#125;);</span><br><span class="line">    const updateUser1Name = () =&gt; &#123;</span><br><span class="line">      // ref定义的变量需要使用.value修改</span><br><span class="line">      user1.value.name += &quot;!&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    console.log(isRef(count1)); // true</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      count1,</span><br><span class="line">      plus,</span><br><span class="line">      decrease,</span><br><span class="line">      user1,</span><br><span class="line">      updateUser1Name</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>ref</code>除了定义响应式数据还可以定义模板引用，类似<code>vue2</code>的<code>this.$refs</code>这个后面笔者在讲模板引用的时候会细说。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      // 创建</span><br><span class="line">      const root = ref(null)</span><br><span class="line"></span><br><span class="line">      onMounted(() =&gt; &#123;</span><br><span class="line">        // 获取子组件</span><br><span class="line">        console.log(root.value) // &lt;div&gt;This is a root element&lt;/div&gt;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h3><p>创建一个跟踪自身 <code>.value</code> 变化的 <code>ref</code>，但不会使其值也变成响应式的。</p>
<p>这句话怎么理解呢？就是我们使用<code>shallowRef</code>创建出来的数据不是响应式的，也就是我们的修改页面并不会重新渲染。但是我们直接修改数据<code>.value</code>是会响应式的。</p>
<p>下面我们来看例子。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const sRef1 = shallowRef(0);</span><br><span class="line">console.log(&quot;shallowRef:&quot;, sRef1.value); // 0</span><br><span class="line"></span><br><span class="line">// 假设点击页面按钮，触发该方法</span><br><span class="line">const changeShallowRef1 = () =&gt; &#123;</span><br><span class="line">  // 直接修改value，页面会同步修改，也就是会响应式</span><br><span class="line">  sRef1.value++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const sRef2 = shallowRef(&#123; name: &quot;demi1&quot; &#125;);</span><br><span class="line"></span><br><span class="line">// 假设点击页面按钮，触发该方法</span><br><span class="line">const changeShallowRef2 = () =&gt; &#123;</span><br><span class="line">  // 不直接修改value，而是修改属性值</span><br><span class="line">  sRef2.value.name = &quot;randy&quot;;</span><br><span class="line">  sRef2.value.address = &#123; city: &quot;汨罗&quot; &#125;; // 添加新属性</span><br><span class="line">  // 这里数据虽然改变了，但是页面不会更新，也就是说不会响应式</span><br><span class="line">  console.log(sRef2.value); // &#123;address: &#123;city: &#x27;汨罗&#x27;&#125;, name: &quot;randy&quot;&#125;</span><br><span class="line">  </span><br><span class="line">  // 但是我们直接重新赋值，页面会立马重新渲染</span><br><span class="line">  sRef2.value = &#123;name: &quot;randy&quot;, address: &#123;city: &#x27;汨罗&#x27;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 假设点击页面按钮，触发该方法</span><br><span class="line">const changeShallowRef3 = () =&gt; &#123;</span><br><span class="line">  // 但是我们直接重新赋值，页面会立马重新渲染</span><br><span class="line">  sRef2.value = &#123;name: &quot;randy&quot;, address: &#123;city: &#x27;汨罗&#x27;&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以发现，当响应式数据是基本数据类型的时候<code>ref</code>和<code>shallowRef</code>没有差别。但是如果数据是引用数据类型的话<code>ref</code>的数据是响应式的而<code>shallowRef</code>不是，<code>shallowRef</code>需要给<code>value</code>重新赋值才会触发响应式。</p>
<h3 id="reactive和isReactive"><a href="#reactive和isReactive" class="headerlink" title="reactive和isReactive"></a>reactive和isReactive</h3><p><code>reactive</code>用来定义引用类型的响应式数据。注意，不能用来定义基本数据类型的响应式数据，不然会报错。</p>
<p><code>reactive</code>定义的对象是不能直接使用<code>es6</code>语法解构的，不然就会失去它的响应式，如果硬要解构需要使用<code>toRefs()</code>方法。</p>
<p><code>isReactive</code>用来检查对象是否是由 <code>reactive</code> 创建的响应式代理。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;user2&lt;/h3&gt;</span><br><span class="line">    &lt;div&gt;user2: &#123;&#123; user2.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;updateUser2Name&quot;&gt;update user2 name&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;user3&lt;/h3&gt;</span><br><span class="line">    &lt;div&gt;user3 name: &#123;&#123; name &#125;&#125; user3 age: &#123;&#123; age &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;updateUser3Name&quot;&gt;update user3 name&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;count2&lt;/h3&gt;</span><br><span class="line">    &lt;div&gt;count2: &#123;&#123; count2 &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;plus2&quot;&gt;plus2&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;decrease2&quot;&gt;decrease2&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, reactive, toRefs, isReactive &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const _user = &#123; name: &quot;randy2&quot; &#125;</span><br><span class="line">    const user2 = reactive(_user);</span><br><span class="line">    const updateUser2Name = () =&gt; &#123;</span><br><span class="line">      // reactive定义的变量可以直接修改</span><br><span class="line">      user2.name += &quot;!&quot;;</span><br><span class="line">      </span><br><span class="line">      // 原始对象的修改并不会响应式，也就是页面并不会重新渲染</span><br><span class="line">      // _user.name += &quot;!&quot;;</span><br><span class="line">      // 代理对象被改变的时候，原始对象会被修改</span><br><span class="line">      // console.log(_user);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 使用toRefs可以响应式解构出来，在模板能直接使用啦。</span><br><span class="line">    const user3 = reactive(&#123; name: &quot;randy3&quot;, age: 24 &#125;);</span><br><span class="line">    const updateUser3Name = () =&gt; &#123;</span><br><span class="line">      user3.name += &quot;!&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 使用reactive定义基本数据类型会报错</span><br><span class="line">    const count2 = reactive(0);</span><br><span class="line"></span><br><span class="line">    const plus2 = () =&gt; &#123;</span><br><span class="line">      count2.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    const decrease2 = () =&gt; &#123;</span><br><span class="line">      count2.value--;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 检查对象是否是由 reactive 创建的响应式代理。</span><br><span class="line">    console.log(isReactive(user2)); // true</span><br><span class="line">    console.log(isReactive(count2)); // false</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      user2,</span><br><span class="line">      updateUser2Name,</span><br><span class="line">      // ...user3, // 直接解构不会有响应式</span><br><span class="line">      ...toRefs(user3),</span><br><span class="line">      updateUser3Name,</span><br><span class="line">      count2,</span><br><span class="line">      plus2,</span><br><span class="line">      decrease2,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>reactive</code> 将解包所有深层的 <code>refs</code>，同时维持 <code>ref</code> 的响应性。</p>
<p>怎么理解这句话呢，就是使用<code>reactive</code>定义响应式对象，里面的属性是<code>ref</code>定义的话可以直接赋值而不需要再<code>.value</code>，并且数据的修改是响应式的。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(1)</span><br><span class="line">// 可以直接定义，而不是&#123;count: count.value&#125;</span><br><span class="line">const obj = reactive(&#123; count &#125;)</span><br><span class="line"></span><br><span class="line">// 这种写法也是支持的</span><br><span class="line">// const obj = reactive(&#123;&#125;)</span><br><span class="line">// obj.count = count</span><br><span class="line"></span><br><span class="line">// ref 会被解包</span><br><span class="line">console.log(obj.count === count.value) // true</span><br><span class="line"></span><br><span class="line">// 它会更新 `obj.count`</span><br><span class="line">count.value++</span><br><span class="line">console.log(count.value) // 2</span><br><span class="line">console.log(obj.count) // 2</span><br><span class="line"></span><br><span class="line">// 它也会更新 `count` ref</span><br><span class="line">obj.count++</span><br><span class="line">console.log(obj.count) // 3</span><br><span class="line">console.log(count.value) // 3</span><br></pre></td></tr></table></figure>

<h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a>shallowReactive</h3><p>浅响应式，创建一个响应式代理，它跟踪其自身 <code>property</code> 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)。</p>
<p>并且与 <code>reactive</code>不同，任何使用 <code>ref</code> 的 <code>property</code> 都<strong>不会</strong>被代理自动解包。</p>
<p>简单理解就是响应式只会在第一层，不会深层响应式。类似于浅拷贝。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const user1 = shallowReactive(&#123;</span><br><span class="line">  name: &quot;demi1&quot;,</span><br><span class="line">  address: &#123; city: &quot;汨罗&quot;, count: 10 &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 假设点击页面按钮，触发该方法</span><br><span class="line">const changeUser1 = () =&gt; &#123;</span><br><span class="line">  // 响应式，页面会发生变化</span><br><span class="line">  user1.name = &quot;demi1 !!!&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 假设点击页面按钮，触发该方法</span><br><span class="line">const changeUser2 = () =&gt; &#123;</span><br><span class="line">  // 非响应式，也就是页面不会发生变化</span><br><span class="line">  user1.address.city = &quot;岳阳&quot;;</span><br><span class="line">  user1.address.count++;</span><br><span class="line">  // 这里数据虽然改变了，但是页面不会更新，也就是说不会响应式</span><br><span class="line">  console.log(user1); // &#123;address: &#123;city: &#x27;岳阳&#x27;, count: 11&#125;, name: &quot;demi1 !!!&quot;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(isReactive(user1)); // true</span><br><span class="line">console.log(isReactive(user1.address)); // false</span><br></pre></td></tr></table></figure>

<h3 id="readonly和isReadonly"><a href="#readonly和isReadonly" class="headerlink" title="readonly和isReadonly"></a>readonly和isReadonly</h3><p>接受一个对象 (响应式或纯对象) 或 <code>ref</code>数据 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 <code>property</code> 也是只读的。</p>
<p>怎么理解这句话呢，就是说只要是对象不管是普通对象还是<code>reactive</code>定义的对象或者是<code>ref</code>定义的数据，定义成<code>readonly</code>后就不能被修改了。</p>
<blockquote>
<p>这里需要特别注意，是<code>readonly</code><strong>返回的对象</strong>变成只读，源对象不会受到影响，所以修改源对象还是可以的。</p>
</blockquote>
<p><code>isReadonly</code>用来检查对象是否是由 <code>readonly</code> 创建的只读代理。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// ref定义的数据会被限制，不能被修改</span><br><span class="line">let name1 = ref(&quot;readonly randy&quot;);</span><br><span class="line">// readOnlyName1才是只读的</span><br><span class="line">let readOnlyName1 = readonly(name1);</span><br><span class="line">const changeName1 = () =&gt; &#123;</span><br><span class="line">  readOnlyName1.value += &quot;!&quot;;</span><br><span class="line">  // 这里直接修改源对象还是可以的</span><br><span class="line">  // name1.value += &quot;!&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 基本数据类型数据会无效，能被修改</span><br><span class="line">let readOnlyName2 = readonly(&quot;readonly randy&quot;);</span><br><span class="line">readOnlyName2 = &quot;randy&quot;;</span><br><span class="line">console.log(readOnlyName2); // randy</span><br><span class="line"></span><br><span class="line">// reactive定义的对象会被限制，不能被修改</span><br><span class="line">const reactiveUser1 = reactive(&#123; name: &quot;readonly randy&quot; &#125;);</span><br><span class="line">let readonlyUser1 = readonly(reactiveUser1);</span><br><span class="line">const changeUserName1 = () =&gt; &#123;</span><br><span class="line">  readonlyUser1.name += &quot;!&quot;;</span><br><span class="line">  // 这里直接修改源对象还是可以的</span><br><span class="line">  // reactiveUser1.name += &quot;!&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 普通对象也会被限制，不能被修改</span><br><span class="line">let readonlyUser2 = readonly(&#123; name: &quot;readonly randy&quot; &#125;);</span><br><span class="line">readonlyUser2.name = &quot;randy&quot;;</span><br><span class="line">console.log(readonlyUser2.name); // readonly randy</span><br><span class="line"></span><br><span class="line">console.log(isReadonly(readOnlyName1)); // true</span><br><span class="line">console.log(isReadonly(readOnlyName2)); // false</span><br><span class="line">console.log(isReadonly(readonlyUser1)); // true</span><br><span class="line">console.log(isReadonly(readonlyUser2)); // true</span><br></pre></td></tr></table></figure>

<p>与 <code>reactive</code> 一样，如果任何 <code>property</code> 使用了 <code>ref</code>，当它通过代理访问时，则被自动解包。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const raw = &#123;</span><br><span class="line">  count: ref(123)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里就类似const copy = reactive(raw)</span><br><span class="line">const copy = readonly(raw)</span><br><span class="line"></span><br><span class="line">console.log(raw.count.value) // 123</span><br><span class="line">console.log(copy.count) // 123</span><br></pre></td></tr></table></figure>

<h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a>shallowReadonly</h3><p>浅只读，创建一个 <code>proxy</code>，使其自身的 <code>property</code> 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。</p>
<p>并且与 <code>readonly</code>不同，任何使用 <code>ref</code> 的 <code>property</code> 都<strong>不会</strong>被代理自动解包。</p>
<p>简单理解就是只读的限制只会在第一层，不会深层只读。类似于浅拷贝。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const user2 = shallowReadonly(</span><br><span class="line">  reactive(&#123;</span><br><span class="line">    name: &quot;demi2&quot;,</span><br><span class="line">    address: &#123; city: &quot;汨罗2&quot;, count: 10 &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(isReadonly(user2)); // true</span><br><span class="line">console.log(isReadonly(user2.address)); // false</span><br><span class="line">const changeUser2 = () =&gt; &#123;</span><br><span class="line">  // 响应式，页面会同步修改</span><br><span class="line">  user2.address.city = &quot;岳阳&quot;;</span><br><span class="line">  user2.address.count++;</span><br><span class="line">  </span><br><span class="line">  // 非响应式，也就是页面不会重新渲染该值</span><br><span class="line">  user2.name = &quot;demi1 !!!&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="isProxy"><a href="#isProxy" class="headerlink" title="isProxy"></a>isProxy</h3><p>检查对象是否是由 <code>reactive</code>或 <code>readonly</code> 创建的 <code>proxy</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ref定义的所以返回false</span><br><span class="line">let name1 = ref(&quot;readonly randy&quot;);</span><br><span class="line">// ref是对象，所以返回true</span><br><span class="line">let readOnlyName1 = readonly(name1);</span><br><span class="line"></span><br><span class="line">// readonly失败返回false</span><br><span class="line">let readOnlyName2 = readonly(&quot;readonly randy&quot;);</span><br><span class="line"></span><br><span class="line">const reactiveUser1 = reactive(&#123; name: &quot;readonly randy&quot; &#125;);</span><br><span class="line">let readonlyUser1 = readonly(reactiveUser1);</span><br><span class="line"></span><br><span class="line">let readonlyUser2 = readonly(&#123; name: &quot;readonly randy&quot; &#125;);</span><br><span class="line"></span><br><span class="line">// 检查对象是否是由 reactive 或 readonly 创建的 proxy。</span><br><span class="line">console.log(isProxy(name1)); // false</span><br><span class="line">console.log(isProxy(readOnlyName1)); // true</span><br><span class="line">console.log(isProxy(readOnlyName2)); // false</span><br><span class="line">console.log(isProxy(reactiveUser1)); // true</span><br><span class="line">console.log(isProxy(readonlyUser2)); // true</span><br></pre></td></tr></table></figure>

<p>上面的例子有些小伙伴看了会比较懵逼，为什么<code>readonly</code>有些是<code>true</code>有些又是<code>false</code>呢？其实你弄懂了<code>readonly</code>就大概会清楚了。<code>readonly</code>是不能处理基本数据类型的，所以<code>readonly</code>不成功就会返回<code>false</code>。</p>
<h3 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a>toRaw</h3><p>返回 <code>reactive</code> 或 <code>readonly</code>代理的原始对象。这是一个“逃生舱”，可用于临时读取数据而无需承担代理访问/跟踪的开销，也可用于写入数据而避免触发更改。<strong>不</strong>建议保留对原始对象的持久引用。请谨慎使用。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;</span><br><span class="line">const reactiveFoo = reactive(foo)</span><br><span class="line"></span><br><span class="line">console.log(toRaw(reactiveFoo) === foo) // true</span><br></pre></td></tr></table></figure>

<h3 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a>markRaw</h3><p>标记一个对象，使其永远不会转换为 <code>proxy</code>。返回对象本身。</p>
<p>因为不会被<code>proxy</code>，也就是说不会响应式，相当于一个普通值。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const info = markRaw(&#123; sex: &quot;male&quot; &#125;);</span><br><span class="line">console.log(isReactive(reactive(info))); // false</span><br><span class="line"></span><br><span class="line">const user3 = reactive(&#123; name: &quot;randy&quot;, info &#125;);</span><br><span class="line">const changeUser3 = () =&gt; &#123;</span><br><span class="line">  user3.info.sex = &quot;female&quot;;</span><br><span class="line">  // 这里数据虽然变了，但是页面并不会重新渲染，也就是说不会响应式</span><br><span class="line">  console.log(user3); // &#123;info: &#123;sex: &#x27;female&#x27;&#125;, name: &quot;randy&quot;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="unref"><a href="#unref" class="headerlink" title="unref"></a>unref</h3><p>如果参数是一个 <code>ref</code>，则返回内部值，否则返回参数本身。这是 <code>val = isRef(val) ? val.value : val</code> 的语法糖函数。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const user1 = ref(&#123; name: &quot;randy1&quot; &#125;);</span><br><span class="line">console.log(&quot;unref: &quot;, unref(user1), user1.value);</span><br></pre></td></tr></table></figure>

<h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>可以用来为源响应式对象上的某个 <code>property</code> 新创建一个 <code>ref</code>。然后，<code>ref</code> 可以被传递，它会保持对其源 <code>property</code> 的响应式连接。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const state = reactive(&#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const fooRef = toRef(state, &#x27;foo&#x27;)</span><br><span class="line"></span><br><span class="line">fooRef.value++</span><br><span class="line">console.log(state.foo) // 2</span><br><span class="line"></span><br><span class="line">state.foo++</span><br><span class="line">console.log(fooRef.value) // 3</span><br></pre></td></tr></table></figure>

<p>当你要将 <code>prop</code> 的 <code>ref</code> 传递给复合函数时，<code>toRef</code> 很有用：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    useSomeFeature(toRef(props, &#x27;foo&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使源<code>property</code>不存在，<code>toRef</code> 也会返回一个可用的<code>ref</code>。这使得它在使用可选<code>prop</code>时特别有用，可选<code>prop</code>并不会被 <code>toRefs</code> 处理。</p>
<h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>将响应式对象转换为普通对象，其中结果对象的每个 <code>property</code> 都是指向原始对象相应 <code>property</code> 的 <code>ref</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const state = reactive(&#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const stateAsRefs = toRefs(state)</span><br><span class="line">/*</span><br><span class="line">stateAsRefs 的类型:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  foo: Ref&lt;number&gt;,</span><br><span class="line">  bar: Ref&lt;number&gt;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// ref 和原始 property 已经“链接”起来了</span><br><span class="line">state.foo++</span><br><span class="line">console.log(stateAsRefs.foo.value) // 2</span><br><span class="line"></span><br><span class="line">stateAsRefs.foo.value++</span><br><span class="line">console.log(state.foo) // 3</span><br></pre></td></tr></table></figure>

<p>当从组合式函数返回响应式对象时，<code>toRefs</code> 非常有用，这样消费组件就可以在不丢失响应性的情况下对返回的对象进行解构/展开：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function useFeatureX() &#123;</span><br><span class="line">  const state = reactive(&#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 操作 state 的逻辑</span><br><span class="line"></span><br><span class="line">  // 返回时转换为ref</span><br><span class="line">  return toRefs(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 可以在不失去响应性的情况下解构</span><br><span class="line">    const &#123; foo, bar &#125; = useFeatureX()</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toRefs</code> 只会为源对象中包含的<code>property</code>生成<code>ref</code>。如果要为特定的<code>property</code>创建<code>ref</code>，则应当使用 <code>toRef</code>。</p>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p>创建一个自定义的 <code>ref</code>，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收 <code>track</code> 和 <code>trigger</code> 函数作为参数，并且应该返回一个带有 <code>get</code> 和 <code>set</code> 的对象。</p>
<p>这个在我们自定义响应式的时候非常有用。比如我们在获取、设置值的时候做些特殊处理。</p>
<p>这个在<code>vue2</code>中是没办法直接修改响应值的实现的，但是在<code>vue3</code>可以。</p>
<p>下面是一个延迟响应式的例子。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;customref&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;input v-model=&quot;text&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, customRef &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const useDebouncedRef = (value, delay = 2000) =&gt; &#123;</span><br><span class="line">      let timeout;</span><br><span class="line">      return customRef((track, trigger) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          get() &#123;</span><br><span class="line">            track();</span><br><span class="line">            return value;</span><br><span class="line">          &#125;,</span><br><span class="line">          set(newValue) &#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">              value = newValue;</span><br><span class="line">              trigger();</span><br><span class="line">            &#125;, delay);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: useDebouncedRef(&quot;randy&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef"></a>triggerRef</h3><p>手动执行与 <code>shallowRef</code> 关联的任何作用 (<code>effect</code>)。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const shallow = shallowRef(&#123;</span><br><span class="line">  greet: &#x27;Hello, world&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 第一次运行时输出&quot;Hello, world&quot;</span><br><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">  console.log(shallow.value.greet)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 这不会触发作用 (effect)，因为 ref 是浅层的</span><br><span class="line">shallow.value.greet = &#x27;Hello, universe&#x27;</span><br><span class="line"></span><br><span class="line">// 触发watchEffect 输出&quot;Hello, universe&quot;</span><br><span class="line">triggerRef(shallow)</span><br></pre></td></tr></table></figure>

<h2 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h2><p>为了让相关代码更紧凑<code>vue3</code>提出了组合式<code>api</code>，组合式<code>api</code>能将同一个逻辑关注点相关代码收集在一起。 组合式<code>api</code>的入口就是<code>setup</code>方法。</p>
<h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>用官方语言说，<code>setup</code>是一个组件选项，在组件被创建<strong>之前</strong>，<code>props</code> 被解析之后执行。它是组合式 <code>API</code> 的入口。</p>
<p><code>setup</code>的写法有两种，可以跟<code>vue2</code>一样直接导出也可以导出<code>defineComponent</code>对象。若要对传递给 <code>setup()</code> 的参数进行类型推断，你需要使用 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https%253A%252F%252Fv3.cn.vuejs.org%252Fapi%252Fglobal-api.html%2523definecomponent">defineComponent</a>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 直接export</span><br><span class="line">export default &#123;</span><br><span class="line">  setup()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line">// 导出defineComponent对象</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>从生命周期的角度来看，它会在<code>beforeCreate</code>之前执行。也就是创建组件会依次执行<code>setup</code>、<code>beforeCreate</code>、<code>create</code>。</p>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例。<code>setup</code> 的调用发生在 <code>data</code> property、<code>computed</code> property 或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。<code>props</code>就是我们父组件给子组件传递的参数。</p>
<p>正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 <code>prop</code> 时，它将被更新。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 <code>props</code> 是响应式的，你<strong>不能使用 ES6 解构</strong>，它会消除 prop 的响应性。</p>
</blockquote>
<p>如果需要解构请使用<code>toRefs</code>方法。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent, toRefs &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    const &#123; title &#125; = toRefs(props)</span><br><span class="line">    console.log(title.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果 <code>title</code> 是可选的 <code>prop</code>，则传入的 <code>props</code> 中可能没有 <code>title</code> 。在这种情况下，<code>toRefs</code> 将不会为 <code>title</code> 创建一个 <code>ref</code> 。你需要使用 <code>toRef</code> 替代它：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent, toRef &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    const title = toRef(props, &#x27;title&#x27;)</span><br><span class="line">    console.log(title.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p><code>context</code> 是一个普通的 <code>JavaScript</code> 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 <code>ES6</code> 解构。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    // Attribute (非响应式对象，等同于 $attrs)</span><br><span class="line">    console.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    // 插槽 (非响应式对象，等同于 $slots)</span><br><span class="line">    console.log(context.slots)</span><br><span class="line"></span><br><span class="line">    // 触发事件 (方法，等同于 $emit)</span><br><span class="line">    console.log(context.emit)</span><br><span class="line"></span><br><span class="line">    // 暴露公共 property (函数)</span><br><span class="line">    console.log(context.expose)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 <code>property</code>。请注意，与 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 的 <code>property</code> 是<strong>非</strong>响应式的。如果你打算根据 <code>attrs</code> 或 <code>slots</code> 的更改应用副作用，那么应该在 <code>onBeforeUpdate</code> 生命周期钩子中执行此操作。</p>
<p>这里我们重点说下<code>expose</code>的使用。</p>
<p>假如我们想在父组件中直接调用子组件的方法该怎么做呢？我们就可以在子组件中使用<code>expose</code>把属性或方法暴露出去。在父组件我们就可以通过子组件的<code>ref</code>直接调用了。</p>
<p>使用的时候需要注意：</p>
<ol>
<li>当组件没定义<code>expose</code>暴露内容的时候，通过<code>ref</code>获取到的就是组件自身的内容，也就是<code>setup</code>函数<code>return</code>的内容。</li>
<li>当定义了<code>expose</code>暴露内容的时候，通过ref获取到的就是组件<code>expose</code>暴露内容，并且<code>setup</code>函数<code>return</code>的内容会失效，也就是会被覆盖。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;child&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup(props, &#123; expose &#125;) &#123;</span><br><span class="line">    const childSay = () =&gt; &#123;</span><br><span class="line">      console.log(&quot;childSay&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    const sex = &#x27;male&#x27;</span><br><span class="line"></span><br><span class="line">    // 如果定义了会覆盖return中的内容</span><br><span class="line">    // expose(&#123;</span><br><span class="line">    //   sex</span><br><span class="line">    // &#125;);</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">      childSay,</span><br><span class="line">      childSay</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;LifeChild ref=&quot;childRef&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  onMounted,</span><br><span class="line">  ref,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">import LifeChild from &quot;@/components/LifeChild&quot;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    LifeChild,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const childRef = ref(null);</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      // 使用子组件暴露的属性和方法</span><br><span class="line">      childRef.value.childSay(); // childSay</span><br><span class="line">      console.log(childRef.value.sex); // male</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      childRef,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。所以我们在模板中需要使用到的数据都需要通过<code>setup</code>方法<code>return</code>出来。</p>
<p>上面的话怎么理解呢？就是我们在模板，或者<code>vue2</code>选项式写法的计算属性、方法、生命周期钩子等等中使用的数据都需要在<code>setup</code>方法中通过<code>return</code>返回出来。</p>
<h3 id="结合模板使用"><a href="#结合模板使用" class="headerlink" title="结合模板使用"></a>结合模板使用</h3><p>如果 <code>setup</code> 返回一个对象，那么该对象的 <code>property</code> 以及传递给 <code>setup</code> 的 <code>props</code> 参数中的 <code>property</code> 就都可以在模板中访问到。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; collectionName &#125;&#125;: &#123;&#123; number &#125;&#125; &#123;&#123; user.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, reactive, defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      // 这个属性能直接在模板中使用</span><br><span class="line">      collectionName: String</span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">      // 在setup函数中需要通过props获取。</span><br><span class="line">      console.log(props.collectionName)</span><br><span class="line">      </span><br><span class="line">      // 定义响应式数据</span><br><span class="line">      const number = ref(0)</span><br><span class="line">      const user = reactive(&#123; name: &#x27;randy&#x27; &#125;)</span><br><span class="line"></span><br><span class="line">      // 暴露给 template</span><br><span class="line">      return &#123;</span><br><span class="line">        number,</span><br><span class="line">        user</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们通过<code>ref</code>、<code>reactive</code>创建了响应式数据，具体差别后面会再细说。</p>
<h3 id="结合渲染函数使用"><a href="#结合渲染函数使用" class="headerlink" title="结合渲染函数使用"></a>结合渲染函数使用</h3><p><code>setup</code> 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h, ref, reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const number = ref(0)</span><br><span class="line">    const user = reactive(&#123; name: &#x27;randy&#x27; &#125;)</span><br><span class="line">    // 请注意这里我们需要显式使用 ref 的 value</span><br><span class="line">    return () =&gt; h(&#x27;div&#x27;, [number.value, user.name])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个渲染函数将阻止我们返回任何其它的东西。我们可以通过我们上面介绍的 <code>expose</code> 来解决这个问题，给它传递一个对象，其中定义的<code>property</code>将可以被外部组件实例访问。</p>
<h3 id="单文件setup"><a href="#单文件setup" class="headerlink" title="单文件setup"></a>单文件setup</h3><p>要使用这个语法，需要将 <code>setup</code> attribute 添加到 <code>&lt;script&gt;</code> 代码块上：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">console.log(&#x27;hello script setup&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>里面的代码会被编译成组件 <code>setup()</code> 函数的内容。这意味着与普通的 <code>&lt;script&gt;</code> 只在组件被首次引入的时候执行一次不同，<code>&lt;script setup&gt;</code> 中的代码会在<strong>每次组件实例被创建的时候执行</strong>。</p>
<h3 id="顶层的绑定会被暴露给模板"><a href="#顶层的绑定会被暴露给模板" class="headerlink" title="顶层的绑定会被暴露给模板"></a>顶层的绑定会被暴露给模板</h3><p>当使用 <code>&lt;script setup&gt;</code> 的时候，任何在 <code>&lt;script setup&gt;</code> 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容) 都能在模板中直接使用：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">// 变量</span><br><span class="line">const msg = &#x27;Hello!&#x27;</span><br><span class="line"></span><br><span class="line">// 函数</span><br><span class="line">function log() &#123;</span><br><span class="line">  console.log(msg)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click=&quot;log&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>import 导入的内容也会以同样的方式暴露。意味着可以在模板表达式中直接使用导入的 helper 函数，并不需要通过 <code>methods</code> 选项来暴露它：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; capitalize &#125; from &#x27;./helpers&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; capitalize(&#x27;hello&#x27;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>响应式状态需要明确使用响应式 APIs来创建。和从 <code>setup()</code> 函数中返回值一样，<code>ref</code> 值在模板中使用的时候会自动解包：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><script setup> 范围里的值也能被直接作为自定义组件的标签名使用：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import MyComponent from &#x27;./MyComponent.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;MyComponent /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

将 `MyComponent` 看做被一个变量所引用。如果你使用过 JSX，在这里的使用它的心智模型是一样的。其 kebab-case 格式的 `<my-component>` 同样能在模板中使用。不过，我们强烈建议使用 PascalCase 格式以保持一致性。同时也有助于区分原生的自定义元素。


动态组件

由于组件被引用为变量而不是作为字符串键来注册的，在 `<script setup>` 中要使用动态组件的时候，就应该使用动态的 `:is` 来绑定：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Foo from &#x27;./Foo.vue&#x27;</span><br><span class="line">import Bar from &#x27;./Bar.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component :is=&quot;Foo&quot; /&gt;</span><br><span class="line">  &lt;component :is=&quot;someCondition ? Foo : Bar&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

### 递归组件

一个单文件组件可以通过它的文件名被其自己所引用。例如：名为 `FooBar.vue` 的组件可以在其模板中用 `<FooBar/>` 引用它自己。

请注意这种方式相比于 import 导入的组件优先级更低。如果有命名的 import 导入和组件的推断名冲突了，可以使用 import 别名导入：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FooBar as FooBarChild &#125; from &#x27;./components&#x27;</span><br></pre></td></tr></table></figure>

### 命名空间组件

可以使用带点的组件标记，例如 `<Foo.Bar>` 来引用嵌套在对象属性中的组件。这在需要从单个文件中导入多个组件的时候非常有用：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import * as Form from &#x27;./form-components&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Form.Input&gt;</span><br><span class="line">    &lt;Form.Label&gt;label&lt;/Form.Label&gt;</span><br><span class="line">  &lt;/Form.Input&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

### 使用自定义指令

全局注册的自定义指令将以符合预期的方式工作，且本地注册的指令可以直接在模板中使用，就像上文所提及的组件一样。

但这里有一个需要注意的限制：必须以 `vNameOfDirective` 的形式来命名本地自定义指令，以使得它们可以直接在模板中使用。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const vMyDirective = &#123;</span><br><span class="line">  beforeMount: (el) =&gt; &#123;</span><br><span class="line">    // 在元素上做些操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 v-my-directive&gt;This is a Heading&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 导入的指令同样能够工作，并且能够通过重命名来使其符合命名规范</span><br><span class="line">  import &#123; myDirective as vMyDirective &#125; from &#x27;./MyDirective.js&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### `defineProps` 和 `defineEmits`

在 `<script setup>` 中必须使用 `defineProps` 和 `defineEmits` API 来声明 `props` 和 `emits` ，它们具备完整的类型推断并且在 `<script setup>` 中是直接可用的：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  foo: String</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const emits = defineEmits([&#x27;change&#x27;, &#x27;delete&#x27;])</span><br><span class="line"></span><br><span class="line">//触发事件 类似 context.emit()</span><br><span class="line">emits(&#x27;change&#x27;, &#123;name: &#x27;randy&#x27;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

`defineProps` 和 `defineEmits` 都是只在 `<script setup>` 中才能使用的**编译器宏**。他们不需要导入且会随着 `<script setup>` 处理过程一同被编译掉。

`defineProps` 接收与 `props`相同的值，`defineEmits` 也接收 `emits`相同的值。

传入到 `defineProps` 和 `defineEmits` 的选项会从 setup 中提升到模块的范围。因此，传入的选项不能引用在 setup 范围中声明的局部变量。这样做会引起编译错误。但是，它*可以*引用导入的绑定，因为它们也在模块范围内。

defineExpose

使用 `<script setup>` 的组件是**默认关闭**的，也即通过模板 ref 或者 `$parent` 链获取到的组件的公开实例，不会暴露任何在 `<script setup>` 中声明的绑定。

为了在 `<script setup>` 组件中明确要暴露出去的属性，使用 `defineExpose` 编译器宏，他也是不需要导入且会随着 `<script setup>` 处理过程一同被编译掉。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const a = 1</span><br><span class="line">const b = ref(2)</span><br><span class="line"></span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

当父组件通过模板 ref 的方式获取到当前组件的实例，获取到的实例可以获取到`a 、b`属性 (ref 会和在普通实例中一样被自动解包)。跟前面说的`expose`是一样的。

### useSlots 和 useAttrs

在 `<script setup>` 使用 `slots` 和 `attrs` 的情况应该是很罕见的，因为可以在模板中通过 `$slots` 和 `$attrs` 来访问它们。在你的确需要使用它们的罕见场景中，可以分别用 `useSlots` 和 `useAttrs` 两个辅助函数：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useSlots, useAttrs &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const slots = useSlots()</span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

`useSlots` 和 `useAttrs` 是真实的运行时函数，它会返回与 `setupContext.slots` 和 `setupContext.attrs` 等价的值，同样也能在普通的组合式 API 中使用。

### 与普通的 `<script>` 一起使用

<script setup> 可以和普通的 <script> 一起使用。普通的 <script> 在有这些需要的情况下或许会被使用到：

- 无法在 `<script setup>` 声明的选项，例如 `inheritAttrs` 或通过插件启用的自定义的选项。
- 声明命名导出。
- 运行副作用或者创建只需要执行一次的对象。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 普通 &lt;script&gt;, 在模块范围下执行(只执行一次)</span><br><span class="line">runSideEffectOnce()</span><br><span class="line"></span><br><span class="line">// 声明额外的选项</span><br><span class="line">export default &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  customOptions: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// 在 setup() 作用域中执行 (对每个实例皆如此)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

> 该场景下不支持使用 `render` 函数。请使用一个普通的 `<script>` 结合 `setup` 选项来代替。

### 顶层 `await`

<script setup> 中可以使用顶层 await。结果代码会被编译成 async setup()：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const post = await fetch(`/api/post/1`).then(r =&gt; r.json())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

另外，`await` 的表达式会自动编译成在 `await` 之后保留当前组件实例上下文的格式。

> 注意 `async setup()` 必须与 `Suspense` 组合使用，`Suspense` 目前还是处于实验阶段的特性。

### 不能和src混合使用

<script setup> 不能和 src attribute 一起使用。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 不能同时使用</span><br><span class="line">&lt;script setup src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

## computed和watch

计算属性和监听器

### computed

`computed`是计算属性，意思就是会缓存值，只有当依赖属性发生变化的时候才会重新计算。

在`vue2`中计算属性很简单，是一个对象，只需要简单定义就可以使用。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  // 计算属性默认只有 get，不过在需要时你也可以提供一个 set</span><br><span class="line">  fullName() &#123;</span><br><span class="line">    return this.firstName + this.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  fullName2: &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return this.firstName + this.lastName + &quot;2&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 提供set方法后计算属性的值可以更改了</span><br><span class="line">    set(newVal) &#123;</span><br><span class="line">      const names = newVal.split(&quot; &quot;);</span><br><span class="line">      this.firstName = names[0];</span><br><span class="line">      this.lastName = names[1];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

在`vue3`中，是函数式的，并且需要先引入。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; user1.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; user1.age &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; fullName1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;updateUser1Name&quot;&gt;update user1 name&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;&#123;&#123; user2.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; user2.age &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; fullName2 &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;updateUser2Name&quot;&gt;update user2 name&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, reactive, computed &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const user1 = reactive(&#123; name: &quot;randy1&quot;, age: 24 &#125;);</span><br><span class="line">    // 接受一个 getter 函数，并根据 getter 的返回值返回一个不可变的响应式 ref 对象</span><br><span class="line">    // 这里的fullName1是不能修改的</span><br><span class="line">    const fullName1 = computed(() =&gt; &#123;</span><br><span class="line">      return `$&#123;user1.name&#125;今年$&#123;user1.age&#125;岁啦`;</span><br><span class="line">    &#125;);</span><br><span class="line">    const updateUser1Name = () =&gt; &#123;</span><br><span class="line">      user1.name += &quot;!&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const user2 = reactive(&#123; name: &quot;randy2&quot;, age: 27 &#125;);</span><br><span class="line">    // 接受一个具有 get 和 set 函数的对象，用来创建可写的 ref 对象。</span><br><span class="line">    // 这里的fullName2是可以修改的</span><br><span class="line">    let fullName2 = computed(&#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return `$&#123;user2.name&#125;今年$&#123;user2.age&#125;岁啦`;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(val) &#123;</span><br><span class="line">        user2.name = val;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    const updateUser2Name = () =&gt; &#123;</span><br><span class="line">      // 需要使用value访问</span><br><span class="line">      fullName2.value = &quot;新的name&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      user1,</span><br><span class="line">      fullName1,</span><br><span class="line">      updateUser1Name,</span><br><span class="line">      user2,</span><br><span class="line">      fullName2,</span><br><span class="line">      updateUser2Name,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### watchEffect

立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。

怎么理解这句话呢？就是它会自动收集依赖，不需要手动传入依赖。当里面用到的数据发生变化时就会自动触发`watchEffect`。并且`watchEffect`会先执行一次用来自动收集依赖。而且`watchEffect`无法获取到变化前的值，只能获取变化后的值。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, reactive, watchEffect &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">   const user2 = reactive(&#123; name: &quot;randy2&quot;, age: 27 &#125;);</span><br><span class="line">  </span><br><span class="line">    const updateUser2Age = () =&gt; &#123;</span><br><span class="line">      user2.age++;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    watchEffect(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;watchEffect&quot;, user2.age);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在上面这个例子中，首先会执行`watchEffect`输出27，当我们触发`updateUser2Age`方法改变`age`的时候，因为`user2.age`是`watchEffect`的依赖，所以`watchEffect`会再次执行，输出28。

这个方法可以鸡蛋理解为`created`、`beforeDestory`和`watch`的组合。

### 停止侦听

当 `watchEffect` 在组件的 `setup()` 函数或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。

在一些情况下，也可以显式调用返回值以停止侦听：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const stop = watchEffect(() =&gt; &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// later</span><br><span class="line">stop()</span><br></pre></td></tr></table></figure>

### 清除副作用

有时副作用函数会执行一些异步的副作用，这些响应需要在其失效时清除。所以侦听副作用传入的函数可以接收一个 `onInvalidate` 函数作入参，用来注册清理失效时的回调。当以下情况发生时，这个失效回调会被触发：

- 副作用即将重新执行时
- 侦听器被停止 (如果在 `setup()` 或生命周期钩子函数中使用了 `watchEffect`，则在组件卸载时)

清除副作用很多同学可能不太理解，下面笔者用个例子解释下。

假设我们需要在`input`框输入关键字进行实时搜索，又不想请求太频繁我们就可以用到这个功能了。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;text&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">const text = ref(&quot;randy&quot;);</span><br><span class="line"></span><br><span class="line">watchEffect((onInvalidate) =&gt; &#123;</span><br><span class="line">  const timer = setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;input&quot;, text.value);</span><br><span class="line">    // 模拟调用后端接口</span><br><span class="line">    // getDate(text.value)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">  </span><br><span class="line">  onInvalidate(() =&gt; &#123;</span><br><span class="line">    // 清除上一次请求</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(&quot;watchEffect&quot;, text.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

上面的例子中`watchEffect`依赖了`text.value`，所以我们只要在`input`输入值就会立马进入`watchEffect`。如果不处理的话后端服务压力可能会很大，因为我们只要输入框值改变了就会发送请求。

我们可以利用清除副作用回调函数，在用户输入完一秒后再向后端发送请求。因为第一次是不会执行`onInvalidate`回调方法的，只有在副作用重新执行或卸载的时候才会执行该回调函数。

所以在我们输入的时候，会一直输出`"watchEffect" text对应的值`，当我们停止输入一秒后会输出`"input" text对应的值`，然后发送请求给后端。这样就达到我们最开始的目标了。

类似的还可以应用到事件监听上。这个小伙伴们可以自己试试。

### 副作用刷新时机

`Vue` 的响应性系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个“tick” 中多个状态改变导致的不必要的重复调用。在核心的具体实现中，组件的 `update` 函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 `update` **前**执行。也就是会在组件生命周期函数`onBeforeUpdate`之前执行。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const updateUser2Age = () =&gt; &#123;</span><br><span class="line">  user2.age++;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    console.log(&quot;watchEffect&quot;, user2.age);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;onBeforeUpdate&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

上面的例子，当我们触发`updateUser2Age`方法修改`age`的时候，会先执行`watchEffect`然后执行`onBeforeUpdate`。

如果需要在组件更新**后**重新运行侦听器副作用，我们可以传递带有 `flush` 选项的附加 `options` 对象 (默认为 `pre`)。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const updateUser2Age = () =&gt; &#123;</span><br><span class="line">  user2.age++;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    console.log(&quot;watchEffect&quot;, user2.age);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: &quot;post&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;onBeforeUpdate&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

上面的例子，当我们触发`updateUser2Age`方法修改`age`的时候，会先执行`onBeforeUpdate`然后执行`watchEffect`。

`flush` 选项还接受 `sync`，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。`sync`这个参数是什么意思呢？很多同学可能不理解，这里我们重点解释下。

当`watchEffect`只有一个依赖的时候这个参数和`pre`是没区别的。但是当有多个依赖的时候，`flush: post`和 `flush: pre`只会执行一次副作用，但是`sync`会执行多次，也就是有一个依赖改变就会执行一次。

下面我们看例子

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const user3 = reactive(&#123; name: &quot;randy3&quot;, age: 27 &#125;);</span><br><span class="line"></span><br><span class="line">const updateUser3NameAndAge = () =&gt; &#123;</span><br><span class="line">  user3.name += &quot;!&quot;;</span><br><span class="line">  user3.age++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    console.log(&quot;watchEffect&quot;, user3.name, user3.age);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: &quot;sync&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;onBeforeUpdate&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

在上面的例子中，`watchEffect`有`name`和`age`两个依赖，当我们触发`updateUser3NameAndAge`方法的时候，如果`flush: "sync"`这个副作用会执行两次，依次输出`watchEffect randy3! 27`、`watchEffect randy3! 28`、`onBeforeUpdate`。

如果你想让每个依赖发生变化都执行`watchEffect`但又不想设置`flush: "sync"`你也可以使用`nextTick`等待侦听器在下一步改变之前运行。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">const updateUser3NameAndAge = async () =&gt; &#123;</span><br><span class="line">  user3.name += &quot;!&quot;;</span><br><span class="line">  await nextTick()</span><br><span class="line">  user3.age++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

上面的例子会依次输出`watchEffect randy3! 27`、`onBeforeUpdate`、`watchEffect randy3! 28`、`onBeforeUpdate`。

从 `Vue 3.2.0` 开始，我们也可以使用别名方法`watchPostEffect` 和 `watchSyncEffect`，这样可以用来让代码意图更加明显。

### watchPostEffect

`watchPostEffect`就是`watchEffect` 的别名，带有 `flush: 'post'` 选项。

### watchSyncEffect

`watchSyncEffect`就是`watchEffect` 的别名，带有 `flush: 'sync'` 选项。

### 侦听器调试

`onTrack` 和 `onTrigger` 选项可用于调试侦听器的行为。

- `onTrack` 将在响应式 `property` 或 `ref` 作为依赖项被追踪时被调用。
- `onTrigger` 将在依赖项变更导致副作用被触发时被调用。

这个有点类似前面说的生命周期函数`renderTracked`和`renderTriggered`，一个最初次渲染时调用，一个在数据更新的时候调用。

这两个回调都将接收到一个包含有关所依赖项信息的调试器事件。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    /* 副作用 */</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    onTrack(e) &#123;</span><br><span class="line">      console.log(&quot;onTrack: &quot;, e);</span><br><span class="line">    &#125;,</span><br><span class="line">    onTrigger(e) &#123;</span><br><span class="line">      console.log(&quot;onTrigger:&quot;, e);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

> `onTrack` 和 `onTrigger` 只能在开发模式下工作。

### watch

`watch` 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生变化时被调用。

与 `watchEffect` 相比，`watch` 有如下特点

1. 惰性地执行副作用
2. 更具体地说明应触发侦听器重新运行的状态
3. 可以访问被侦听状态的先前值和当前值

我们首先来看看在`vue2`中我们是怎么监听的。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  // 监听title属性</span><br><span class="line">  title1(newVal, oldVal) &#123;</span><br><span class="line">    console.log(newVal, oldVal);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 监听某一个对象</span><br><span class="line">  obj3: &#123;</span><br><span class="line">    handler(newVal, oldVal) &#123;</span><br><span class="line">      console.log(newVal, oldVal); // 引用数据类型这里输出的值都是一样的</span><br><span class="line">    &#125;,</span><br><span class="line">    // 深度监听</span><br><span class="line">    deep: true,</span><br><span class="line">    // 立即执行</span><br><span class="line">    // immediate: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  // 监听对象某属性</span><br><span class="line">  &quot;obj3.age&quot;(newVal, oldVal) &#123;</span><br><span class="line">    console.log(newVal, oldVal);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 数组回调函数，里面的方法都会执行</span><br><span class="line">  title2: [</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      console.log(&quot;修改了title2-1&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      console.log(&quot;修改了title2-2&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

或者

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$watch(&#x27;title1&#x27;, callback(newVal, oldVal), &#123; deep: true, immediate: true &#125;)</span><br></pre></td></tr></table></figure>

接下来我们来看看`vue3`中的监听。

`vue3`中`watch`方法有三个参数

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// source: 可以支持 string,Object,Function,Array; 用于指定要侦听的响应式变量</span><br><span class="line">// callback: 执行的回调函数</span><br><span class="line">// options：支持 deep、immediate 和 flush 选项。</span><br><span class="line">watch(source, callback, options)</span><br></pre></td></tr></table></figure>

### 监听单一源

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, reactive, watchEffect &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const user1 = reactive(&#123; name: &quot;randy1&quot;, age: 24 &#125;);</span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; user1.name,</span><br><span class="line">      (newVal, oldVal) =&gt; &#123;</span><br><span class="line">        console.log(newVal, oldVal);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; user1.age,</span><br><span class="line">      (newVal, oldVal) =&gt; &#123;</span><br><span class="line">        console.log(newVal, oldVal);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### 监听多个源

监听多个源我们使用数组。

这里我们需要注意，监听多个源只要有一个源发生变化，回调函数都会执行。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, reactive, watchEffect &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const user1 = reactive(&#123; name: &quot;randy1&quot;, age: 24 &#125;);</span><br><span class="line">    watch(</span><br><span class="line">      [() =&gt; user1.name, () =&gt; user1.age],</span><br><span class="line">      ([newVal1, newVal2], [oldVal1, oldVal2]) =&gt; &#123;</span><br><span class="line">        console.log(newVal1, newVal2);</span><br><span class="line">        console.log(oldVal1, oldVal2);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### 监听引用数据类型

有时我们可能需要监听一个对象的改变，而不是具体某个属性。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const user2 = reactive(&#123; name: &quot;randy2&quot;, age: 27 &#125;);</span><br><span class="line">watch(</span><br><span class="line">  user2 ,</span><br><span class="line">  (newVal, oldVal) =&gt; &#123;</span><br><span class="line">    console.log(newVal, oldVal); // &#123;name: &#x27;randy2&#x27;, age: 28&#125; &#123;name: &#x27;randy2&#x27;, age: 28&#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const updateUser2Age = () =&gt; &#123;</span><br><span class="line">  user2.age++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

上面的写法有没有问题呢？当我们触发`updateUser2Age`方法修改`age`的时候可以发现我们输出`newVal, oldVal`两个值是一样的。这就是引用数据类型的坑。当我们不需要知道`oldVal`的时候这样写没问题，但是当我们需要对比新老值的时候这种写法就不行了。


我们需要监听这个引用数据类型的拷贝。当引用数据类型简单的时候我们可以直接解构成新对象，但是当引用数据类型复杂的时候我们就需要用到深拷贝了。深拷贝前面笔者有文章介绍，可以自己写深拷贝方法或者引用`lodash`库。

这样输出来的值才是正确的。

`vue2`中好像没办法解决这个问题。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const user2 = reactive(&#123; name: &quot;randy2&quot;, age: 27 &#125;);</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; (&#123; ...user2 &#125;),</span><br><span class="line">  (newVal, oldVal) =&gt; &#123;</span><br><span class="line">    console.log(newVal, oldVal); // &#123;name: &#x27;randy2&#x27;, age: 28&#125; &#123;name: &#x27;randy2&#x27;, age: 27&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const updateUser2Age = () =&gt; &#123;</span><br><span class="line">  user2.age++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

`watch`除了支持`vue2`的深度监听`deep: true`和立即执行`immediate: true`还支持 `watchEffect`的停止侦听、清除副作用、副作用刷新时机、侦听器调试，用法是一样的这里笔者就不再赘述了，小伙伴们可以自行研究。

## teleport

`teleport` 提供了一种干净的方法，允许我们控制在 `DOM` 中哪个父节点下渲染了 `HTML`，而不必求助于全局状态或将其拆分为两个组件。

什么意思呢？就是我们组件的`html`节点可以通过`teleport`挂载到任意位置。

比如我们的`about`组件里面就可以通过`<teleport to="#app">`把`<div>我是通过teleport传递过来的，挂载在app下面</div>`挂载到`id`为`app`的`html`节点下。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">    &lt;teleport to=&quot;#app&quot;&gt;</span><br><span class="line">      &lt;div&gt;我是通过teleport传递过来的，挂载在app下面&lt;/div&gt;</span><br><span class="line">    &lt;/teleport&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

我们来看看渲染效果，发现我们写在`about`页面的元素被挂载到了`app`节点下。



![img](https://pic2.zhimg.com/80/v2-741aba49bd5a48c6cf8bcdd86e849c85_720w.webp)



`teleport`的`to`属性必须是有效的查询选择器或 `HTMLElement`

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确 --&gt;</span><br><span class="line">&lt;teleport to=&quot;#some-id&quot; /&gt;</span><br><span class="line">&lt;teleport to=&quot;.some-class&quot; /&gt;</span><br><span class="line">&lt;teleport to=&quot;[data-teleport]&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 错误 --&gt;</span><br><span class="line">&lt;teleport to=&quot;h1&quot; /&gt;</span><br><span class="line">&lt;teleport to=&quot;some-string&quot; /&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

`teleport`还支持`disabled`选项。此可选属性可用于禁用 `<teleport>` 的功能，这意味着其插槽内容将不会移动到任何位置，而是在你在周围父组件中指定了 `<teleport>` 的位置渲染。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;#app&quot; :disabled=&quot;displayVideoInline&quot;&gt;</span><br><span class="line">  &lt;video src=&quot;./my-movie.mp4&quot;&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>

## Suspense

我们在`vue2`中肯定写过这样的代码

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div v-if=&quot;!loading&quot;&gt;</span><br><span class="line">        ...页面内容</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-if=&quot;loading&quot;&gt;</span><br><span class="line">        加载中...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

`Suspense`就是用来更优雅的展示内容。需要搭配`defineAsyncComponent`使用。

`<suspense>` 组件有两个插槽。它们都只接收一个直接子节点。`default` 插槽里的节点会尽可能展示出来。如果不能，则展示 `fallback` 插槽里的节点。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Suspense&gt;</span><br><span class="line">    &lt;template #default&gt;</span><br><span class="line">      &lt;AsyncPage /&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template #fallback&gt;</span><br><span class="line">      &lt;div&gt;Loading...&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/Suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import &#123; defineComponent,  defineAsyncComponent &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    // 无配置项异步组件</span><br><span class="line">    AsyncPage: defineAsyncComponent(() =&gt; import(&quot;@/components/AsyncCom.vue&quot;)),</span><br><span class="line">    </span><br><span class="line">    // 有配置项异步组件</span><br><span class="line">    // AsyncPage: defineAsyncComponent(&#123;</span><br><span class="line">    //   loader: () =&gt; import(&quot;@/components/AsyncCom.vue&quot;),</span><br><span class="line">    //   delay: 3000,</span><br><span class="line">    //   timeout: 3000,</span><br><span class="line">    //   // errorComponent: () =&gt; import(&quot;./ErrorComponent.vue&quot;),</span><br><span class="line">    //   // loadingComponent: () =&gt; import(&quot;./LoadingComponent.vue&quot;),</span><br><span class="line">    // &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子组件 AsyncCom.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;hi 我是异步组件&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, inject, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  async setup() &#123;</span><br><span class="line">    // sleep 模拟后端请求接口</span><br><span class="line">    const sleep = (times) =&gt; &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, times);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 请求2秒</span><br><span class="line">    await sleep(2000);</span><br><span class="line"></span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

> 注意，Suspense 是一个试验性的新特性，其 API 可能随时会发生变动。特此声明，以便社区能够为当前的实现提供反馈。生产环境请勿使用。我们目前了解有这个东西即可。

## 多片段

`vue3`现在正式支持了多根节点的组件，也就是片段！什么意思呢？下面看个例子就明白了。

在 `vue2` 中，由于不支持多根节点组件，当其被开发者意外地创建时会发出警告。结果是，为了修复这个问题，许多组件被包裹在了一个 `<div>` 中。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Layout.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">    &lt;main&gt;...&lt;/main&gt;</span><br><span class="line">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

在 `vue3` 中，组件可以包含多个根节点！但是，这要求开发者显式定义 `attribute` 应该分布在哪里。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Layout.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

这一段是什么意思呢？我们先来说说`$attrs`。

### `$attrs`

在`vue2`中，我们知道`this.$attrs`包含了父作用域中不作为 `prop` 被识别 (且获取) 的 `attribute` 绑定 (`class` 和 `style` 除外)。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child3 :fullName=&quot;fullName&quot; :age=&quot;24&quot; class=&quot;child3&quot; id=&quot;child3&quot; style=&quot;color: blue&quot;&gt;&lt;/Child3&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">export default &#123;</span><br><span class="line">  // 设置inheritAttrs false 不接受没有在props中定义的属性</span><br><span class="line">  // inheritAttrs: false,</span><br><span class="line">  props: &#123;</span><br><span class="line">    fullName: String</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    // 获取没在props中定义的但是传递过来的属性</span><br><span class="line">    console.log(this.$attrs); // 输出&#123;age: 24, id: &#x27;child3&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面的例子输出没在子组件接收的`age`和`id`所以会输出`{age: 24, id: 'child3'}`(因为`class` 和 `style`会被忽略)。

在`vue3`中有了更改，`attrs`被转移到`setup`的第二个参数`context`上，`context.attrs`。**并且class 和 style也都不再忽略了**。也就是说`class` 和 `style`也会在`attrs`里面。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child2 v-model:name1=&quot;name1&quot; v-model:name2=&quot;name2&quot; class=&quot;child2&quot; id=&quot;child2&quot; style=&quot;color: blue&quot;&gt;&lt;/Child3&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name1: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    // 获取没在props中定义的但是传递过来的属性</span><br><span class="line">    console.log(context.attrs); // 输出&#123;name2: &#x27;randy&#x27;, class: &#x27;child2&#x27;, id: &#x27;child2&#x27;, style: &#123;color: &#x27;blue&#x27;&#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面会输出全部未被接收的`prop`，输出`{age: 24, class: 'child3', id: 'child3', style: {color: 'blue'}}`。

在`vue2`中由于只有一个片段，所以未在`props`定义的属性会直接挂载在根片段上。但是`vue3`由于支持多个片段，所以如果使用了多片段并且有未在`props`定义的属性就会抛出警告，因为它不知道把这些未定义在`props`中的属性挂载到哪个片段上，所以就需要我们使用`v-bind="$attrs"`来显示指定了。


我们先来看看只有一个片段的时候，未定义在`props`中的属性都挂载在根片段上了。

![img](https://pic4.zhimg.com/80/v2-6d4178226964c9dbcfdc0af2661f5107_720w.webp)

但是我们使用多片段的时候它会提示警告，`[Vue warn]: Extraneous non-props attributes (name2, class, id, style) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`

当我们在第1个`div`定义`v-bind="$attrs"`后我们发现未定义在`props`中的属性都挂载在该片段上了。

![img](https://pic3.zhimg.com/80/v2-5eb4d04a40f608d4e11844feb8b5df7e_720w.webp)

看到这小伙伴们是不是就懂了呢。虽然`vue3`支持多片段，但是我们需要定义`v-bind="$attrs"`。

既然讲到了`$attrs`，我们再讲讲`$listeners`的改动

### `$listeners`

我们知道在`vue2`中`$listeners`包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。

但是在`vue3`，`$listeners`被移除了，父作用域中的事件监听器也被放到了`attrs`里面。相当于是合并在一起了。

## 生命周期改动

首先我们来看看`vue2`和`vue3`的生命周期函数。

`vue3`虽然提倡把生命周期函数都放到`setup`中，但是`vue2`那种选项式写法还是支持的。

![img](https://pic1.zhimg.com/80/v2-5870c8848dd1632a2c95bb70ad25f784_720w.webp)

总结

1. `vue2`相较于`vue3`少了`renderTracked`、`renderTriggered`两个生命周期方法。
2. 销毁生命周期方法名也发生了变化，由`beforeDestroy`、`destroyed`变为`beforeUnmount`、`unmounted`，这样是为了更好的与`beforeMount`、`mounted` 相对应。
3. `vue3`写在`setup`函数中生命周期方法名就是前面多加了`on`。


基本的生命周期函数我想不必笔者多说小伙伴们应该都很清楚了。下面重点说下 `renderTracked`、`renderTriggered` 两个方法。

### renderTracked

简单理解就是，首次渲染时，模板里面进行了哪些操作，以及该操作的目标对象和键。

如果有多个属性，这个方法会被触发多次。

我们来看例子

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;user: &#123;&#123; user.age &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  onRenderTracked,</span><br><span class="line">  onRenderTriggered,</span><br><span class="line">  ref,</span><br><span class="line">  reactive,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const name = ref(&quot;randy&quot;);</span><br><span class="line">    const user = reactive(&#123; age: 27 &#125;);</span><br><span class="line"></span><br><span class="line">    onRenderTracked((&#123; key, target, type &#125;) =&gt; &#123;</span><br><span class="line">      console.log(&quot;onRenderTracked&quot;, &#123; key, target, type &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    onRenderTriggered((&#123; key, target, type &#125;) =&gt; &#123;</span><br><span class="line">      console.log(&quot;onRenderTriggered&quot;, &#123; key, target, type &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      name,</span><br><span class="line">      user,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

页面首次加载只会触发`onRenderTracked`方法。

因为模板里面用到了`name`和`user.age`所以该方法会被触发两次输出`{key: 'value', target: RefImpl, type: 'get'}`和`{key: 'age', target: {age: 27}, type: 'get'}`。因为`name`是`ref`定义的，所以`key`始终是`value`，并且只是读操作，所以`type`为`get`。`user`是`reactive`定义的，并且我们只使用了`age`属性所以`key`是`age`并且只是读操作，所以`type`为`get`。

### renderTriggered

简单理解就是，页面更新渲染时，模板里面进行了哪些操作，以及该操作的目标对象和键。

如果有多个属性被修改，这个方法会被触发多次。

我们来看例子

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;changeName&lt;/button&gt;</span><br><span class="line">    &lt;div&gt;user: &#123;&#123; user.age &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  onRenderTracked,</span><br><span class="line">  onRenderTriggered,</span><br><span class="line">  ref,</span><br><span class="line">  reactive,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const name = ref(&quot;randy&quot;);</span><br><span class="line">    const changeName = () =&gt; &#123;</span><br><span class="line">      name.value = &quot;demi&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    const user = reactive(&#123; age: 27 &#125;);</span><br><span class="line"></span><br><span class="line">    onRenderTracked((&#123; key, target, type &#125;) =&gt; &#123;</span><br><span class="line">      console.log(&quot;onRenderTracked&quot;, &#123; key, target, type &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    onRenderTriggered((&#123; key, target, type &#125;) =&gt; &#123;</span><br><span class="line">      console.log(&quot;onRenderTriggered&quot;, &#123; key, target, type &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      name,</span><br><span class="line">      changeName,</span><br><span class="line">      user,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

我们点击`changeName`按钮来修改name，这里只会触发`onRenderTriggered`方法一次。并且输出`{key: 'value', target: RefImpl, type: 'set'}`，因为是修改所以`type`是`set`。

### 生命周期全流程

有些人可能好奇，所有的生命周期函数顺序到底是怎么样的呢？

我们分单组件和父子组件来说明。

### 单组件

**页面首次加载**

`setup -> onBeforeMount -> onRenderTracked -> onMounted`

**页面更新**

`onRenderTriggered -> onBeforeUpdate -> onUpdated`

**页面卸载**

`onBeforeUnmount -> onUnmounted`

### 父子组件

**页面首次加载**

`父组件setup -> 父组件onBeforeMount -> 父组件onRenderTracked -> 子组件setup -> 子组件onBeforeMount -> 子组件onRenderTracked -> 子组件onMounted -> 父组件onMounted`

**页面更新**

纯父组件属性更新 `onRenderTriggered -> onBeforeUpdate -> onUpdated`

纯子组件属性更新 `onRenderTriggered -> onBeforeUpdate -> onUpdated`

父组件属性更新，该属性在子组件中有被使用 `父组件onRenderTriggered -> 父组件onBeforeUpdate -> 子组件onBeforeUpdate -> 子组件onUpdated -> 父组件onUpdated`

子组件属性更新，该属性在父组件中有被使用 `子组件onRenderTriggered -> 父组件onRenderTriggered -> 父组件onBeforeUpdate -> 子组件onBeforeUpdate -> 子组件onUpdated -> 父组件onUpdated`

**页面卸载**

`父组件onBeforeUnmount -> 子组件onBeforeUnmount -> 子组件onUnmounted -> 父组件onUnmounted`

> 注意上面生命周期函数调用顺序在`vue2`中也是一致的，只不过`vue2`没有 `setup`、 `renderTracked`、`renderTriggered`，并且销毁方法是`beforeDestroy`、`destroyed`。

### hook名称修改

在 `vue2` 中，我们可以通过事件来监听组件生命周期中的关键阶段。这些事件名都是以 `hook:` 前缀开头，并跟随相应的生命周期钩子的名字。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;child-component @hook:updated=&quot;onUpdated&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

在 `vue3` 中，这个前缀已被更改为 `vnode-`。额外地，这些事件现在也可用于 HTML 元素，和在组件上的用法一样。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;child-component @vnode-updated=&quot;onUpdated&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

或者在驼峰命名法的情况下附带前缀 `vnode`：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;child-component @vnodeUpdated=&quot;onUpdated&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

## 全局API改动

任何全局改变 `Vue` 行为的 `API` 现在都会移动到应用实例上`app`上，以下是部分全局 `API` 及其相应实例 `API` 的表，如需了解很多可以查看官网。

### 位置变更

![img](https://pic2.zhimg.com/80/v2-66baa6862c873620c589f04d04916c19_720w.webp)

`app`通过`createApp`方法创建。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">const app = createApp(App);</span><br></pre></td></tr></table></figure>

### nextTick

在`vue2`中我们是这样使用的

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(() =&gt; &#123;&#125;)</span><br><span class="line">//或者</span><br><span class="line">Vue.nextTick(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>

在`vue3`中是这样的，需要手动引入

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; nextTick &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">nextTick(()=&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>

在`vue2`中`Vue.nextTick()` 这样的全局 API 是不支持 `tree-shake` 的，不管它们实际上是否被使用了，都会被包含在最终的打包产物中。

而`vue3`中的引入时写法可以`tree-shaking`能减少打包体积。

## 模板指令改动

### v-model

在`vue2`中 `v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。

`v-model` 在内部为不同的输入元素使用不同的 `property` 并抛出不同的事件：

- text 和 textarea 元素使用 `value` property 和 `input` 事件；
- checkbox 和 radio 使用 `checked` property 和 `change` 事件；
- select 字段将 `value` 作为 prop 并将 `change` 作为事件。

在`vue2`中只对上面几个表单项做了特殊处理。如果在自定义组件上使用`v-model`需要在组件内通过`model`参数指明`v-model`的属性和事件。

如果不指明`model`它的值默认是`value`，事件默认是`input`事件。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&#123;&#123; value2 &#125;&#125;</span><br><span class="line">&lt;Child4 v-model=&quot;value2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;value1&quot; @input=&quot;handleInput&quot; /&gt;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 定义v-model传过来的值名字是value1 修改值的事件是change事件</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &quot;value1&quot;,</span><br><span class="line">    event: &quot;change&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value1: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleInput(e) &#123;</span><br><span class="line">      this.$emit(&quot;change&quot;, e.target.value);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

有了`model`这样我们的自定义组件`Child4`也能使用`v-model`啦。在`input`输入框输入的时候会`$emit`出`change`事件，这个事件会直接修改父组件`value2`的值。

除了使用`v-model`，`vue2`还可以使用`.sync`修饰符来直接修改父元素数据。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&#123;&#123; syncValue &#125;&#125;</span><br><span class="line">&lt;Child4 :syncTest.sync=&quot;syncValue&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;updateSyncTestValue&quot;&gt;修改syncTest的值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    syncTest: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateSyncTestValue() &#123;</span><br><span class="line">      this.$emit(&quot;update:syncTest&quot;, &quot;new syncTest value&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

父组件传递给子组件的值如果带了`.sync`就可以在子组件通过`update:xxx`事件直接修改该值而不用再暴露事件在父组件去修改。

这样我们点击子组件按钮触发`updateSyncTestValue`方法，父组件的`syncTest`值会变成`new syncTest value`。

在`vue3`中`v-model`得到了加强，自定义组件也可以使用了`v-model`。而不用去指定`model`或者使用`.sync`参数了。

默认情况下，组件上的 `v-model` 使用 `modelValue` 作为 prop 和 `update:modelValue` 作为事件。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&#123;&#123;name1&#125;&#125;</span><br><span class="line">&lt;Child1 v-model=&quot;name1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child1&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;改变值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const changeName = () =&gt; &#123;</span><br><span class="line">      context.emit(&quot;update:modelValue&quot;, &quot;demi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      changeName,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

当我们点击子组件按钮触发`changeName`方法，会直接修改父组件的`name1`值。

### 自定义参数名

我们可以通过向 `v-model` 传递参数来修改这些名称：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&#123;&#123;name1&#125;&#125;</span><br><span class="line">&lt;Child1 v-model:name=&quot;name1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child1&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;改变值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const changeName = () =&gt; &#123;</span><br><span class="line">      context.emit(&quot;update:name&quot;, &quot;demi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      changeName,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

当我们点击子组件按钮触发`changeName1`、`changeName2`方法，会直接修改父组件的`name1`、`name2`值。

### 多个参数

我们还可以通过向 `v-model` 传递多个参数，这在`vue2`中是不可以的。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">name1: &#123;&#123; name1 &#125;&#125; name2: &#123;&#123; name2 &#125;&#125;</span><br><span class="line">&lt;Child2 v-model:name1=&quot;name1&quot; v-model:name2=&quot;name2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child2&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName1&quot;&gt;改变name1值&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName2&quot;&gt;改变name2值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name1: String,</span><br><span class="line">    name2: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const changeName1 = () =&gt; &#123;</span><br><span class="line">      context.emit(&quot;update:name1&quot;, &quot;demi1&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    const changeName2 = () =&gt; &#123;</span><br><span class="line">      context.emit(&quot;update:name2&quot;, &quot;demi2&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      changeName1,</span><br><span class="line">      changeName2,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### `v-model` 修饰符

`vue3`除了支持`.trim`、`.number` 和 `.lazy`修饰符。还支持添加自己的自定义修饰符。

下面笔者写个`.capitalize`修饰符，用来转换字母为大写。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&#123;&#123; name3 &#125;&#125;</span><br><span class="line">&lt;Child5 v-model.capitalize=&quot;name3&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child5&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; @input=&quot;changeName&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: String,</span><br><span class="line">    modelModifiers: &#123;</span><br><span class="line">      default: () =&gt; (&#123;&#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    console.log(props.modelModifiers); // &#123;capitalize: true&#125;</span><br><span class="line">    const changeName = (e) =&gt; &#123;</span><br><span class="line">      if (props.modelModifiers.capitalize) &#123;</span><br><span class="line">        context.emit(&quot;update:modelValue&quot;, e.target.value.toUpperCase());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        context.emit(&quot;update:modelValue&quot;, e.target.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      changeName,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

我们通过传递`.capitalize`，在子组件`props`中接收`modelModifiers`，这个属性里面存放传递的修饰符，比如我们传递了`.capitalize`它的值就是`{capitalize: true}`，所以我们可以根据这个属性还自定义操作。

对于带参数的 `v-model` 绑定，生成的 prop 名称将为 `arg + "Modifiers"`，这里笔者就不再细说了。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child5 v-model:name.capitalize=&quot;name3&quot; /&gt;</span><br></pre></td></tr></table></figure>

### key支持在template使用

在`vue2`中，`key`是不能定义在`template`节点上的。但是在`vue3`中支持了。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue 2.x --&gt;</span><br><span class="line">&lt;template v-for=&quot;item in list&quot;&gt;</span><br><span class="line">  &lt;div :key=&quot;&#x27;heading-&#x27; + item.id&quot;&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;span :key=&quot;&#x27;content-&#x27; + item.id&quot;&gt;...&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Vue 3.x --&gt;</span><br><span class="line">&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;div&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;span&gt;...&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

### 修改v-if和v-for优先级

在`vue2`中`v-for`的优先级是比v-if高的，在一个元素上同时使用 `v-if` 和 `v-for` 时，`v-for` 会优先作用。

下面我们根据数据`show`字段进行遍历展示，在`vue2`中是可行的。但是在`vue3`这样是不可行的。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;(list, index) of lists2&quot; :key=&quot;index&quot; v-if=&quot;list.show&quot;&gt;</span><br><span class="line">    &#123;&#123; list.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">lists2: [</span><br><span class="line">  &#123; name: &quot;randy&quot;, show: true &#125;,</span><br><span class="line">  &#123; name: &quot;demi&quot;, show: false &#125;,</span><br><span class="line">  &#123; name: &quot;jack&quot;, show: true &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

在`vue3`中需要这样写。因为在`vue3`中`v-if`的优先级比`v-for`更高，所以在`v-if`中访问不到`list`。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;(list, index) of lists2&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;div v-if=&quot;list.show&quot;&gt;&#123;&#123; list.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">lists2: [</span><br><span class="line">  &#123; name: &quot;randy&quot;, show: true &#125;,</span><br><span class="line">  &#123; name: &quot;demi&quot;, show: false &#125;,</span><br><span class="line">  &#123; name: &quot;jack&quot;, show: true &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

### `v-bind="object"` 现在排序敏感

在一个元素上动态绑定 attribute 时，同时使用 `v-bind="object"` 语法和独立 attribute 是常见的场景。然而，这就引出了关于合并的优先级的问题。

在 `vue2` 中，如果一个元素同时定义了 `v-bind="object"` 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 `object` 中的绑定。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 模板 --&gt;</span><br><span class="line">&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 结果 --&gt;</span><br><span class="line">&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

在 `vue3` 中，如果一个元素同时定义了 `v-bind="object"` 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并。后面的会覆盖前面的。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 模板 --&gt;</span><br><span class="line">&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 结果 --&gt;</span><br><span class="line">&lt;div id=&quot;blue&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 模板 --&gt;</span><br><span class="line">&lt;div v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot; id=&quot;red&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 结果 --&gt;</span><br><span class="line">&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

### 移除`v-on.native`修饰符

默认情况下，传递给带有 `v-on` 的组件的事件监听器只能通过 `this.$emit` 触发。如果要将原生 DOM 监听器添加到子组件的根元素中，可以使用 `.native` 修饰符：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click.native=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

这里的被`.native`修饰的`click`就是原生事件，当点击的时候才会触发。

在vue3中`v-on` 的 `.native` 修饰符已被移除。同时，新增的 `emits` 选项允许子组件定义真正会被触发的事件。

因此，对于子组件中*未*被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 `inheritAttrs: false`)。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

子组件

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在上面的例子中，因为子组件定义了`emits: ['close']`，也就是说组件说明了，我只会暴露出`close`事件，其他的事件你就当原生事件处理就可以了。所以`click`事件就是原生事件了。

### v-for 中的 ref

在 vue2 中，在 `v-for` 中使用的 `ref` attribute 会用 ref 数组填充相应的 `$refs` property。当存在嵌套的 `v-for` 时，这种行为会变得不明确且效率低下。

在 vue3 中，此类用法将不再自动创建 `$ref` 数组。要从单个绑定获取多个 ref，请将 `ref` 绑定到一个更灵活的函数上 (这是一个新特性)：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in list&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

选项式 API:

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      itemRefs: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setItemRef(el) &#123;</span><br><span class="line">      if (el) &#123;</span><br><span class="line">        this.itemRefs.push(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate() &#123;</span><br><span class="line">    this.itemRefs = []</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;</span><br><span class="line">    console.log(this.itemRefs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

组合式 API:

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; onBeforeUpdate, onUpdated &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let itemRefs = []</span><br><span class="line">    const setItemRef = el =&gt; &#123;</span><br><span class="line">      if (el) &#123;</span><br><span class="line">        itemRefs.push(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">      itemRefs = []</span><br><span class="line">    &#125;)</span><br><span class="line">    onUpdated(() =&gt; &#123;</span><br><span class="line">      console.log(itemRefs)</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

`itemRefs` 不必是数组：它也可以是一个对象，其 ref 可以通过迭代的 key 被设置。如有需要，`itemRefs` 也可以是响应式的，且可以被侦听。

## 组件改动

### 函数式组件

在`vue2`中我们使用`functional`定义函数式组件。有如下特点

- 作为性能优化，因为它们的初始化速度比有状态组件快得多
- 返回多个根节点

比如使用 `<dynamic-heading>` 组件，负责提供适当的标题 (即：`h1`、`h2`、`h3` 等等)，在 vue2 中，这可以通过单文件组件编写：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  props: [&#x27;level&#x27;],</span><br><span class="line">  render(h, &#123; props, data, children &#125;) &#123;</span><br><span class="line">    return h(`h$&#123;props.level&#125;`, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

或者，对于喜欢在单文件组件中使用 `<template>` 的用户：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;component</span><br><span class="line">    :is=&quot;`h$&#123;props.level&#125;`&quot;</span><br><span class="line">    v-bind=&quot;attrs&quot;</span><br><span class="line">    v-on=&quot;listeners&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;level&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

但是在 `vue3` 中，所有的函数式组件都是用普通函数创建的。换句话说，不需要定义 `{ functional: true }` 组件选项。也就是说 `functional` 已经被移除了。

它们将接收两个参数：`props` 和 `context`。`context` 参数是一个对象，包含组件的 `attrs`、`slots` 和 `emit` property。

此外，`h` 现在是全局导入的，而不是在 `render` 函数中隐式提供。

以前面提到的 `<dynamic-heading>` 组件为例，下面是它现在的样子。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const DynamicHeading = (props, context) =&gt; &#123;</span><br><span class="line">  return h(`h$&#123;props.level&#125;`, context.attrs, context.slots)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DynamicHeading.props = [&#x27;level&#x27;]</span><br><span class="line"></span><br><span class="line">export default DynamicHeading</span><br></pre></td></tr></table></figure>

### 异步组件

在`vue2`中异步组件是通过将组件定义为返回 `Promise` 的函数来创建的，例如：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const asyncModal = () =&gt; import(&#x27;./Modal.vue&#x27;)</span><br></pre></td></tr></table></figure>

在`vue3`中异步组件通过`defineAsyncComponent`定义

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 不带选项的异步组件</span><br><span class="line">const asyncModal = defineAsyncComponent(() =&gt; import(&#x27;./Modal.vue&#x27;))</span><br></pre></td></tr></table></figure>

### emits

组件里面新增了`emits`选项，可以通过 `emits` 选项在组件上定义发出的事件。

下面看例子

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child4 @submit=&quot;handleSubmit&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child4&quot;&gt;</span><br><span class="line">    &lt;h3&gt;child4&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;handleClick&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, ref, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  // 与props类似，支持数组和对象</span><br><span class="line">  // emits: [&quot;submit&quot;],</span><br><span class="line">   emits: &#123;</span><br><span class="line">     submit: null</span><br><span class="line">   &#125;,</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      emit(&quot;submit&quot;, &#123; name: &quot;randy&quot; &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在这个例子中，子组件对外暴露了`submit`事件，所以需要在`emits`里面定义。

### 原生事件替代

当在 `emits` 选项中定义了原生事件 (如 `click`) 时，将使用组件中的事件**替代**原生事件侦听器。

下面笔者再出一个例子就会明白了。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child4 @click=&quot;handleClick&quot; /&gt;</span><br><span class="line">const handleClick = (data) =&gt; &#123;</span><br><span class="line">  console.log(data.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child4&quot;&gt;</span><br><span class="line">    &lt;h3&gt;child4&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, ref, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  emits: [&quot;click&quot;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const handleInput = (e) =&gt; &#123;</span><br><span class="line">      emit(&quot;click&quot;, &#123; value: e.target.value &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      handleInput,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

上面的例子我们在`input`输入框输入内容的时候控制台会打印值。虽然我们在子组件上监听了`click`方法，但是并不会起作用，他被`input`事件替代了。

虽然vue支持这种写法但是笔者不太建议用原生方法命名，容易混淆。

> 暴露的事件一定要定义emits中，因为没被定义在emits中的事件会被当做原生事件处理。当你命名和原生事件一样的时候就会发现有问题了。

比如上面的例子，当你定义的方法名和原生事件名一样比如`click`，又没在`emits`里面定义，这样会导致你自定义的事件会触发你的方法而且当你点击的时候还会触发你的方法，会触发两次。

### 事件验证

与 `prop` 类型验证类似，如果使用对象语法而不是数组语法定义发出的事件，则可以对它进行验证。

要添加验证，请为事件分配一个函数，该函数接收传递给 `$emit` 调用的参数，并返回一个布尔值以指示事件是否有效。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child4 @submit=&quot;handleSubmit&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child4&quot;&gt;</span><br><span class="line">    &lt;h3&gt;child4&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;handleClick&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, ref, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  emits: &#123;</span><br><span class="line">    submit: (&#123; name, age &#125;) =&gt; &#123;</span><br><span class="line">      if (name &amp;&amp; age) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      emit(&quot;submit&quot;, &#123; name: &quot;randy&quot; &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

验证不通过并不会报错，而是出现控制台警告。

### 自定义元素

在`vue2`中`template`里面只能识别`html`标签或者组件，如果是其它不认识的标签会报错。如果要自定义元素怎么办呢？比如自定义一个`<basic-button>`

在`vue2`中需要通过 `Vue.config.ignoredElements` 将标签配置为自定义元素

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.ignoredElements = [&#x27;basic-button&#x27;]</span><br></pre></td></tr></table></figure>

在`vue3`中需要通过 `app.config.compilerOptions.isCustomElement` 传递。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.config.compilerOptions.isCustomElement = tag =&gt; tag === &#x27;basic-button&#x27;</span><br></pre></td></tr></table></figure>

这样我们在`vue`模板里面就能正常使用该标签了。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;basic-button&gt;&lt;/basic-button&gt;</span><br></pre></td></tr></table></figure>

### is

在`vue2`中，`is`可以用在普通元素和`<component>`上。不管用在哪个上面都会渲染`is`指定的组件。

下面渲染的都是`Child3`组件

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;component is=&quot;Child3&quot;&gt; &lt;/component&gt;</span><br><span class="line">&lt;component :is=&quot;Com&quot;&gt; &lt;/component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- is始终渲染组件 --&gt;</span><br><span class="line">&lt;section is=&quot;Child3&quot;&gt;&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">import Child3 from &quot;@/components/Child3&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; Child3 &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      Com: Child3,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在vue3中，`is`也可以用在普通元素和`<component>`上。但是只有用在`<component>`上才会渲染指定组件，用在普通元素上只会作为一个属性传递。如果想在普通元素上渲染组件怎么办呢？这就需要加上`vue:`前缀了。

下面渲染的都是`Child3`组件

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;&#x27;Child3&#x27;&quot;&gt; &lt;/component&gt;</span><br><span class="line">&lt;component :is=&quot;Com&quot;&gt; &lt;/component&gt;</span><br><span class="line"></span><br><span class="line">&lt;section is=&quot;vue:Child3&quot;&gt;&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">import Child3 from &quot;@/components/Child3&quot;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  components: &#123; Child3 &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">     Com: Child3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

## 渲染函数改动

### 渲染函数API改变

在`vue3`中渲染函数`h`现在全局导入，而不是作为参数传递给渲染函数。并且在setup中需要返回函数，而不是渲染函数`h`。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//vue2.x</span><br><span class="line">export default&#123;</span><br><span class="line">  render(h)&#123;</span><br><span class="line">    return h(&#x27;div&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//vue3</span><br><span class="line">import &#123; h &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    return () =&gt; h(&#x27;div&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### slot变更

在 vue2 中， 具名插槽的写法：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  子组件中：--&gt;</span><br><span class="line">&lt;slot name=&quot;title&quot;&gt;</span><br><span class="line">  &lt;div&gt;randy&lt;/div&gt;</span><br><span class="line">&lt;/slot&gt;</span><br></pre></td></tr></table></figure>

在父组件中使用：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template slot=&quot;title&quot;&gt;</span><br><span class="line">  &lt;div&gt;后备内容&lt;/div&gt;</span><br><span class="line">&lt;template&gt;</span><br></pre></td></tr></table></figure>

如果我们要**在 slot 上面绑定数据，可以使用作用域插槽**，实现如下：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;slot name=&quot;content&quot; :user=&quot;user1&quot;&gt;&lt;/slot&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      user1:&#123;name: &#x27;randy&#x27;, age: 27&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件中使用 --&gt;</span><br><span class="line">&lt;template slot=&quot;content&quot; slot-scope=&quot;scoped&quot;&gt;</span><br><span class="line">  &lt;div&gt;name: &#123;&#123;scoped.user.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;age: &#123;&#123;scoped.user.age&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;template&gt;</span><br></pre></td></tr></table></figure>

在 vue2 中具名插槽和作用域插槽分别使用`slot`和`slot-scope`来实现， 在 vue3 中将`slot`和`slot-scope`进行了合并同意使用，使用`v-slot`代替。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件中使用 --&gt;</span><br><span class="line"> &lt;template v-slot:content=&quot;scoped&quot;&gt;</span><br><span class="line">  &lt;div&gt;name: &#123;&#123;scoped.user.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;age: &#123;&#123;scoped.user.age&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 也可以简写成： --&gt;</span><br><span class="line">&lt;template #content=&quot;&#123;user&#125;&quot;&gt;</span><br><span class="line">  &lt;div&gt;name: &#123;&#123;user.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;age: &#123;&#123;user.age&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

## 样式改动

`Vue3`新增了样式穿透方法，支持了全局样式和slot样式定义，还支持了模块化样式和样式变量。

### 样式穿透

在`vue2`中我们使用`/deep/`来做样式穿透，在vue3中推荐使用`:deep()`

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// vue2</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.a /deep/ .b &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// vue3</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.a :deep(.b) &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面是简写形式</span><br><span class="line">.a ::v-deep(.b) &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

### 全局样式和局部样式

我们知道使用scoped修饰的style样式只会在当前文件生效。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">/* local styles */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

但是我们想创建全局样式应该怎么做呢？

在`vue3`中有两种方法

创建一个不带 `scoped` 的`style`的标签。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">/* global styles */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

还可以使用 `:global` 伪类来实现

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个.red的全局类样式</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">:global(.red) &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面是简写形式</span><br><span class="line">::v-global(.red) &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

### module

<style module> 标签会被编译为 CSS Modules 并且将生成的 CSS 类作为 $style 对象的键暴露给组件：

<style module> 实现了和 scope CSS 一样将 CSS 仅作用于当前组件的效果。所以我们不需要再加scoped属性了。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;$style.red&quot;&gt;</span><br><span class="line">    This should be red</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.red &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

我们还可以通过给 `module` attribute 一个值来自定义注入的类对象的 property 键：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p :class=&quot;classes.red&quot;&gt;red&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module=&quot;classes&quot;&gt;</span><br><span class="line">.red &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

注意使用模块化的话我们的样式不要嵌套哦，不然会获取不到。

### 与组合式 API 一同使用

注入的类可以通过 `useCssModule` API 在 `setup()` 和 `<script setup>` 中使用。对于使用了自定义注入名称的 `<style module>` 模块，`useCssModule` 接收一个对应的 `module` attribute 值作为第一个参数。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useCssModule &#125; from &quot;vue&quot;;</span><br><span class="line">// 默认, 返回 &lt;style module&gt; 中的类，是一个对象</span><br><span class="line">console.log(useCssModule())</span><br><span class="line"></span><br><span class="line">// 命名, 返回 &lt;style module=&quot;classes&quot;&gt; 中的类，是一个对象</span><br><span class="line">console.log(useCssModule(&#x27;classes&#x27;))</span><br></pre></td></tr></table></figure>

### 状态驱动的动态 CSS

单文件组件的 `<style>` 标签可以通过 `v-bind` 这一 CSS 函数将 CSS 的值关联到动态的组件状态上：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;title3&quot;&gt;title3&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;title4&quot;&gt;title4&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, ref, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const color1 = ref(&quot;green&quot;);</span><br><span class="line">    const color2 = reactive(&#123; color: &quot;blue&quot; &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      color1,</span><br><span class="line">      color2,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.title3 &#123;</span><br><span class="line">  color: v-bind(color1);</span><br><span class="line">&#125;</span><br><span class="line">.title4 &#123;</span><br><span class="line">  color: v-bind(&quot;color2.color&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

这里的样式是响应式的，`js`中值改变样式也会更新。

### 插槽选择器

默认情况下，作用域样式不会影响到 `<slot/>` 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 `:slotted` 伪类以确切地将插槽内容作为选择器的目标：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child3&gt;</span><br><span class="line">  &lt;div class=&quot;slot1&quot;&gt;我是slot传递过来的&lt;/div&gt;</span><br><span class="line">&lt;/Child3&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">:slotted(.slot1) &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面是简写</span><br><span class="line">::v-slotted(.slot1) &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

其实我们把样式写在父元素也是可以实现该功能的。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child3&gt;</span><br><span class="line">  &lt;div class=&quot;slot1&quot;&gt;我是slot传递过来的&lt;/div&gt;</span><br><span class="line">&lt;/Child3&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.slot1 &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

## 其他改动

### Provide / Inject

使用过`vue2`的同学肯定知道`Provide / Inject`使用来组件间传递值的。我们来看看`vue2`和`vue3`中使用差别。

在`vue2`中，我们能直接使用。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: &quot;父组件数据&quot;,</span><br><span class="line">    say() &#123;</span><br><span class="line">      console.log(&quot;say say say&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当需要用到this的时候需要使用函数形式</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todoLength: this.todos.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;provide inject传递过来的数据： &#123;&#123; name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;provide inject传递过来的方法&lt;button @click=&quot;say&quot;&gt;say&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&#x27;name&#x27;, &#x27;say&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在`vue3`中，我们需要引入`provide`和`inject`，并且在`setup`方法中返回才能使用。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, provide &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 定义数据或方法</span><br><span class="line">    provide(&quot;fName&quot;, &quot;父组件数据&quot;);</span><br><span class="line">    provide(&quot;say&quot;, () =&gt; &#123;</span><br><span class="line">      console.log(&quot;say say say&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;provide inject传递过来的数据：&#123;&#123; fName &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;provide inject 支持默认值：&#123;&#123; fAge &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;provide inject传递过来的方法&lt;button @click=&quot;say&quot;&gt;say&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, inject &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 引入使用，并支持默认值</span><br><span class="line">    const fName = inject(&quot;fName&quot;);</span><br><span class="line">    // 第二个参数用来设置默认值</span><br><span class="line">    const fAge = inject(&quot;fAge&quot;, 27);</span><br><span class="line">    const say = inject(&quot;say&quot;, () =&gt; &#123;</span><br><span class="line">      console.log(&quot;say say say&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">      fName,</span><br><span class="line">      fAge,</span><br><span class="line">      say</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

为了增加 `provide` 值和 `inject` 值之间的响应性，我们可以在 `provide` 值时使用 `ref` 或 `reactive`。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provide, reactive, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const title = ref(&#x27;title&#x27;)</span><br><span class="line">    const user = reactive(&#123;</span><br><span class="line">      name: &#x27;randy&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    provide(&#x27;title&#x27;, title)</span><br><span class="line">    provide(&#x27;user&#x27;, user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

现在，如果这两个 `property` 中有任何更改，`Child` 组件也将自动更新！

当使用响应式 `provide / inject` 值时，**建议尽可能将对响应式 property 的所有修改限制在定义 provide 的组件内部**。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provide, reactive, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const title = ref(&#x27;title&#x27;)</span><br><span class="line">    const user = reactive(&#123;</span><br><span class="line">      name: &#x27;randy&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    provide(&#x27;title&#x27;, title)</span><br><span class="line">    provide(&#x27;user&#x27;, user)</span><br><span class="line">    </span><br><span class="line">    const updateTitle = () =&gt; &#123;</span><br><span class="line">      title.value = &#x27;new title&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

然而，有时我们需要在注入数据的组件内部更新 `inject` 的数据。在这种情况下，我们建议 `provide` 一个方法来负责改变响应式 `property`。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provide, reactive, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const title = ref(&#x27;title&#x27;)</span><br><span class="line">    const user = reactive(&#123;</span><br><span class="line">      name: &#x27;randy&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const updateTitle = () =&gt; &#123;</span><br><span class="line">      title.value = &#x27;new title&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    provide(&#x27;title&#x27;, title)</span><br><span class="line">    provide(&#x27;user&#x27;, user)</span><br><span class="line">    provide(&#x27;updateTitle&#x27;, updateTitle)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

最后，如果要确保通过 `provide` 传递的数据不会被 `inject` 的组件更改，我们建议对提供者的 `property` 使用 `readonly`，这样就万无一失啦。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provide, reactive, ref, readonly &#125; from &#x27;vue&#x27;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const title = ref(&#x27;title&#x27;)</span><br><span class="line">    const user = reactive(&#123;</span><br><span class="line">      name: &#x27;randy&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const updateTitle = () =&gt; &#123;</span><br><span class="line">      title.value = &#x27;new title&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    provide(&#x27;title&#x27;, readonly(title))</span><br><span class="line">    provide(&#x27;user&#x27;, readonly(user))</span><br><span class="line">    provide(&#x27;updateTitle&#x27;, updateTitle)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### 模板引用

模板引用在`vue2`中是非常简单的，通过`this.$refs`就能获取到。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Child1 ref=&quot;childRef&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child1 from &quot;@/components/Child1&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child1,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 获取子组件</span><br><span class="line">    console.log(this.$refs.childRef)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在`vue3`中相对麻烦，需要先引入`ref`，并在`setup`方法中返回。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      // 创建</span><br><span class="line">      const root = ref(null)</span><br><span class="line"></span><br><span class="line">      onMounted(() =&gt; &#123;</span><br><span class="line">        // 获取子组件</span><br><span class="line">        console.log(root.value) // &lt;div&gt;This is a root element&lt;/div&gt;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在`JSX`中

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const root = ref(null)</span><br><span class="line"></span><br><span class="line">    // 渲染函数方式</span><br><span class="line">    return () =&gt;</span><br><span class="line">      h(&#x27;div&#x27;, &#123;</span><br><span class="line">        ref: root</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    // JSX方式</span><br><span class="line">    return () =&gt; &lt;div ref=&#123;root&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在`v-for`中

我们知道，`vue2`中，如果是`for`循环的话`this.$refs`会是一个数组。但是在`vue3` 中 `v-for`内部使用时没有特殊处理。相反，使用函数引用执行自定义处理。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-for=&quot;(item, i) in list&quot; :ref=&quot;el =&gt; &#123; if (el) divs[i] = el &#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, reactive, onBeforeUpdate &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const list = reactive([1, 2, 3])</span><br><span class="line">      const divs = ref([])</span><br><span class="line"></span><br><span class="line">      // 确保在每次更新之前重置ref</span><br><span class="line">      onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">        divs.value = []</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        list,</span><br><span class="line">        divs</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在侦听模板中

我们也可以不在生命周期钩子使用而是在监听器中使用，但与生命周期钩子的一个关键区别是，`watch()` 和 `watchEffect()` 在 `DOM` 挂载或更新**之前**运行副作用，所以当侦听器运行时，模板引用还未被更新。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const root = ref(null)</span><br><span class="line"></span><br><span class="line">      watchEffect(() =&gt; &#123;</span><br><span class="line">        // 这个副作用在 DOM 更新之前运行，因此，模板引用还没有持有对元素的引用。</span><br><span class="line">        console.log(root.value) // =&gt; null</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

因此，使用模板引用的侦听器应该用 `flush: 'post'` 选项来定义，这将在 `DOM` 更新**后**运行副作用，确保模板引用与 `DOM` 保持同步，并引用正确的元素。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const root = ref(null)</span><br><span class="line"></span><br><span class="line">      watchEffect(() =&gt; &#123;</span><br><span class="line">        console.log(root.value) // =&gt; &lt;div&gt;This is a root element&lt;/div&gt;</span><br><span class="line">      &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        flush: &#x27;post&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### 自定义指令

指令的钩子函数已经被重命名，以更好地与组件的生命周期保持一致。并且，`expression` 字符串不再作为 `binding` 对象的一部分被传入。

在 vue2 中，自定义指令通过使用下列钩子来创建，以对齐元素的生命周期，它们都是可选的：

- **bind** - 指令绑定到元素后调用。只调用一次。
- **inserted** - 元素插入父 DOM 后调用。
- **update** - 当元素更新，但子元素尚未更新时，将调用此钩子。
- **componentUpdated** - 一旦组件和子级被更新，就会调用这个钩子。
- **unbind** - 一旦指令被移除，就会调用这个钩子。也只调用一次。

下面是一个例子：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-highlight=&quot;&#x27;yellow&#x27;&quot;&gt;以亮黄色高亮显示此文本&lt;/p&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&#x27;highlight&#x27;, &#123;</span><br><span class="line">  bind(el, binding, vnode) &#123;</span><br><span class="line">    el.style.background = binding.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

此处，在这个元素的初始设置中，通过给指令传递一个值来绑定样式，该值可以在应用中任意更改。

然而，在 `vue3` 中，我们为自定义指令创建了一个更具凝聚力的 API。正如你所看到的，它们与我们的组件生命周期方法有很大的不同，即使钩子的目标事件十分相似。我们现在把它们统一起来了：

- **created** - 新增！在元素的 attribute 或事件监听器被应用之前调用。
- bind → **beforeMount**
- inserted → **mounted**
- **beforeUpdate**：新增！在元素本身被更新之前调用，与组件的生命周期钩子十分相似。
- update → 移除！该钩子与 `updated` 有太多相似之处，因此它是多余的。请改用 `updated`。
- componentUpdated → **updated**
- **beforeUnmount**：新增！与组件的生命周期钩子类似，它将在元素被卸载之前调用。
- unbind -> **unmounted**

最终的 API 如下：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const MyDirective = &#123;</span><br><span class="line">  created(el, binding, vnode, prevVnode) &#123;&#125;, // 新增</span><br><span class="line">  beforeMount() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  beforeUpdate() &#123;&#125;, // 新增</span><br><span class="line">  updated() &#123;&#125;,</span><br><span class="line">  beforeUnmount() &#123;&#125;, // 新增</span><br><span class="line">  unmounted() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

因此，API 可以这样使用，与前面的示例相同：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-highlight=&quot;&#x27;yellow&#x27;&quot;&gt;以亮黄色高亮显示此文本&lt;/p&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.directive(&#x27;highlight&#x27;, &#123;</span><br><span class="line">  beforeMount(el, binding, vnode) &#123;</span><br><span class="line">    el.style.background = binding.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

### data

在vue2中，我们可以通过 `object` 或者是 `function` 定义 `data` 选项。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Object 声明 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      apiKey: &#x27;a1b2c3&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Function 声明 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        apiKey: &#x27;a1b2c3&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

vue3 中，`data` 选项已标准化为只接受返回 `object` 的 `function`。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  createApp(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        apiKey: &#x27;a1b2c3&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).mount(&#x27;#app&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### mixin 合并行为改为浅合并

我们先来复习下`mixin`。`mixin`对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

1. `mixin`和组件的`data`数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。
2. 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用。
3. 值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

这次`mixin`的调整主要是在`data()`。

当来自组件的 `data()` 及其 `mixin` 或 `extends` 基类被合并时，合并操作现在将被*浅层次*地执行：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Mixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        name: &#x27;Jack&#x27;,</span><br><span class="line">        id: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const CompA = &#123;</span><br><span class="line">  mixins: [Mixin],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        id: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在 `vue2` 中，生成的 `$data` 是：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 2,</span><br><span class="line">    &quot;name&quot;: &quot;Jack&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在 `vue3` 中，其结果将会是：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 保持原样</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

因为组件已经有了`user`属性，所以不会再替换了。

### 侦听数组

在`vue3`中当使用 `watch` 选项侦听数组时，只有在数组被替换时才会触发回调。换句话说，在数组被改变时侦听回调将不再被触发。要想在数组被改变时触发侦听回调，必须指定 `deep` 选项。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  bookList: &#123;</span><br><span class="line">    handler(val, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;book list changed&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### transition

过渡类名 `v-enter` 修改为 `v-enter-from`、过渡类名 `v-leave` 修改为 `v-leave-from`。

下面笔者用两张图总结

在`vue2`中

![img](https://pic4.zhimg.com/80/v2-c71bbd336ccdf2b26fb7928d1778a6cb_720w.webp)

在`vue3`中

![img](https://pic4.zhimg.com/80/v2-9d08911ee7e574673366698132006513_720w.webp)

`<transition>` 组件的相关 prop 名称也发生了变化：

`leave-class` 已经被重命名为 `leave-from-class` (在渲染函数或 JSX 中可以写为：`leaveFromClass`) `enter-class` 已经被重命名为 `enter-from-class` (在渲染函数或 JSX 中可以写为：`enterFromClass`)

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vu2</span><br><span class="line">&lt;transition</span><br><span class="line">  leave-class=&quot;animated tada&quot; </span><br><span class="line">  enter-class=&quot;animated bounceOutRight&quot; &gt; </span><br><span class="line">  &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; </span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"></span><br><span class="line">vue3</span><br><span class="line">&lt;transition</span><br><span class="line">  leave-from-class=&quot;animated tada&quot; </span><br><span class="line">  enter-from-class=&quot;animated bounceOutRight&quot; &gt; </span><br><span class="line">  &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; </span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

### transition-group 不再默认渲染根元素

在 `vue2` 中，`<transition-group>` 像其它自定义组件一样，需要一个根元素。默认的根元素是一个 `<span>`，但可以通过 `tag` attribute 定制。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition-group tag=&quot;ul&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure>

在 `vue3` 中`<transition-group>` 不再默认渲染根元素，但仍然可以用 `tag` attribute 创建根元素。

### template标签在非特殊情况下不渲染内容

没有特殊指令的标记 (`v-if/else-if/else`、`v-for` 或 `v-slot`) 的 `<template>` 现在被视为普通元素，并将渲染为原生的 `<template>` 元素，而不是渲染其内部内容。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue2</span><br><span class="line">&lt;template&gt;randy&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">vue3</span><br><span class="line">&lt;template&gt;randy&lt;/template&gt;</span><br></pre></td></tr></table></figure>

上面的例子在`vue2`中会渲染出`randy`，在`vue3`中会渲染`<template></template>`并没有内容。

### 被挂载的应用不会替换元素

当我们的`index.html`是这样的

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    Some app content</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

根组件是这样的

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello Vue!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div id=&quot;rendered&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

`vue2`会渲染成

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;rendered&quot;&gt;Hello Vue!&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

`vue3`会渲染成

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot; data-v-app=&quot;&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;rendered&quot;&gt;Hello Vue!&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

看出差别了吧，就是`vue3`不会替换被挂载的元素。

## 移除API

在`vue3`中移除了部分`api`。

### filter

在`vue2`中我们这样使用`filter`。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; accountBalance | currencyUSD &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      accountBalance: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        required: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">      currencyUSD(value) &#123;</span><br><span class="line">        return &#x27;$&#x27; + value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在`vue3`中移除过滤器，不在支持。建议使用`computed`去替代。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; accountInUSD &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      accountBalance: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        required: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      accountInUSD() &#123;</span><br><span class="line">        return &#x27;$&#x27; + this.accountBalance</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

### config.keyCodes

在 `vue2` 中，`keyCodes` 可以作为修改 `v-on` 方法的一种方式。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 键码版本 --&gt;</span><br><span class="line">&lt;input v-on:keyup.13=&quot;submit&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 别名版本 --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=&quot;submit&quot; /&gt;</span><br></pre></td></tr></table></figure>

此外，也可以通过全局的 `config.keyCodes` 选项定义自己的别名。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes = &#123;</span><br><span class="line">  f1: 112</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 键码版本 --&gt;</span><br><span class="line">&lt;input v-on:keyup.112=&quot;showHelpText&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 自定义别名版本 --&gt;</span><br><span class="line">&lt;input v-on:keyup.f1=&quot;showHelpText&quot; /&gt;</span><br></pre></td></tr></table></figure>

`vue3`对任何要用作修饰符的键使用 `kebab-cased` (短横线) 名称。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue 3 在 v-on 上使用按键修饰符 --&gt;</span><br><span class="line">&lt;input v-on:keyup.page-down=&quot;nextPage&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 同时匹配 q 和 Q --&gt;</span><br><span class="line">&lt;input v-on:keypress.q=&quot;quit&quot;&gt;</span><br></pre></td></tr></table></figure>

因此，这意味着 `config.keyCodes` 现在也已弃用，不再受支持。

### `$on`，`$off` 和 `$once`

`$on`，`$off` 和 `$once` 实例方法已被移除，组件实例不再实现事件触发接口。

在 `vue2` 中，Vue 实例可用于触发由事件触发器 API 通过指令式方式添加的处理函数 (`$on`，`$off` 和 `$once`)。这可以用于创建一个*事件总线*，以创建在整个应用中可用的全局事件监听器：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// eventBus.js</span><br><span class="line"></span><br><span class="line">const eventBus = new Vue()</span><br><span class="line"></span><br><span class="line">export default eventBus</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ChildComponent.vue</span><br><span class="line">import eventBus from &#x27;./eventBus&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 添加 eventBus 监听器</span><br><span class="line">    eventBus.$on(&#x27;custom-event&#x27;, () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;Custom event triggered!&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    // 移除 eventBus 监听器</span><br><span class="line">    eventBus.$off(&#x27;custom-event&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ParentComponent.vue</span><br><span class="line">import eventBus from &#x27;./eventBus&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    callGlobalCustomEvent() &#123;</span><br><span class="line">      eventBus.$emit(&#x27;custom-event&#x27;) // 当 ChildComponent 已被挂载时，控制台中将显示一条消息</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在`vue3`中已经从实例中完全移除了 `$on`、`$off` 和 `$once` 方法。`$emit` 仍然包含于现有的 API 中，因为它用于触发由父组件声明式添加的事件处理函数。

### $children

`$children` 实例 `property` 已从 `vue3`中移除，不再支持。

在 `vue2` 中，开发者可以使用 `this.$children` 访问当前实例的直接子组件：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;my-button&gt;Change logo&lt;/my-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyButton from &#x27;./MyButton&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyButton</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.$children) // [VueComponent]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

在 `vue3` 中，`$children` property 已被移除，且不再支持。如果你需要访问子组件实例，我们建议使用 `ref`。

### propsData

`propsData` 选项之前用于在创建 Vue 实例的过程中传入 `prop`，现在它被移除了。如果想为 `vue3` 应用的根组件传入 `prop`，请使用 `createApp` 的第二个参数。

在 `vue2` 中，我们可以在创建 Vue 实例的时候传入 prop：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Comp = Vue.extend(&#123;</span><br><span class="line">  props: [&#x27;username&#x27;],</span><br><span class="line">  template: &#x27;&lt;div&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Comp(&#123;</span><br><span class="line">  propsData: &#123;</span><br><span class="line">    username: &#x27;randy&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

在 `vue3` 中 `propsData` 选项已经被移除。如果你需要在实例创建时向根组件传入 prop，你应该使用 `createApp` 的第二个参数：

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const app = createApp(</span><br><span class="line">  &#123;</span><br><span class="line">    props: [&#x27;username&#x27;],</span><br><span class="line">    template: &#x27;&lt;div&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; username: &#x27;Evan&#x27; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

### `$destroy`

在`vue3`中移除了`$destroy`，用户不应再手动管理单个 Vue 组件的生命周期。

### `set delete $set $delete`

在`vue3`中移除了全局函数 `Vue.set` 和 `Vue.delete` 以及实例方法 `this.$set` 和 `this.$delete`。因为在`vue3`中响应式检测是基于`proxy`的，基于代理的变化检测已经不再需要它们了。

### `inline-template`

在 vue2 中，Vue 为子组件提供了 `inline-template` attribute，以便将其内部内容作为模板使用，而不是作为分发内容。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component inline-template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;它们将被编译为组件自己的模板，&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;而不是父级所包含的内容。&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

上面会在页面渲染

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;它们将被编译为组件自己的模板，&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;而不是父级所包含的内容。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

我们看看不加`inline-template` attribute

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;它们将被编译为组件自己的模板，&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;而不是父级所包含的内容。&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

上面会在页面渲染`<my-component>`的真实内容，如果`<my-component>`没内容将渲染为空。

在 `vue3` 中将不再支持此功能。

## router的使用

`vue2.x`使用的是`vue-router@3.x`，`vue3.x`使用的是[vue-router@4.x](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%253A%252F%252Frouter.vuejs.org%252F)。

### 创建

不再使用`new Router()`创建实例，而是使用`createRouter`方法。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// vue2.x router</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">  scrollBehavior: () =&gt; (&#123; y: 0 &#125;),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router</span><br><span class="line"></span><br><span class="line">// vue3.x router</span><br><span class="line">import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;</span><br><span class="line">import Home from &#x27;../views/Home.vue&#x27;</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(process.env.BASE_URL),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

### 路由跳转

由于`vue3`的`setup`方法没有`this`，所以不能再使用`this.$router`获取路由对象啦。在`vue3`中需要使用`useRouter`方法。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// vue2</span><br><span class="line">this.$router.push()</span><br><span class="line">this.$router.replace()</span><br><span class="line"></span><br><span class="line">// vue3</span><br><span class="line">import &#123;useRouter&#125; fom vue-router</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const router = useRouter()</span><br><span class="line">    router.push()</span><br><span class="line">    router.replace()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

请注意，在模板中我们仍然可以访问 `$router` 和 `$route`，所以不需要在 `setup` 中返回 `router` 或 `route`。

### 路由参数

由于`vue3`的`setup`方法没有`this`，所以不能再使用`this.$route`获取当前路由对象啦。在`vue3`中需要使用`useRoute`方法。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// vue2</span><br><span class="line">const &#123;id&#125; = this.$route.query</span><br><span class="line">const &#123;id&#125; = this.$route.params</span><br><span class="line"></span><br><span class="line">// vue3</span><br><span class="line">import &#123;useRoute&#125; fom vue-router</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const route = useRoute()</span><br><span class="line">    const &#123;id&#125; = route.query</span><br><span class="line">    const &#123;id&#125; = route.params</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

请注意，在模板中我们仍然可以访问 `$router` 和 `$route`，所以不需要在 `setup` 中返回 `router` 或 `route`。

### 路由钩子

在`vue3`中有改动的路由钩子是组件内钩子。在`vue2`中有`beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`三个钩子。但是在`vue3`中移除了`beforeRouteEnter`。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    onBeforeRouteLeave((to, from) =&gt; &#123;&#125;)</span><br><span class="line">    onBeforeRouteUpdate((to, from) =&gt; &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## store的使用

`vue2.x`使用的是`vuex@3.x`，`vue3.x`使用的是[vuex@4.x](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%253A%252F%252Fvuex.vuejs.org%252Fzh%252F)。

### 创建

不再使用`new Vuex.Store()`创建实例，而是使用`createStore`方法。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// vue2.x vuex</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  modules: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// vue3.x vuex</span><br><span class="line">import &#123; createStore &#125; from &quot;vuex&quot;;</span><br><span class="line"></span><br><span class="line">export default createStore(&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  modules: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

### 获取store

除了获取`store`的方式有所改变，其它方法都没变。

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// vue2</span><br><span class="line">this.$store</span><br><span class="line"></span><br><span class="line">// vue3.x vuex</span><br><span class="line">import &#123; useStore &#125; from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    const store = userStore()</span><br><span class="line">    // store.state</span><br><span class="line">    // store.getters</span><br><span class="line">    // store.commit()</span><br><span class="line">    // store.dispatch()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 参考文档

[官方文档](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%253A%252F%252Fv3.cn.vuejs.org%252Fguide%252Fmigration%252Fintroduction.html)

## 后记

感谢小伙伴们的耐心观看，本文为笔者个人学习笔记，如有谬误，还请告知，万分感谢！如果本文对你有所帮助，还请点个关注点个赞~，您的支持是笔者不断更新的动力！
        </div>
        <br />

        <!-- 分享 -->
        <div id="social-share" class="article-social-share"></div>

        <!-- 评论系统 -->
        
            <section id="comments" class="comments">
              <!-- 可以添加样式
              <style>
                .comments{margin:30px;padding:10px;background:#fff}
                @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
              </style> -->
              <!-- 评论系统。在post.ejs中引入 -->
<div class="valine_comment"></div>
<script type="module">
  import { init } from '/js/waline.mjs';
  // import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js'; // 在线url
  init({
    el: '.valine_comment',
    serverURL: 'https://blog.comment.helloallen.cn',
    // serverURL: 'https://allen-blog-vercel.vercel.app', // 未绑定域名的评论url，只能外网访问
  });
</script>
            </section>
        

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Vue/"># Vue</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <!-- 另一种的上一篇下一篇 -->
        <!-- <section class="post-nav">
            
                <a class="prev" rel="prev" href="/184b4b1f/">相对论前夜：牛顿和麦克斯韦的战争</a>
            
            
            <a class="next" rel="next" href="/b3106040/">《文明的冲突与世界秩序的重建》（亨廷顿）</a>
            
        </section> -->
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/184b4b1f/"> &laquo; Prev </a>
            
            
                <a class="next" rel="next" href="/b3106040/"> Next &raquo; </a>
            
        </section>


    </article>
</div>

            </div>
            <!-- 分享 -->
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" defer></script>
<link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">

<footer id="footer" class="footer">
    <div>
        <span>
            Allen © 
                2015 - 
                2024  
        </span> |   <!-- 站点访问量统计。在footer.ejs中引入 -->
<script async src="/js/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    <i class="iconfont icon-peoplecopy3"></i>
    <span id="busuanzi_value_site_uv"></span>
</span>&nbsp;


<span class="site-pv">
    <i class="iconfont icon-view"></i>
    <span id="busuanzi_value_site_pv"></span>
</span>

 
    </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & Theme by <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        </span>
    </div>

    <!-- 上个版本的统计当前站点运行时间 -->
    <!-- <div class="copyright">
        <span>© Allen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
        | <span id="timeDate">loading...</span>
        <span id="times" style="text-align: center;font-size: 12px;">载入时分秒...</span>
    </div> -->
</footer>

<!-- <script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("11/06/2020 00:00:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "This site has been running for "+dnum+" days "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    }
    setInterval("createtime()",250);
</script> -->

    </div>

    <!--Start of Tawk.to Script-->
    <script type="text/javascript">
        var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
        (function(){
            var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
            s1.async=true;
            s1.src='https://embed.tawk.to/66b239041601a2195ba16829/1i4k2tesf';
            s1.charset='UTF-8';
            s1.setAttribute('crossorigin','*');
            s0.parentNode.insertBefore(s1,s0);
        })();
    </script>
    <!--End of Tawk.to Script-->
</body>

</html>