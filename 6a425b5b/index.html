<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="Allen">


    <meta name="subtitle" content="绿衣捧砚催题卷，红袖添香伴读书">




<title>从零开始学习Vue3源码（四、Vue3渲染原理） | 阿伦的个人博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



<!-- 百度统计，在head.ejs中引入 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4089b5476d9d7b1fbf81de2841dc180c";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    


<!-- 搜索 -->
<div id="algolia-search">
  <div class="search-dialog">  
    <nav class="search-nav">
      <span class="search-dialog-title">Search</span>
      <button class="search-close-button">
        <span class="iconfont icon-guanbi"></span>
      </button>
    </nav>
  
    <div class="search-wrap">
      <div id="algolia-search-input"></div>
      <hr />  
      <div id="algolia-search-results">
        <div id="algolia-hits"></div>
        <div id="algolia-pagination"></div>
        <div id="algolia-info">
          <div class="algolia-stats"></div>
          <div class="algolia-poweredBy"></div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="search-mask"></div>
  
  <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.66.1/dist/instantsearch.production.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/algoliasearch/4.23.2/algoliasearch-lite.umd.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/js/algolia.js"></script>
</div>



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="阿伦的个人博客" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
            } else {
                pagebody.classList.remove('dark-theme');
            }
            // mobile
            if (document.getElementById("mobile-toggle-theme")) {
                document.getElementById("mobile-toggle-theme").innerText = isDark ? "· Dark" : "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Allen&#39;s Blog</a></div>
            <div class="menu navbar-right">
                <!-- 其他的导航 -->
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                

                <!-- Search -->
                <span id="search-button" style="padding: 0 8px;cursor: pointer;">
                    <span class="search">Search</span>
                </span>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Allen&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">从零开始学习Vue3源码（四、Vue3渲染原理）</h1>
            
                <div class="post-meta">
                    
                    <!-- 
                        Author: <a itemprop="author" rel="author" href="/">Allen</a>
                     -->

                    
                        <span class="post-time">
                        
                        <!-- Date: <a href="#">三月 13, 2023&nbsp;&nbsp;11:11:08</a> -->
                        <span class="iconfont icon-date1"></span>
                        三月 13, 2023
                        </span>
                    
                    &nbsp;  &nbsp;
                    
                        <span class="post-category">
                            <span class="iconfont icon-icon-goodscategory"></span>
                            
                                <a href="/categories/Web%E5%89%8D%E7%AB%AF/">Web前端</a>
                            
                        </span>
                    
                    <!-- 展示当前文章所属tags -->
                    
                    &nbsp;  &nbsp;
                    <span class="iconfont icon-tags"></span>
                        <span>
                            
                                <a href="/tags/Vue/">Vue </a>&nbsp;
                            
                        </span>
                    
                    
                    
                        <!-- 文章字数和阅读时间 -->
<div style="display: inline;">
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-post"></span>
      <!-- <span class="post-meta-item-text">  Count: </span> -->
      <span class="post-count">7.2k Words</span>
    </span>
  </span>
  <!-- &nbsp; | &nbsp; -->
  &nbsp;  &nbsp;
  <span class="post-time">
    <span class="post-meta-item-icon">
      <span class="iconfont icon-time"></span>
      <!-- <span class="post-meta-item-text">  Time: </span> -->
      <span class="post-count">31 min</span>
    </span>
  </span>
</div>

                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章开始，我们就要继续学习<code>Vue3</code>中其它包的作用了，在前文也提到过，<code>Vue3</code>的组成，是有<strong>编译时</strong>和<strong>运行时</strong>的概念。</p>
<ul>
<li>编译时：其实就是将模板转化为函数的过程，举个例子，就是将我们写的模板代码，如<code>&lt;template&gt;&#123;&#123; msg &#125;&#125;&lt;/template&gt;</code>转化为函数。之所以用模板的方式来写，纯粹是为了减少开发的心智负担，能够根据语义化进行代码书写，而不必用各种函数调用的方式来生成。</li>
<li>运行时：运行时又分为两个部分，那么运行时的核心，也就是<code>runtime-core</code>是不依赖任何平台的，</li>
</ul>
<p>那么模块之间的依赖就是<code>runtime-dom</code>提供了浏览器运行环境中的<code>DOM API</code>，而<code>runtime-core</code>提供了虚拟<code>dom</code>的核心逻辑，通过<code>runtime-dom</code>提供的<code>API</code>，从而生成真实<code>DOM</code>，而<code>runtime-core</code>中又会引入<code>reactivity</code>包中的内容，所以整体的流程是<code>Vue -&gt; runtime-dom -&gt; runtime-core -&gt; reactivity</code>后者均是前者的子级，由前者导入使用。我们本篇文章主要讲运行时相关的内容。</p>
<p>在<code>runtime-core</code>包中，提供了一个方法<code>createRenderer</code>，看着虽然陌生，但是在我们项目中的<code>createApp</code>(在<code>runtime-dom</code>包中实现)，其实底层调用的就是这个方法，那么我们便从这个方法开始，一步步学习<code>runtime-dom</code>和<code>runtime-core</code>这两个包吧！</p>
<h3 id="runtime-dom的实现"><a href="#runtime-dom的实现" class="headerlink" title="runtime-dom的实现"></a><code>runtime-dom</code>的实现</h3><p>首先，我们依旧是要创建文件夹，和之前的套路一样，先看下示例效果，再进行代码书写。和<code>reactivity</code>包位置相同，我们创建<code>runtime-dom</code>文件夹和<code>package.json</code>文件，并且在<code>runtime-dom</code>文件夹下边创建<code>src/index.ts</code>作为入口；创建<code>dist/index.html</code>作为效果展示示例页面。同样，我们把<code>node_modules</code>文件夹中，<code>Vue</code>官方打包好的<code>compiler-dom.esm-browser.js</code>文件，复制进<code>dist</code>目录下，和我们之前<code>reactivity</code>的操作一模一样，先看看人家官方的方法实现效果，再自己实现一遍。最后，别忘了将<code>script/dev.js</code>中的<code>target</code>改为<code>runtime-dom</code>，这样，我们就是从<code>runtime-dom/src/index.ts</code>作为入口进行打包了。万事具备，我们写一下测试代码，看看有没有跑通吧：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-dom/src/index.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="type">const</span> testName = <span class="string">&#x27;测试runtime-dom&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后执行<code>npm run dev</code>，对我们<code>runtime-dom</code>模块的代码进行打包，之后修改<code>dist/index.html</code>文件内容，执行<code>npx serve dist</code>，在浏览器控制台观测结果，成功打印了<code>testName</code>，便说明我们已经调通了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// runtime-dom/dist/index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; testName &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(testName)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们首先看下两个方法：<code>createRenderer</code>和<code>h</code>的用法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// runtime-dom/dist/index.html 文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 引入的文件是我们刚才复制进来官方打报好的runtime-dom文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createRenderer, h &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么这两个方法，其实是<code>runtime-core</code>中提供的，前文也说过，其实<code>runtime-dom</code>提供的主要是浏览器相关的<code>API</code>，作为参数传入<code>createRenderer</code>中。什么意思呢？我们一步一步来看。</p>
<p>相信<code>h</code>方法，大家都有所耳闻，可以生成一个虚拟<code>DOM</code>，那么调用<code>createRenderer</code>就可以将虚拟<code>DOM</code>，通过我们传入的<code>API</code>，在页面中生成真实的<code>DOM</code>，我们再次修改示例代码，然后查看控制台结果。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// runtime-dom/dist/index.html 文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 引入的文件是我们刚才复制进来官方打报好的runtime-dom文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createRenderer, h &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderer = <span class="title function_">createRenderer</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将h1渲染到页面上</span></span></span><br><span class="line"><span class="language-javascript">renderer.<span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现控制台竟然报错了：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78aee4b64e9543568f6dc425d9471823~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"></p>
<p>代码非常简单，就是想要将<code>h1</code>标签渲染到页面上，但是为啥报错了呢？我们查看报错的内容，可以发现，提示我们缺少<code>insert</code>方法，这是啥意思呢？没错，前文提到了<code>runtime-dom</code>这个包中，提供了<code>DOM</code>操作的<code>API</code>，将这些<code>API</code>配置项等传入<code>createRenderer</code>，才能够正常的执行代码，所以我们此时要传入一个<code>insert</code>方法，告诉<code>runtime-core</code>在将虚拟<code>DOM</code>转化为真实<code>DOM</code>，进行插入操作，要用我们传入的这个<code>insert</code>方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// runtime-dom/dist/index.html 文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 引入的文件是我们刚才复制进来官方打报好的runtime-dom文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createRenderer, h &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderOptions = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 我们自己提供一个insert方法，当做api来调用</span></span></span><br><span class="line"><span class="language-javascript">  insert (el, container, anchor = <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    container.<span class="title function_">insertBefore</span>(el, anchor)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 传入配置项，里边包含各种操作的api</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderer = <span class="title function_">createRenderer</span>(renderOptions)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将h1渲染到页面上</span></span></span><br><span class="line"><span class="language-javascript">renderer.<span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时我们再刷新页面，发现又有了新的报错，很明显，有了前边的经验，我们很容易能明白，原来还缺少一个创建元素的方法，<code>runtime-core</code>不知道用哪个<code>API</code>来进行元素的创建，于是我们又补充了一下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// runtime-dom/dist/index.html 文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 引入的文件是我们刚才复制进来官方打报好的runtime-dom文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createRenderer, h &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderOptions = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 我们自己提供一个insert方法，当做api来调用</span></span></span><br><span class="line"><span class="language-javascript">  insert (el, container, anchor = <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    container.<span class="title function_">insertBefore</span>(el, anchor)</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 注意，报错中的hostCreateElement是对我们配置中的命名做了个映射，所以我们配置这里命名为createElement</span></span></span><br><span class="line"><span class="language-javascript">  createElement (element) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(element)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 传入配置项，里边包含各种操作的api</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderer = <span class="title function_">createRenderer</span>(renderOptions)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将h1渲染到页面上</span></span></span><br><span class="line"><span class="language-javascript">renderer.<span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们再运行代码，发现又有了一个报错，还真是没完没了- -，我们不难分析出来，还需要提供一个设置元素值的方法，于是我们再次修改了配置项</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// runtime-dom/dist/index.html 文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 引入的文件是我们刚才复制进来官方打报好的runtime-dom文件</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createRenderer, h &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderOptions = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 我们自己提供一个insert方法，当做api来调用</span></span></span><br><span class="line"><span class="language-javascript">  insert (el, container, anchor = <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    container.<span class="title function_">insertBefore</span>(el, anchor)</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 注意，报错中的hostCreateElement是对我们配置中的命名做了个映射，所以我们配置这里命名为createElement</span></span></span><br><span class="line"><span class="language-javascript">  createElement (element) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(element)</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 将文字内容赋值给元素</span></span></span><br><span class="line"><span class="language-javascript">  setElementText (el, text) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="property">innerHTML</span> = text</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 传入配置项，里边包含各种操作的api</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderer = <span class="title function_">createRenderer</span>(renderOptions)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将h1渲染到页面上</span></span></span><br><span class="line"><span class="language-javascript">renderer.<span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这次我们再刷新页面，可以发现，页面上终于打印出了<code>hello world</code>，也就是说，至少要提供创建元素、插入元素、设置元素内容这3个<code>API</code>，才能够在页面上正常显示一个基本的元素。</p>
<p>说了这么多，大家应该知道<code>runtime-dom</code>的大致作用了吧？没错，就是提供了上述的这些个<code>renderOptions</code>中<code>DOM</code>相关的<code>API</code>。所以，我们有了大致的思路，便开始实现一下吧！</p>
<p>目录结构如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtime-dom</span><br><span class="line">    src</span><br><span class="line">      <span class="keyword">module</span> <span class="comment">// 存放模块文件</span></span><br><span class="line">      index.ts <span class="comment">// 入口文件</span></span><br><span class="line">      nodeOps.ts <span class="comment">// 操作节点相关的api</span></span><br><span class="line">      patchProp.ts <span class="comment">// 属性相关的api   </span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/index.ts</span><br><span class="line">import &#123; nodeOps &#125; from &#x27;./nodeOps&#x27;</span><br><span class="line">import &#123; patchProp &#125; from &#x27;./patchProp&#x27;</span><br><span class="line"></span><br><span class="line">// 将渲染时所需要的属性做整理</span><br><span class="line">export const renderOptions = Object.assign(&#123; patchProp &#125;, nodeOps)</span><br></pre></td></tr></table></figure>

<p>nodeOps.ts<code>文件中，我们存放了和节点相关的操作，不止上文中提到的三个，常见的还有如下一些</code>API`：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/nodeOps.ts文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nodeOps = &#123;</span><br><span class="line">  <span class="attr">insert</span>: <span class="function">(<span class="params">child, parent, anchor</span>) =&gt;</span> &#123; <span class="comment">// 添加节点</span></span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(child, anchor || <span class="literal">null</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">remove</span>: <span class="function"><span class="params">child</span> =&gt;</span> &#123; <span class="comment">// 节点删除</span></span><br><span class="line">      <span class="keyword">const</span> parent = child.<span class="property">parentNode</span>;</span><br><span class="line">      <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">          parent.<span class="title function_">removeChild</span>(child);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">createElement</span>: <span class="function">(<span class="params">tag</span>) =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tag),<span class="comment">// 创建节点</span></span><br><span class="line">  <span class="attr">createText</span>: <span class="function"><span class="params">text</span> =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(text),<span class="comment">// 创建文本</span></span><br><span class="line">  <span class="attr">setText</span>: <span class="function">(<span class="params">node, text</span>) =&gt;</span> node.<span class="property">nodeValue</span> = text, <span class="comment">//  设置文本节点内容</span></span><br><span class="line">  <span class="attr">setElementText</span>: <span class="function">(<span class="params">el, text</span>) =&gt;</span> el.<span class="property">textContent</span> = text, <span class="comment">// 设置文本元素中的内容</span></span><br><span class="line">  <span class="attr">parentNode</span>: <span class="function"><span class="params">node</span> =&gt;</span> node.<span class="property">parentNode</span>, <span class="comment">// 父节点</span></span><br><span class="line">  <span class="attr">nextSibling</span>: <span class="function"><span class="params">node</span> =&gt;</span> node.<span class="property">nextSibling</span>, <span class="comment">// 下一个节点</span></span><br><span class="line">  <span class="attr">querySelector</span>: <span class="function"><span class="params">selector</span> =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector) <span class="comment">// 查找元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了节点操作，还涉及到了对比属性的方法，比如处理类，样式的替换，事件的绑定解绑，这些都写在<code>src/patchProp.ts</code>文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/patchProp.ts文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; patchClass &#125; <span class="keyword">from</span> <span class="string">&#x27;./module/class&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; patchStyle &#125; <span class="keyword">from</span> <span class="string">&#x27;./module/style&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; patchEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;./module/event&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; patchAttr &#125; <span class="keyword">from</span> <span class="string">&#x27;./module/attr&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比对属性的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">patchProp</span> = (<span class="params">el, key, prevValue, nextValue</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">patchClass</span>(el, nextValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;style&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">patchStyle</span>(el, prevValue, nextValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/^on[^a-z]/</span>.<span class="title function_">test</span>(key)) &#123;</span><br><span class="line">    <span class="title function_">patchEvent</span>(el, key, nextValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">patchAttr</span>(el, key, nextValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对不同情况的处理，把这些文件单独放在<code>module</code>文件夹下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/module/attr.ts 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">patchAttr</span>(<span class="params">el, key, value</span>) &#123; <span class="comment">// 更新属性</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    el.<span class="title function_">removeAttribute</span>(key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el.<span class="title function_">setAttribute</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/module/class.ts 文件</span><br><span class="line">export function patchClass(el, value) &#123; // 根据最新值设置类名</span><br><span class="line">  if (value == null) &#123;</span><br><span class="line">    el.removeAttribute(&#x27;class&#x27;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    el.className = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// src/module/event.ts 文件</span><br><span class="line"></span><br><span class="line">function createInvoker(initialValue) &#123;</span><br><span class="line">  const invoker = (e) =&gt; invoker.value(e)</span><br><span class="line">  // 真实的方法，是绑定在.value上的</span><br><span class="line">  invoker.value = initialValue</span><br><span class="line">  return invoker;</span><br><span class="line">&#125;</span><br><span class="line">export function patchEvent(el, rawName, nextValue) &#123;</span><br><span class="line">  const invokers = el._vei || (el._vei = &#123;&#125;)</span><br><span class="line">  const exisitingInvoker = invokers[rawName] // 是否缓存过</span><br><span class="line"></span><br><span class="line">  if (nextValue &amp;&amp; exisitingInvoker) &#123;</span><br><span class="line">    // 有新值并且绑定过事件，需要进行换绑操作</span><br><span class="line">    exisitingInvoker.value = nextValue;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 获取注册事件的名称</span><br><span class="line">    const name = rawName.slice(2).toLowerCase()</span><br><span class="line">    if (nextValue) &#123;// 缓存函数</span><br><span class="line">      const invoker = (invokers[rawName]) = createInvoker(nextValue)</span><br><span class="line">      el.addEventListener(name, invoker);</span><br><span class="line">    &#125; else if (exisitingInvoker) &#123;</span><br><span class="line">      el.removeEventListener(name, exisitingInvoker);</span><br><span class="line">      invokers[rawName] = undefined</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// src/module/style.ts 文件</span><br><span class="line">export function patchStyle(el, prev, next) &#123; // 更新style</span><br><span class="line">  const style = el.style;</span><br><span class="line">  for (const key in next) &#123; // 用最新的直接覆盖</span><br><span class="line">    style[key] = next[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if (prev) &#123;</span><br><span class="line">    for (const key in prev) &#123;// 老的有新的没有删除</span><br><span class="line">      if (next[key] == null) &#123;</span><br><span class="line">        style[key] = null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么有了这些个<code>API</code>，<code>runtime-core</code>就知道，应该用哪些方法将虚拟<code>DOM</code>转化为真实<code>DOM</code>了。之后，我们引入自己的<code>renderOptions</code>看看能不能正常渲染：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createRenderer, h &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; renderOptions &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> renderer = <span class="title function_">createRenderer</span>(renderOptions)</span></span><br><span class="line"><span class="language-javascript">renderer.<span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面正常渲染了！那么针对上文这种方式，适合针对某个平台（跨平台），自己定义一套渲染<code>API</code>，可以随意进行定制化，如果在浏览器环境下，其实正如上文所说，<code>API</code>都已经在<code>runtime-dom</code>中了，所以在内部又提供了一个方法(<code>render</code>)，默认把这一坨<code>renderOptions</code>自动传进去了，不用我们再手动传入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createRenderer, h, render &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// import &#123; renderOptions &#125; from &#x27;./runtime-dom.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//const renderer = createRenderer(renderOptions)</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//renderer.render(h(&#x27;h1&#x27;, &#x27;hello&#x27;), app)</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次运行代码，发现结果没变，还是能正常运行，说明这两种方式都可行，使用<code>render</code>的话，相当于默认传入浏览器环境下的<code>API</code>，使用<code>createRenderer</code>可以自定义传入<code>API</code>，比较灵活，所以，我们最后还需要改一下入口文件的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; nodeOps &#125; <span class="keyword">from</span> <span class="string">&#x27;./nodeOps&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; patchProp &#125; <span class="keyword">from</span> <span class="string">&#x27;./patchProp&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRenderer <span class="keyword">as</span> renderer &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将渲染时所需要的属性做整理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> renderOptions = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; patchProp &#125;, nodeOps)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRenderer</span> (options) &#123;</span><br><span class="line">  <span class="comment">// 提供了渲染的api，但实际调用的是runtime-core中的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">renderer</span>(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 专门给浏览器环境中使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span> (vnode, container) &#123;</span><br><span class="line">  <span class="keyword">const</span> renderer = <span class="title function_">createRenderer</span>(renderOptions)</span><br><span class="line">  <span class="keyword">return</span> renderer.<span class="title function_">render</span>(vnode, container)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将runtime-core中的方法都进行导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br></pre></td></tr></table></figure>

<p>诶，这样就没啥问题了，既然从<code>runtime-core</code>包中引入了渲染的方法，那么接下来我们需要的就是来实现<code>runtime-core</code>的核心逻辑了。</p>
<h3 id="runtime-core的实现"><a href="#runtime-core的实现" class="headerlink" title="runtime-core的实现"></a><code>runtime-core</code>的实现</h3><p>老规矩，首先还是创建相应文件夹：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtime-core</span><br><span class="line">      src</span><br><span class="line">        index.<span class="property">ts</span> <span class="comment">// 入口文件</span></span><br><span class="line">        createVNode.<span class="property">ts</span> <span class="comment">// 创建虚拟DOM</span></span><br><span class="line">        renderer.<span class="property">ts</span> <span class="comment">// 创建真实DOM进行渲染</span></span><br><span class="line">        h.<span class="property">ts</span> <span class="comment">// 封装createVNode，形成h方法</span></span><br></pre></td></tr></table></figure>

<p>先在入口文件进行导出操作，防止后边忘记掉，我们不难发现，正如我们之前所说，<code>runtime-dom</code>将<code>DOM</code>相关<code>API</code>传给<code>runtime-core</code>，<code>runtime-core</code>中又使用了<code>reactivity</code>模块，至此，三个模块便互相串通了起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts 入口文件</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./renderer&#x27;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./createVNode&#x27;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./h&#x27;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们还是先紧跟着<code>runtime-dom</code>的逻辑，先写下<code>renderer.ts</code>的大概逻辑，那么这个就是我们<code>runtime-dom</code>中使用的<code>createRenderer</code>方法，实际上调用的还是<code>runtime-core</code>中的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// renderer.ts文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRenderer</span>(<span class="params">renderOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 从renderOptions中解构api，并重命名</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">insert</span>: hostInsert,</span><br><span class="line">    <span class="attr">remove</span>: hostRemove,</span><br><span class="line">    <span class="attr">patchProp</span>: hostPatchProp,</span><br><span class="line">    <span class="attr">createElement</span>: hostCreateElement,</span><br><span class="line">    <span class="attr">createText</span>: hostCreateText,</span><br><span class="line">    <span class="attr">setText</span>: hostSetText,</span><br><span class="line">    <span class="attr">setElementText</span>: hostSetElementText,</span><br><span class="line">    <span class="attr">parentNode</span>: hostParentNode,</span><br><span class="line">    <span class="attr">nextSibling</span>: hostNextSibling,</span><br><span class="line">    <span class="attr">querySelector</span>: hostQuerySelector</span><br><span class="line">  &#125; = renderOptions</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们写一下<code>createVNode.ts</code>中的逻辑。所谓虚拟<code>DOM</code>，就是用对象的形式，来形容一个节点，标注了各种信息，为了之后转化成真实<code>DOM</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ShapeFlags</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="comment">// 判断是不是一个虚拟节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isVNode</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value ? value.<span class="property">__v_isVNode</span> === <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createVNode</span>(<span class="params">type, props, children = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> shapeFlag = <span class="keyword">typeof</span> type === <span class="string">&#x27;string&#x27;</span> ? <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span> : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 虚拟节点包含的信息</span></span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    <span class="attr">__v_isVNode</span>: <span class="literal">true</span>, <span class="comment">// 判断对象是不是虚拟节点</span></span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    <span class="attr">key</span>: props &amp;&amp; props[<span class="string">&#x27;key&#x27;</span>], <span class="comment">// 虚拟节点的key，主要用于diff算法</span></span><br><span class="line">    <span class="attr">el</span>: <span class="literal">null</span>, <span class="comment">// 虚拟节点对应的真实节点</span></span><br><span class="line">    children,</span><br><span class="line">    shapeFlag</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line">      type = <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      children = <span class="title class_">String</span>(children);</span><br><span class="line">      type = <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span></span><br><span class="line">    &#125;</span><br><span class="line">    vnode.<span class="property">shapeFlag</span> |= type</span><br><span class="line">    <span class="comment">// 如果shapeFlag结果为9 说明元素中包含一个文本</span></span><br><span class="line">    <span class="comment">// 如果shapeFlag结果为17 说明元素中有多个子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回的虚拟节点并且标注了虚拟节点的类型，之后生成真实DOM时，根据shapFlag调用不同的方法。</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>@vue/shared</code>包中补充下<code>ShapFlags</code>，并且来详细解释一下，这到底是个什么东西。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared/src/index.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">ShapeFlags</span> &#123; <span class="comment">// Vue3提供的标识</span></span><br><span class="line">  <span class="variable constant_">ELEMENT</span> = <span class="number">1</span>, <span class="comment">// 元素</span></span><br><span class="line">  <span class="variable constant_">FUNCTIONAL_COMPONENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 函数式组件</span></span><br><span class="line">  <span class="variable constant_">STATEFUL_COMPONENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 普通状态组件</span></span><br><span class="line">  <span class="variable constant_">TEXT_CHILDREN</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 组件儿子为文本</span></span><br><span class="line">  <span class="variable constant_">ARRAY_CHILDREN</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 组件的儿子为数组</span></span><br><span class="line">  <span class="variable constant_">SLOTS_CHILDREN</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 组件的插槽</span></span><br><span class="line">  <span class="variable constant_">TELEPORT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">// 传送门组件</span></span><br><span class="line">  <span class="variable constant_">SUSPENSE</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 异步加载组件</span></span><br><span class="line">  <span class="variable constant_">COMPONENT_SHOULD_KEEP_ALIVE</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// keep-alive相关</span></span><br><span class="line">  <span class="variable constant_">COMPONENT_KEPT_ALIVE</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">// keep-alive相关</span></span><br><span class="line">  <span class="variable constant_">COMPONENT</span> = <span class="title class_">ShapeFlags</span>.<span class="property">STATEFUL_COMPONENT</span> | <span class="title class_">ShapeFlags</span>.<span class="property">FUNCTIONAL_COMPONENT</span> <span class="comment">// 按位或操作，相当于包含两种类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多朋友可能对<code>&lt;&lt; | &amp;</code>移位、按位或、按位与很陌生，就算知道其定义，也不知道有哪些个使用场景。其实在<code>Vue3</code>中，就有很好的例子。比如这个<code>ShapFlags</code>通过名称我们便能大致猜出来，是描述形状的标志，比如一个普通的元素，就用1来代表，函数式组件就用1向左移1位来表示，普通的状态组件，就用1向左移2位来表示。为啥要用移位操作呢？搞几个普通的枚举值不行么，其实，之所以用移位来进行标识，是为了后续进行按位与，按位或操作提供了极大的便利。我们举个例子，我们有如下的3种权限：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试：<span class="number">1</span>，二进制为<span class="number">001</span></span><br><span class="line">开发者：<span class="number">1</span> &lt;&lt; <span class="number">1</span>，二进制为<span class="number">010</span></span><br><span class="line">超级管理员：<span class="number">1</span> &lt;&lt; <span class="number">2</span>，二进制为<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>那么当<code>A</code>，既是<code>开发者</code>，又是<code>超级管理员</code>的时候，那么只需要将<code>开发者</code>和<code>超级管理员</code>的权限进行按位或操作，也就是<code>010</code>和<code>100</code>进行按位或操作，得到的结果为<code>110</code>，大于<code>0</code>。那么判断<code>A</code>有没有<code>测试</code>权限，只需要将刚才的结果和<code>测试</code>的权限进行按位与操作，即<code>110</code>和<code>001</code>进行按位与操作，得到的结果为<code>000</code>，等于<code>0</code>。从而我们可以发现，在使用移位符操作的枚举值，进行<code>|</code>操作后，相当于权限相加的操作，进行<code>&amp;</code>操作后，如果结果大于<code>0</code>，说明包含相关权限，如果结果等于<code>0</code>，则说明不包括相关权限。</p>
<p>那么再回到我们之前的实例，我们改动下<code>index.html</code>中的代码，来调试下代码有没有生效，先调试下<code>createVNode</code>方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createVNode &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">createVNode</span>(<span class="string">&#x27;div&#x27;</span>,<span class="literal">null</span>, [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打印结果可以看到，虚拟节点成功的被创建了：</p>
<p>但是<code>createVNode</code>这个方法，写法是固定的，比如传参的顺序和类型，都不能变，并不灵活，（特别注意，<code>createVNode</code>的第三个参数，只能传字符串和数组类型的数据），所以，我们可以基于<code>createVNode</code>进行封装，那么这个方法就是我们熟悉的<code>h</code>方法了，首先我们先看下<code>h</code>方法能怎么传参：</p>
<ul>
<li>只传1个参数，就是标签；</li>
<li>传2个参数，可能是传标签和属性：<code>h(&#39;div&#39;, &#123; style: &#123; color: &#39;red&#39; &#125; &#125;)</code>，也可能是传标签和子元素：<code>h(&#39;div&#39;, h(&#39;span&#39;, null, &#39;hello&#39;))  h(&#39;div&#39;, [h(&#39;span&#39;, null, &#39;hello&#39;)])</code>，还可能是传标签和内容：<code>h(&#39;div&#39;, &#39;hello&#39;)</code></li>
<li>传3个参数，那就是和<code>createVNode</code>的传参一样了，即<code>h(&#39;div&#39;, &#123; style: &#123;color: &#39;red&#39;&#125; &#125;, &#39;hello&#39;)</code></li>
<li>传3个以上的参数，第二个参数必须是属性，之后的参数都作为内容：<code>h(&#39;div&#39;, null, &#39;hello&#39;, &#39;world&#39;, &#39;!&#39;)</code></li>
</ul>
<p>那么知道了以上的用法，我们便可以按照传参数量的不同，分别处理相应逻辑，来编写<code>h</code>方法了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h.ts 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; isArray, isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/shared&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVNode, isVNode &#125; <span class="keyword">from</span> <span class="string">&#x27;./createVNode&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params">type, propsOrChildren?, children?</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> l = <span class="variable language_">arguments</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (l === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有属性，或者只有一个生成的虚拟元素的时候</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(propsOrChildren) &amp;&amp; !<span class="title function_">isArray</span>(propsOrChildren)) &#123;</span><br><span class="line">      <span class="comment">// 区分第二个参数是属性还是生成的虚拟元素，比如h(&#x27;div&#x27;,h(&#x27;span&#x27;))</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isVNode</span>(propsOrChildren)) &#123;</span><br><span class="line">        <span class="comment">// 如果是虚拟元素，根据createVNode的传参要求，就要用数组包起来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">createVNode</span>(type, <span class="literal">null</span>, [propsOrChildren])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是h(&#x27;div&#x27;,&#123;style:&#123;color:&#x27;red&#x27;&#125;&#125;)，则进行如下传参</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createVNode</span>(type, propsOrChildren)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 传递儿子列表h(&#x27;div&#x27;,null,[h(&#x27;span&#x27;),h(&#x27;span&#x27;)])或者h(&#x27;div&#x27;, &#x27;hello&#x27;)的情况</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createVNode</span>(type, <span class="literal">null</span>, propsOrChildren)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 除了前2个，后边的都是子元素</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">3</span>) &#123;</span><br><span class="line">      children = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">2</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l === <span class="number">3</span> &amp;&amp; <span class="title function_">isVNode</span>(children)) &#123;</span><br><span class="line">      <span class="comment">// 第三个参数传入的是生成的虚拟元素</span></span><br><span class="line">      children = [children]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createVNode</span>(type, propsOrChildren, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，我们<code>h</code>方法便写好了，是不是没有想象中那么困难呢？</p>
<p>接下来，就该完善<code>createRenderer</code>方法，也就是渲染方法了，之后二者一结合，就能够在页面中，将虚拟<code>DOM</code>渲染成真实<code>DOM</code>了，刚才我们写到了<code>render</code>方法，那我们继续完善吧！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// renderer.ts 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRenderer</span>(<span class="params">renderOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 从renderOptions中解构api，并重命名</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">insert</span>: hostInsert,</span><br><span class="line">    <span class="attr">remove</span>: hostRemove,</span><br><span class="line">    <span class="attr">patchProp</span>: hostPatchProp,</span><br><span class="line">    <span class="attr">createElement</span>: hostCreateElement,</span><br><span class="line">    <span class="attr">createText</span>: hostCreateText,</span><br><span class="line">    <span class="attr">setText</span>: hostSetText,</span><br><span class="line">    <span class="attr">setElementText</span>: hostSetElementText,</span><br><span class="line">    <span class="attr">parentNode</span>: hostParentNode,</span><br><span class="line">    <span class="attr">nextSibling</span>: hostNextSibling,</span><br><span class="line">    <span class="attr">querySelector</span>: hostQuerySelector</span><br><span class="line">  &#125; = renderOptions</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 虚拟节点渲染成真实DOM，挂载到页面上</span></span><br><span class="line">    <span class="comment">// 卸载操作 render(null, container)</span></span><br><span class="line">    <span class="comment">// 初始化和更新虚拟DOM</span></span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 卸载逻辑</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始传入一个null作为老的虚拟DOM值；保留之前的vnode，为之后的diff算法做准备</span></span><br><span class="line">      <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    container.<span class="property">_vnode</span> = vnode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mountElement</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 将虚拟节点转化为真实DOM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟节点对比逻辑</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(n1 == n2) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化情况</span></span><br><span class="line">    <span class="title function_">mountElement</span>(n2, container)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// n1, n2不相等，diff算法逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么整个流程的架子我们已经搭好了，接下来就一个个来实现具体的方法，我们先实现将虚拟<code>DOM</code>转化为真实<code>DOM</code>的<code>mountElement</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// renderer.ts 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRenderer</span>(<span class="params">renderOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 从renderOptions中解构api，并重命名</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">insert</span>: hostInsert,</span><br><span class="line">    <span class="attr">remove</span>: hostRemove,</span><br><span class="line">    <span class="attr">patchProp</span>: hostPatchProp,</span><br><span class="line">    <span class="attr">createElement</span>: hostCreateElement,</span><br><span class="line">    <span class="attr">createText</span>: hostCreateText,</span><br><span class="line">    <span class="attr">setText</span>: hostSetText,</span><br><span class="line">    <span class="attr">setElementText</span>: hostSetElementText,</span><br><span class="line">    <span class="attr">parentNode</span>: hostParentNode,</span><br><span class="line">    <span class="attr">nextSibling</span>: hostNextSibling,</span><br><span class="line">    <span class="attr">querySelector</span>: hostQuerySelector</span><br><span class="line">  &#125; = renderOptions</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">mountChildren</span> = (<span class="params">children, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 递归调用patch方法</span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>,children[i],container)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">mountElement</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将虚拟节点转化为真实DOM</span></span><br><span class="line">    <span class="keyword">const</span> &#123; type, props, shapeFlag, children &#125; = vnode</span><br><span class="line">    <span class="comment">// 创建真实元素，挂载到虚拟节点上</span></span><br><span class="line">    <span class="keyword">let</span> el = vnode.<span class="property">el</span> = <span class="title function_">hostCreateElement</span>(type)</span><br><span class="line">    <span class="comment">// 如果有props，则处理属性</span></span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, key, <span class="literal">null</span>, props[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(children) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明是文本</span></span><br><span class="line">        <span class="title function_">hostSetElementText</span>(el, vnode.<span class="property">children</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明有多个儿子</span></span><br><span class="line">        <span class="title function_">mountChildren</span>(vnode.<span class="property">children</span>, el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hostInsert</span>(el,container); <span class="comment">// 插入到容器中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 虚拟节点对比逻辑</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(n1 == n2) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化情况</span></span><br><span class="line">      <span class="title function_">mountElement</span>(n2, container)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// n1, n2不相等，diff算法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 虚拟节点渲染成真实DOM，挂载到页面上</span></span><br><span class="line">    <span class="comment">// 卸载操作 render(null, container)</span></span><br><span class="line">    <span class="comment">// 初始化和更新虚拟DOM</span></span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 卸载逻辑</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始传入一个null作为老的虚拟DOM值；保留之前的vnode，为之后的diff算法做准备</span></span><br><span class="line">      <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    container.<span class="property">_vnode</span> = vnode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以清楚的看到，就是用了<code>runtime-dom</code>中的<code>API</code>，来递归生成真实的<code>DOM</code>元素，我们来验证一下，代码是否有问题吧：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; h, render &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125;, <span class="string">&#x27;hello&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器中运行完代码，发现，<code>hello</code>已经成功被渲染到页面上了。那么初始化阶段的渲染的逻辑，便写完了！那么初始化逻辑写完后，我们再写一下卸载的逻辑，什么是卸载的逻辑呢？可以理解为<code>render(null, app)</code>，也就是传入了<code>null</code>的时候，要把页面中元素清除掉，我们之前已经预留出来卸载逻辑的位置，那我们现在便可以来完善了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// renderer.ts 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRenderer</span>(<span class="params">renderOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 从renderOptions中解构api，并重命名</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">insert</span>: hostInsert,</span><br><span class="line">    <span class="attr">remove</span>: hostRemove,</span><br><span class="line">    <span class="attr">patchProp</span>: hostPatchProp,</span><br><span class="line">    <span class="attr">createElement</span>: hostCreateElement,</span><br><span class="line">    <span class="attr">createText</span>: hostCreateText,</span><br><span class="line">    <span class="attr">setText</span>: hostSetText,</span><br><span class="line">    <span class="attr">setElementText</span>: hostSetElementText,</span><br><span class="line">    <span class="attr">parentNode</span>: hostParentNode,</span><br><span class="line">    <span class="attr">nextSibling</span>: hostNextSibling,</span><br><span class="line">    <span class="attr">querySelector</span>: hostQuerySelector</span><br><span class="line">  &#125; = renderOptions</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">mountChildren</span> = (<span class="params">children, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 递归调用patch方法</span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>,children[i],container)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">mountElement</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将虚拟节点转化为真实DOM</span></span><br><span class="line">    <span class="keyword">const</span> &#123; type, props, shapeFlag, children &#125; = vnode</span><br><span class="line">    <span class="comment">// 创建真实元素，挂载到虚拟节点上</span></span><br><span class="line">    <span class="keyword">let</span> el = vnode.<span class="property">el</span> = <span class="title function_">hostCreateElement</span>(type)</span><br><span class="line">    <span class="comment">// 如果有props，则处理属性</span></span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, key, <span class="literal">null</span>, props[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(children) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明是文本</span></span><br><span class="line">        <span class="title function_">hostSetElementText</span>(el, vnode.<span class="property">children</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明有多个儿子</span></span><br><span class="line">        <span class="title function_">mountChildren</span>(vnode.<span class="property">children</span>, el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hostInsert</span>(el,container); <span class="comment">// 插入到容器中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 虚拟节点对比逻辑</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(n1 == n2) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化情况</span></span><br><span class="line">      <span class="title function_">mountElement</span>(n2, container)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// n1, n2不相等，diff算法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 卸载元素的方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">unmount</span> = vnode =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span>(shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是一个元素，那么直接删除DOM即可</span></span><br><span class="line">      <span class="title function_">hostRemove</span>(vnode.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 虚拟节点渲染成真实DOM，挂载到页面上</span></span><br><span class="line">    <span class="comment">// 卸载操作 render(null, container)</span></span><br><span class="line">    <span class="comment">// 初始化和更新虚拟DOM</span></span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 卸载逻辑</span></span><br><span class="line">      <span class="keyword">if</span>(container.<span class="property">_vnode</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到对应的真实节点，将其卸载</span></span><br><span class="line">        <span class="title function_">unmount</span>(container.<span class="property">_vnode</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始传入一个null作为老的虚拟DOM值；保留之前的vnode，为之后的diff算法做准备</span></span><br><span class="line">      <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    container.<span class="property">_vnode</span> = vnode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，就只剩下元素更新的逻辑了，那么元素更新的逻辑，涉及的内容又非常多，我们先讲一些关键性的点，从而为后续文章做好铺垫。我们用几个不同的例子，来表明什么时候触发更新，也就是说，怎么判断两个虚拟节点相同，可以复用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; h, render &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1、可以看到，标签名不相同，所以就不能够进行DOM复用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125;, <span class="string">&#x27;hello&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;&#125;, <span class="string">&#x27;world&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2、那么如果标签名相同，又不想复用DOM，那么这时候就需要提供key，来进行区分了</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;, <span class="attr">key</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;world&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;, <span class="attr">key</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;world&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3、如果标签名相同，也没有key，那么就进行复用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125;, <span class="string">&#x27;hello&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125;, <span class="string">&#x27;hello&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以我们可以得到结论，当两个虚拟节点的标签类型不同时候，或者两个虚拟节点标签类型相同，但是key不同，那么就不会进行复用；如果两个虚拟节点的标签类型相同，并且不传入key，或者key相同，那么就进行复用。</p>
</blockquote>
<p>所以，我们需要继续改进下更新下<code>patch</code>方法中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// renderer.ts 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRenderer</span>(<span class="params">renderOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 从renderOptions中解构api，并重命名</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">insert</span>: hostInsert,</span><br><span class="line">    <span class="attr">remove</span>: hostRemove,</span><br><span class="line">    <span class="attr">patchProp</span>: hostPatchProp,</span><br><span class="line">    <span class="attr">createElement</span>: hostCreateElement,</span><br><span class="line">    <span class="attr">createText</span>: hostCreateText,</span><br><span class="line">    <span class="attr">setText</span>: hostSetText,</span><br><span class="line">    <span class="attr">setElementText</span>: hostSetElementText,</span><br><span class="line">    <span class="attr">parentNode</span>: hostParentNode,</span><br><span class="line">    <span class="attr">nextSibling</span>: hostNextSibling,</span><br><span class="line">    <span class="attr">querySelector</span>: hostQuerySelector</span><br><span class="line">  &#125; = renderOptions</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">mountChildren</span> = (<span class="params">children, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 递归调用patch方法</span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>,children[i],container)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">mountElement</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将虚拟节点转化为真实DOM</span></span><br><span class="line">    <span class="keyword">const</span> &#123; type, props, shapeFlag, children &#125; = vnode</span><br><span class="line">    <span class="comment">// 创建真实元素，挂载到虚拟节点上</span></span><br><span class="line">    <span class="keyword">let</span> el = vnode.<span class="property">el</span> = <span class="title function_">hostCreateElement</span>(type)</span><br><span class="line">    <span class="comment">// 如果有props，则处理属性</span></span><br><span class="line">    <span class="keyword">if</span> (props) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, key, <span class="literal">null</span>, props[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(children) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明是文本</span></span><br><span class="line">        <span class="title function_">hostSetElementText</span>(el, vnode.<span class="property">children</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明有多个儿子</span></span><br><span class="line">        <span class="title function_">mountChildren</span>(vnode.<span class="property">children</span>, el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hostInsert</span>(el,container); <span class="comment">// 插入到容器中</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是不是相同的虚拟节点</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isSameVNode</span> = (<span class="params">n1, n2</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.<span class="property">type</span> === n2.<span class="property">type</span> &amp;&amp; n1.<span class="property">key</span> === n2.<span class="property">key</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理元素</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">processElement</span> = (<span class="params">n1, n2, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化情况</span></span><br><span class="line">      <span class="title function_">mountElement</span>(n2, container)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 元素相同，属性更新了，可以进行复用，进行diff的逻辑</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 虚拟节点对比逻辑</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(n1 == n2) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n1 &amp;&amp; !<span class="title function_">isSameVNode</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(n1)</span><br><span class="line">      n1 = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">    <span class="title function_">processElement</span>(n1, n2, container)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 卸载元素的方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">unmount</span> = vnode =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span>(shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是一个元素，那么直接删除DOM即可</span></span><br><span class="line">      <span class="title function_">hostRemove</span>(vnode.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 虚拟节点渲染成真实DOM，挂载到页面上</span></span><br><span class="line">    <span class="comment">// 卸载操作 render(null, container)</span></span><br><span class="line">    <span class="comment">// 初始化和更新虚拟DOM</span></span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 卸载逻辑</span></span><br><span class="line">      <span class="keyword">if</span>(container.<span class="property">_vnode</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到对应的真实节点，将其卸载</span></span><br><span class="line">        <span class="title function_">unmount</span>(container.<span class="property">_vnode</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始传入一个null作为老的虚拟DOM值；保留之前的vnode，为之后的diff算法做准备</span></span><br><span class="line">      <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    container.<span class="property">_vnode</span> = vnode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们又将当两个虚拟节点不相同时的更新逻辑写完了，我们改下调试代码，在页面上看效果，发现，过了1秒钟后，成功的渲染了新的虚拟节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">import</span> &#123; h, render &#125; <span class="keyword">from</span> <span class="string">&#x27;./runtime-dom.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;, <span class="string">&#x27;hello&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">render</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125; &#125;, <span class="string">&#x27;world&#x27;</span>), app)</span></span><br><span class="line"><span class="language-javascript">   &#125;, <span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以，当两个虚拟节点可以复用时的逻辑，我们就放到后续文章中，进行详细的讲解，因为会涉及到我们耳熟能详的<code>diff</code>算法。</p>
<p>作者：柠檬soda水<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7209906040921489468">https://juejin.cn/post/7209906040921489468</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

        </div>
        <br />

        <!-- 分享 -->
        <div id="social-share" class="article-social-share"></div>

        <!-- 评论系统 -->
        
            <section id="comments" class="comments">
              <!-- 可以添加样式
              <style>
                .comments{margin:30px;padding:10px;background:#fff}
                @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
              </style> -->
              <!-- 评论系统。在post.ejs中引入 -->
<div class="valine_comment"></div>
<script type="module">
  import { init } from '/js/waline.mjs';
  // import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js'; // 在线url
  init({
    el: '.valine_comment',
    serverURL: 'https://blog.comment.helloallen.cn',
    // serverURL: 'https://allen-blog-vercel.vercel.app', // 未绑定域名的评论url，只能外网访问
  });
</script>
            </section>
        

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Vue/"># Vue</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <!-- 另一种的上一篇下一篇 -->
        <!-- <section class="post-nav">
            
                <a class="prev" rel="prev" href="/17c2e848/">从零开始学习Vue3源码（三、Vue3响应式原理（下））</a>
            
            
            <a class="next" rel="next" href="/761e6d87/">NVM：Node 版本管理</a>
            
        </section> -->
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/17c2e848/"> &laquo; Prev </a>
            
            
                <a class="next" rel="next" href="/761e6d87/"> Next &raquo; </a>
            
        </section>


    </article>
</div>

            </div>
            <!-- 分享 -->
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" defer></script>
<link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">

<footer id="footer" class="footer">
    <div>
        <span>
            Allen © 
                2015 - 
                2024  
        </span> |   <!-- 站点访问量统计。在footer.ejs中引入 -->
<script async src="/js/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    <i class="iconfont icon-peoplecopy3"></i>
    <span id="busuanzi_value_site_uv"></span>
</span>&nbsp;


<span class="site-pv">
    <i class="iconfont icon-view"></i>
    <span id="busuanzi_value_site_pv"></span>
</span>

 
    </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & Theme by <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
        </span>
    </div>

    <!-- 上个版本的统计当前站点运行时间 -->
    <!-- <div class="copyright">
        <span>© Allen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
        | <span id="timeDate">loading...</span>
        <span id="times" style="text-align: center;font-size: 12px;">载入时分秒...</span>
    </div> -->
</footer>

<!-- <script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("11/06/2020 00:00:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "This site has been running for "+dnum+" days "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    }
    setInterval("createtime()",250);
</script> -->

    </div>

    <!--Start of Tawk.to Script-->
    <script type="text/javascript">
        var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
        (function(){
            var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
            s1.async=true;
            s1.src='https://embed.tawk.to/66b239041601a2195ba16829/1i4k2tesf';
            s1.charset='UTF-8';
            s1.setAttribute('crossorigin','*');
            s0.parentNode.insertBefore(s1,s0);
        })();
    </script>
    <!--End of Tawk.to Script-->
</body>

</html>