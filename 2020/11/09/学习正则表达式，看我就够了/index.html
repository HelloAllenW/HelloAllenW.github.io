<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Allen">


    <meta name="subtitle" content="绿衣捧砚催题卷，红袖添香伴读书">




<title>学习正则表达式，看我就够了 | 阿伦的个人博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Allen&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Allen&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">学习正则表达式，看我就够了</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Allen</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 9, 2020&nbsp;&nbsp;23:16:54</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>本文旨在用最通俗的语言讲述最枯燥的基本知识。</p>
<blockquote>
<p>文章提纲：<br>1、元字符<br>2、重复限定符<br>3、分组<br>4、转义<br>5、条件或<br>6、区间<br>7、零宽断言<br>8、捕获和非捕获<br>9、反向引用<br>10、贪婪和非贪婪<br>11、反义</p>
</blockquote>
<p>正则表达式在几乎所有语言中都可以使用，无论是前端的 JavaScript、还是后端的 Java、c#。他们都提供相应的接口 / 函数支持正则表达式。<br>但很神奇的是：无论你大学选择哪一门计算机语言，都没有关于正则表达式的课程给你修，在你学会正则之前，你只能看着那些正则大师们，写了一串外星文似的字符串，替代了你用一大篇幅的 if else 代码来做一些数据校验。<br>既然喜欢，那就动手学呗，可当你百度出一一堆相关资料时，你发现无一不例外的枯燥至极，难以学习（实话说，当年不理君也是这样的心态）。<br>下面，不理君尝试用一种比较通俗点的方式讲一下正则，让你能在读完之后，能自己写出一些简单的正则，再不济，能看懂别人写的正则，那也不错了。</p>
<a id="more"></a>

<h1 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1. 元字符"></a>1. 元字符</h1><p>万物皆有缘，正则也是如此，元字符是构造正则表达式的一种基本元素。<br>我们先来记几个常用的元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结束</td>
</tr>
</tbody></table>
<p>有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，比如：<br>匹配有abc开头的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\babc或者^abc</span><br></pre></td></tr></table></figure>
<p>匹配8位数字的QQ号码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d\d\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure>
<p>匹配1开头11位数字的手机号码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^1\d\d\d\d\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure>

<h1 id="2-重复限定符"><a href="#2-重复限定符" class="headerlink" title="2. 重复限定符"></a>2. 重复限定符</h1><p>有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？<br>答案是有的！<br>为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：</p>
<p>匹配8位数字的QQ号码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<p>匹配1开头11位数字的手机号码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^1\d&#123;10&#125;$</span><br></pre></td></tr></table></figure>

<p>匹配银行卡号是14~18位的数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;14,18&#125;$</span><br></pre></td></tr></table></figure>

<p>匹配以a开头的，0个或多个b结尾的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></table></figure>

<h1 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h1><p>从上面的例子（4）中看到，限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要 ab 同时被限定那怎么办呢？<br>正则表达式中用小括号 () 来做分组，也就是括号中的内容作为一个整体。<br>因此当我们要匹配多个 ab 时，我们可以这样。<br>如：匹配字符串中包含 0 到多个 ab 开头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(ab)*</span><br></pre></td></tr></table></figure>

<h1 id="4-转义"><a href="#4-转义" class="headerlink" title="4. 转义"></a>4. 转义</h1><p>我们看到正则表达式用小括号来做分组，那么问题来了：<br>如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？<br>针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。如：要匹配以 (ab) 开头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\(ab\))*</span><br></pre></td></tr></table></figure>

<h1 id="5-条件或"><a href="#5-条件或" class="headerlink" title="5. 条件或"></a>5. 条件或</h1><p>回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有 130/131/132/155/156/185/186/145/176 等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？<br>正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。<br>那么我们就可以用或条件来处理这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(130|131|132|155|156|185|186|145|176)\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<h1 id="6-区间"><a href="#6-区间" class="headerlink" title="6. 区间"></a>6. 区间</h1><p>看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？</p>
<p>实际是有的。</p>
<p>正则提供了一个元字符中括号[]来表示区间条件。</p>
<p>限定0到9可以写成 [0-9]</p>
<p>限定A-Z写成[A-Z]</p>
<p>限定某些数字[165]</p>
<p>那上面的正则我们还改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((13[0-2])|(15[56])|(18[5-6])|145|176)\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<h1 id="7-零宽断言"><a href="#7-零宽断言" class="headerlink" title="7. 零宽断言"></a>7. 零宽断言</h1><p>无论是零宽还是断言，听起来都古古怪怪的，那先解释一下这两个词。</p>
<p><em>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”, 正则可以用断言找出 aa2 前面有 bb3，也可以找出 aa2 后面有 ss1.</em></p>
<p><em>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</em></p>
<p>意思是讲明白了，那他有什么用呢？</p>
<p>我们来举个栗子：</p>
<p>假设我们要用爬虫抓取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;span class&#x3D;&quot;read-count&quot;&gt;阅读数：641&lt;&#x2F;span&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其中只有‘641’这个是一个变量，也就是不同文章有不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果使用正则应该怎么匹配呢？</p>
<p>下面先讲一下几种类型的断言：</p>
<ul>
<li>正向先行断言（正前瞻）<br>语法：<code>（?=pattern）</code></li>
</ul>
<p>作用：匹配 pattern 表达式的前面内容，不返回本身。</p>
<p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘</span>’前面的数字内容按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=</span>) 就可以匹配到前面的内容了。匹配什么内容呢？如果要所有内容那就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String reg&#x3D;&quot;.+(?&#x3D;&lt;&#x2F;span&gt;)&quot;;</span><br><span class="line"></span><br><span class="line">String test &#x3D; &quot;&lt;span class&#x3D;\&quot;read-count\&quot;&gt;阅读数：641&lt;&#x2F;span&gt;&quot;;</span><br><span class="line">Pattern pattern &#x3D; Pattern.compile(reg);</span><br><span class="line">Matcher mc&#x3D;    pattern.matcher(test);</span><br><span class="line">while(mc.find())&#123;</span><br><span class="line">  System.out.println(&quot;匹配结果：&quot;)</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匹配结果：</span><br><span class="line">&#x2F;&#x2F;&lt;span class&#x3D;&quot;read-count&quot;&gt;阅读数：641</span><br></pre></td></tr></table></figure>
<p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d, 那可以改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg&#x3D;&quot;\\d+(?&#x3D;&lt;&#x2F;span&gt;)&quot;;</span><br><span class="line">String test &#x3D; &quot;&lt;span class&#x3D;\&quot;read-count\&quot;&gt;阅读数：641&lt;&#x2F;span&gt;&quot;;</span><br><span class="line">Pattern pattern &#x3D; Pattern.compile(reg);</span><br><span class="line">Matcher mc&#x3D;    pattern.matcher(test);</span><br><span class="line">while(mc.find())&#123;</span><br><span class="line">  System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;匹配结果：</span><br><span class="line">&#x2F;&#x2F;641</span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<ul>
<li>正向后行断言（正后顾）<br>语法：<code>（?&lt;=pattern）</code></li>
</ul>
<p>作用：匹配 pattern 表达式的后面的内容，不返回本身。</p>
<p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。<br>上面的栗子，我们也可以用后行断言来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;(?&lt;&#x3D;&lt;span class&#x3D;&quot;read-count&quot;&gt;阅读数：)\d+</span><br><span class="line">String reg&#x3D;&quot;(?&lt;&#x3D;&lt;span class&#x3D;\&quot;read-count\&quot;&gt;阅读数：)\\d+&quot;;</span><br><span class="line"></span><br><span class="line">String test &#x3D; &quot;&lt;span class&#x3D;\&quot;read-count\&quot;&gt;阅读数：641&lt;&#x2F;span&gt;&quot;;</span><br><span class="line">Pattern pattern &#x3D; Pattern.compile(reg);</span><br><span class="line">Matcher mc&#x3D;    pattern.matcher(test);</span><br><span class="line">        while(mc.find())&#123;</span><br><span class="line">            System.out.println(mc.group());</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;匹配结果：</span><br><span class="line">&#x2F;&#x2F;641</span><br></pre></td></tr></table></figure>
<p>就这么简单。</p>
<ul>
<li>负向先行断言（负前瞻）<br>语法：<code>(?!pattern)</code></li>
</ul>
<p>作用：匹配非 pattern 表达式的前面内容，不返回本身。</p>
<p>有正向也有负向，负向在这里其实就是非的意思。</p>
<p>举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”</p>
<p>现在要找到不是’的花朵’前面的祖国</p>
<p>用正则就可以这样写：</p>
<p><code>祖国(?!的花朵)</code></p>
<ul>
<li>负向后行断言（负后顾）<br>语法：<code>(?&lt;!pattern)</code></li>
</ul>
<p>作用：匹配非 pattern 表达式的后面内容，不返回本身。</p>
<h1 id="8-捕获和非捕获"><a href="#8-捕获和非捕获" class="headerlink" title="8. 捕获和非捕获"></a>8. 捕获和非捕获</h1><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”。</p>
<p><em>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</em></p>
<p>而根据命名方式的不同，又可以分为两种组：</p>
<ul>
<li>数字编号捕获组：<br>语法：<code>(exp)</code></li>
</ul>
<p>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第 0 组为整个表达式，第一组开始为分组。</p>
<p>比如固定电话的：020-85653333</p>
<p>他的正则表达式为：<code>(0\d&#123;2&#125;)-(\d&#123;8&#125;)</code></p>
<p>按照左括号的顺序，这个表达式有如下分组：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
<tr>
<td>我们用Java来验证一下：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String test &#x3D; &quot;020-85653333&quot;;</span><br><span class="line">        String reg&#x3D;&quot;(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)&quot;;</span><br><span class="line">        Pattern pattern &#x3D; Pattern.compile(reg);</span><br><span class="line">        Matcher mc&#x3D; pattern.matcher(test);</span><br><span class="line">        if(mc.find())&#123;</span><br><span class="line">            System.out.println(&quot;分组的个数有：&quot;+mc.groupCount());</span><br><span class="line">            for(int i&#x3D;0;i&lt;&#x3D;mc.groupCount();i++)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot;+i+&quot;个分组为：&quot;+mc.group(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：020</span><br><span class="line">第2个分组为：85653333</span><br></pre></td></tr></table></figure>
<p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p>
<ul>
<li>命名编号捕获组<br>语法：<code>(?&lt;name&gt;exp)</code></li>
</ul>
<p>解释：分组的命名由表达式中的 name 指定</p>
<p>比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})，按照左括号的顺序，这个表达式有如下分组：</p>
<p>序号|名称|分组|内容<br>|——-|——-|——-|——-|<br>|0|0|(0\d{2})-(\d{8})|020-85653333<br>|1|quhao|(0\d{2})|020<br>|2|haoma|(\d{8})|85653333<br>用代码来验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String test &#x3D; &quot;020-85653333&quot;;</span><br><span class="line">        String reg&#x3D;&quot;(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)&quot;;</span><br><span class="line">        Pattern pattern &#x3D; Pattern.compile(reg);</span><br><span class="line">        Matcher mc&#x3D; pattern.matcher(test);</span><br><span class="line">        if(mc.find())&#123;</span><br><span class="line">            System.out.println(&quot;分组的个数有：&quot;+mc.groupCount());</span><br><span class="line">            System.out.println(mc.group(&quot;quhao&quot;));</span><br><span class="line">            System.out.println(mc.group(&quot;haoma&quot;));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：2</span><br><span class="line">分组名称为:quhao,匹配内容为：020</span><br><span class="line"></span><br><span class="line">分组名称为:haoma,匹配内容为：85653333</span><br></pre></td></tr></table></figure>
<ul>
<li>非捕获组<br>语法：<code>(?:exp)</code></li>
</ul>
<p>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</p>
<p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\0\d&#123;2&#125;)-(\d&#123;8&#125;)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
<tr>
<td>验证一下：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String test &#x3D; &quot;020-85653333&quot;;</span><br><span class="line">        String reg&#x3D;&quot;(?:0\\d&#123;2&#125;)-(\\d&#123;8&#125;)&quot;;</span><br><span class="line">        Pattern pattern &#x3D; Pattern.compile(reg);</span><br><span class="line">        Matcher mc&#x3D; pattern.matcher(test);</span><br><span class="line">        if(mc.find())&#123;</span><br><span class="line">                System.out.println(&quot;分组的个数有：&quot;+mc.groupCount());</span><br><span class="line">                for(int i&#x3D;0;i&lt;&#x3D;mc.groupCount();i++)&#123;</span><br><span class="line">                    System.out.println(&quot;第&quot;+i+&quot;个分组为：&quot;+mc.group(i));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分组的个数有：1</span><br><span class="line">第0个分组为：020-85653333</span><br><span class="line">第1个分组为：85653333</span><br></pre></td></tr></table></figure>

<h1 id="9-反向引用"><a href="#9-反向引用" class="headerlink" title="9. 反向引用"></a>9. 反向引用</h1><p>上面讲到捕获，我们知道：捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<p>数字编号组反向引用：\k 或\number</p>
<p>命名编号组反向引用：\k 或者&#39;name’</p>
<p>好了 讲完了，懂吗？不懂！！！</p>
<p>可能连前面讲的捕获有什么用都还不懂吧？</p>
<p>其实只是看完捕获不懂不会用是很正常的！</p>
<p>因为捕获组通常是和反向引用一起使用的</p>
<p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。</p>
<p>注意两个字眼：“内容” 和 “使用”。</p>
<p>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住。</p>
<p>那这里所说的“使用”是怎样使用呢？</p>
<p>因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。</p>
<p>还是举栗子吧：</p>
<p>比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母。</p>
<p>如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，现在我们先用程序思维理一下思路：</p>
<p>1）匹配到一个字母</p>
<p>2）匹配第下一个字母，检查是否和上一个字母是否一样</p>
<p>3）如果一样，则匹配成功，否则失败</p>
<p>这里的思路 2 中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？</p>
<p>这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件。</p>
<p>好了，有思路就要实践</p>
<p>首先匹配一个字母：\w，我们需要做成分组才能捕获，因此写成这样：(\w)</p>
<p>那这个表达式就有一个捕获组：（\w）</p>
<p>然后我们要用这个捕获组作为条件，那就可以：(\w)\1这样就大功告成了</p>
<p>可能有人不明白了，\1 是什么意思呢？</p>
<p>还记得捕获组有两种命名方式吗，<em>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名在默认情况下都是以数字来命名，而且数字命名的顺序是从 1 开始的。</em></p>
<p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k&lt;1&gt;或者\1，当然，通常都是是后者。</p>
<p>我们来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String test &#x3D; &quot;aabbbbgbddesddfiid&quot;;</span><br><span class="line">        Pattern pattern &#x3D; Pattern.compile(&quot;(\\w)\\1&quot;);</span><br><span class="line">        Matcher mc&#x3D; pattern.matcher(test);</span><br><span class="line">        while(mc.find())&#123;</span><br><span class="line">            System.out.println(mc.group());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br></pre></td></tr></table></figure>
<p>嗯，这就是我们想要的了。<br>在举个替换的例子，假如想要把字符串中abc换成a。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String test &#x3D; &quot;abcbbabcbcgbddesddfiid&quot;;</span><br><span class="line">String reg&#x3D;&quot;(a)(b)c&quot;;</span><br><span class="line">System.out.println(test.replaceAll(reg, &quot;$1&quot;));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1abbabcgbddesddfiid</span><br></pre></td></tr></table></figure>

<h1 id="10-贪婪和非贪婪"><a href="#10-贪婪和非贪婪" class="headerlink" title="10. 贪婪和非贪婪"></a>10. 贪婪和非贪婪</h1><ul>
<li>贪婪<br>我们都知道，贪婪就是不满足，尽可能多的要。在正则中，贪婪也是差不多的意思:</li>
</ul>
<p><em>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。</em></p>
<p><em>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配 - 舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</em></p>
<p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,6&#125;</span><br></pre></td></tr></table></figure>
<p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg&#x3D;&quot;\\d&#123;3,6&#125;&quot;;        </span><br><span class="line">String test&#x3D;&quot;61762828 176 2991 871&quot;;</span><br><span class="line">System.out.println(&quot;文本：&quot;+test);</span><br><span class="line">System.out.println(&quot;贪婪模式：&quot;+reg);</span><br><span class="line">Pattern p1 &#x3D;Pattern.compile(reg);</span><br><span class="line">Matcher m1 &#x3D; p1.matcher(test);</span><br><span class="line">   while(m1.find())&#123;</span><br><span class="line">      System.out.println(&quot;匹配结果：&quot;+m1.group(0));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 44 871</span><br><span class="line">贪婪模式：\d&#123;3,6&#125;</span><br><span class="line">匹配结果：617628</span><br><span class="line">匹配结果：176</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：871</span><br></pre></td></tr></table></figure>
<p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。</p>
<p>一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p>
<p><em>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg&#x3D;&quot;(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)&quot;;        </span><br><span class="line">String test&#x3D;&quot;61762828 176 2991 87321&quot;;</span><br><span class="line">System.out.println(&quot;文本：&quot;+test);</span><br><span class="line">System.out.println(&quot;贪婪模式：&quot;+reg);</span><br><span class="line">Pattern p1 &#x3D;Pattern.compile(reg);</span><br><span class="line">Matcher m1 &#x3D; p1.matcher(test);</span><br><span class="line">  while(m1.find())&#123;</span><br><span class="line">      System.out.println(&quot;匹配结果：&quot;+m1.group(0));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 87321</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;)(\d&#123;3,4&#125;)</span><br><span class="line">匹配结果：617628</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：87321</span><br></pre></td></tr></table></figure>
<p>“617628” 是前面的\d{1,2}匹配出了 61，后面的匹配出了 7628</p>
<p>“2991” 是前面的\d{1,2}匹配出了 29 ，后面的匹配出了 91</p>
<p>“87321”是前面的\d{1,2}匹配出了 87，后面的匹配出了 321</p>
<ul>
<li>懒惰（非贪婪）<br><em>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。</em></li>
</ul>
<p><em>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</em></p>
<p>懒惰量词是在贪婪量词后面加个“？”</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String reg&#x3D;&quot;(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;)&quot;;        </span><br><span class="line">        String test&#x3D;&quot;61762828 176 2991 87321&quot;;</span><br><span class="line">        System.out.println(&quot;文本：&quot;+test);</span><br><span class="line">        System.out.println(&quot;贪婪模式：&quot;+reg);</span><br><span class="line">        Pattern p1 &#x3D;Pattern.compile(reg);</span><br><span class="line">        Matcher m1 &#x3D; p1.matcher(test);</span><br><span class="line">        while(m1.find())&#123;</span><br><span class="line">            System.out.println(&quot;匹配结果：&quot;+m1.group(0));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本：61762828 176 2991 87321</span><br><span class="line">贪婪模式：(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;)</span><br><span class="line">匹配结果：61762</span><br><span class="line">匹配结果：2991</span><br><span class="line">匹配结果：87321</span><br></pre></td></tr></table></figure>
<p>解答：</p>
<p>“61762” 是左边的懒惰匹配出 6，右边的贪婪匹配出 1762</p>
<p>“2991” 是左边的懒惰匹配出 2，右边的贪婪匹配出 991</p>
<p>“87321” 左边的懒惰匹配出 8，右边的贪婪匹配出 7321</p>
<h1 id="11-反义"><a href="#11-反义" class="headerlink" title="11. 反义"></a>11. 反义</h1><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<p>正则知识就讲到这里，正则是一门博大精深的语言，其实学会它的一些语法和知识点还算不太难，但想要做到真正学以致用能写出非常 6 的正则，还有很远的距离，只有真正对它感兴趣的，并且经常研究和使用它，才会渐渐的理解它的博大精深之处，我就带你们走到这，剩下的，靠自己啦。</p>
<blockquote>
<p>作者：公众号（编程无界）<br>链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CBexZfG1DHYji_Pk6Zo38w">https://mp.weixin.qq.com/s/CBexZfG1DHYji_Pk6Zo38w</a><br>来源：微信公众号<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%B7%A5%E5%85%B7/"># 工具</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/">数据结构绪论</a>
            
            
            <a class="next" rel="next" href="/2020/11/09/%E9%80%9A%E8%BF%87JS%E5%B0%86%E5%9B%BE%E7%89%87File%E8%BD%AC%E4%B8%BAbase64%E5%B9%B6%E5%8E%8B%E7%BC%A9/">通过JS将图片File转为base64并压缩</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Allen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>